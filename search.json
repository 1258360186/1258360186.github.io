[{"title":"圆的面积","url":"/2021/10/17/Area-of-circle/","content":"音乐小港\n    \n\n\n圆的面积题目计算圆的面积的公式定义为 。\n请利用这个公式计算所给圆的面积。\n 的取值为 。\n输入格式输入包含一个浮点数，为圆的半径 。\n输出格式输出格式为 A=X，其中  为圆的面积，用浮点数表示，保留四位小数。\n数据范围\n输入样例2.00\n\n输出样例A=12.5664\n\nAC代码#include&lt;cstdio&gt;int main(){    double pi = 3.14159, r;    scanf(\"%lf\",&amp;r);    printf(\"A=%.4lf\",pi*r*r);}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"A+B","url":"/2021/10/17/A-B/","content":"音乐小港\n    \n\n\nA + B题目输入两个整数，求这两个整数的和是多少。\n输入格式输入两个整数A,B，用空格隔开，\n输出格式输出一个整数，表示这两个数的和\n数据范围输入样例3 4\n\n输出样例7\n\nAC代码#include &lt;iostream&gt;using namespace std;int a;int b;int main(){    cin &gt;&gt; a &gt;&gt; b;    cout &lt;&lt; a+b;    return 0;}\n\n解题思路\n\n\n","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"平均数1","url":"/2021/10/17/Average%E2%80%941/","content":"音乐小港\n    \n\n\n平均数1题目读取两个浮点数 A 和 B 的值，对应于两个学生的成绩。\n请你计算学生的平均分，其中 A 的成绩的权重为 3.5，B 的成绩的权重为 7.5。\n成绩的取值范围在 0 到 10 之间，且均保留一位小数。\n输入格式输入占两行，每行包含一个浮点数，第一行表示 A，第二行表示 B。\n输出格式输出格式为 MEDIA = X，其中  为平均分，结果保留五位小数。\n数据范围\n输入样例5.07.1\n\n输出样例MEDIA = 6.43182\n\nAC代码#include&lt;cstdio&gt;int main(){    float a,b;    scanf(\"%f\\n%f\",&amp;a,&amp;b);    printf(\"MEDIA = %.5f\",(3.5*a+7.5*b)/(3.5+7.5));}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"线程的创建与使用","url":"/2021/10/18/CPP-multithreaded-0/","content":"音乐小港\n    \n\n\n线程的创建与使用线程的创建在使用线程之前，我们首先要学会如何创建一个新的线程。不管是哪个库还是哪种高级语言（如 Java），线程的创建最终还是调用操作系统的 API 来进行的。我们这里先介绍操作系统的接口，这里分为 Linux 和 Windows 两个常用的操作系统平台来介绍。当然，这里并不是照本宣科地把 Linux man 手册或者 msdn 上的函数签名搬过来，而是只介绍我们实际开发中常用的参数和需要注意的重难点。\nLinux 线程创建Linux 平台上使用 pthread_create 这个 API 来创建线程，其函数签名如下。\nint pthread_create(pthread_t *thread,                    const pthread_attr_t *attr,                   void *(*start_routine) (void *),                    void *arg);\n\n参数 thread，是一个输出参数，如果线程创建成功，则通过这个参数可以得到创建成功的线程 ID（下文会介绍线程 ID 的知识）。\n参数 attr 指定了该线程的属性，一般设置为 NULL，表示使用默认属性。\n参数 start_routine 指定了线程函数，这里需要注意的是这个函数的调用方式必须是 __cdecl 调用，即 C Declaration 的缩写，这是 C/C++ 中定义函数时默认的调用方式，一般很少有人注意到这一点。而后面我们介绍在 Windows 操作系统上使用 CreateThread 定义线程函数时必须使用 __stdcall 调用方式时，由于函数不是默认函数调用方式，所以我们必须显式声明函数的调用方式了。  也就是说，如下函数的调用方式是等价的：//代码片段1： 不显式指定函数调用方式，其调用方式为默认的 __cdeclvoid* start_routine (void* args){}//代码片段2： 显式指定函数调用方式为默认的 __cdecl，等价于代码片段1void* __cdecl start_routine (void* args){}\n参数 arg，通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个 void* 类型，可以方便我们最大化地传入任意多的信息给线程函数（下文会介绍一个使用示例）。\n返回值：如果成功创建线程，则返回 0；如果创建失败，则返回相应的错误码。常见的错误码有 EAGAIN、EINVAL。EAGAIN 表示系统资源不足导致线程无法创建（如达到系统限制的最大线程数目），EINVAL 表示传入了无效的参数 attr。在实际开发只要我们正确的设置了各个参数，一般不关心该函数的返回值，即一般认为线程可以正确创建出来。\n\n下面是一个使用 pthread_create 创建线程的简单示例：\n#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;void* threadfunc(void* arg){  while(1)  {    //睡眠1秒    sleep(1);    printf(\"I am New Thread!\\n\");  }}int main(){  pthread_t threadid;  pthread_create(&amp;threadid, NULL, threadfunc, NULL);  while (1)  {    sleep(1);    //权宜之计，让主线程不要提前退出  }  return 0;}\n上述代码片段利用 pthread_create 函数在主线程创建了一个工作线程，线程函数为 threadfunc。\nWindows 线程创建Windows 上创建线程使用 CreateThread，其函数签名如下：\nHANDLE CreateThread(  LPSECURITY_ATTRIBUTES   lpThreadAttributes,  SIZE_T                  dwStackSize,  LPTHREAD_START_ROUTINE  lpStartAddress,  LPVOID                  lpParameter,  DWORD                   dwCreationFlags,  LPDWORD                 lpThreadId);\n\n参数 lpThreadAttributes，是线程的安全属性，一般设置为 NULL。\n参数 dwStackSize，线程的栈空间大小，单位为字节数，一般指定为 0，表示使用默认大小。\n参数 lpStartAddress，为线程函数，其类型是 LPTHREAD_START_ROUTINE，这是一个函数指针类型，其定义如下：typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )(LPVOID lpThreadParameter);\n\n需要注意的是，Windows 上创建的线程的线程函数其调用方式必须是__stdcall，如果将如下函数设置成线程函数是不行的：\n\nDWORD threadfunc(LPVOID lpThreadParameter);\n如上文所说，如果不指定函数的调用方式，使用默认调用方式 __cdecl，而这里的线程函数要求是 __stdcall，因此必须在函数名前面显式指定函数调用方式为 __stdcall。DWORD __stdcall threadfunc(LPVOID lpThreadParameter);\nWindows 上的宏 WINAPI 和 CALLBACK 这两个宏的定义都是 __stdcall。因为在项目中看到的线程函数的签名大多写成如下两种形式的一种：//写法1DWORD WINAPI threadfunc(LPVOID lpThreadParameter);//写法2DWORD CALLBACK threadfunc(LPVOID lpThreadParameter);\n参数 lpParameter 为传给线程函数的参数，和 Linux 下的 pthread_create 函数的 arg 一样，这实际上也是一个 void* 类型（LPVOID 类型是用 typedef 包装后的 void* 类型）。typedef void* LPVOID;\n参数 dwCreationFlags，是一个 32 位无符号整型（DWORD），一般设置为 0，表示创建好线程后立即启动线程的运行；有一些特殊的情况，我们不希望创建线程后立即开始执行，可以将这个值设置为 4（对应 Windows 定义的宏 CREATE_SUSPENDED），后面在需要的时候，再使用 ResumeThread 这个 API 让线程运行起来。\n参数 lpThreadId，为线程创建成功返回的线程 ID，这也是一个 32 位无符号整数（DWORD）的指针（LPDWORD）。\n返回值：Windows 上使用句柄（HANDLE 类型）来管理线程对象，句柄本质上是内核句柄表中的索引值。如果成功创建线程，则返回该线程的句柄；如果创建失败，则返回 NULL。\n\n下面的代码片段，演示了 Windows 上如何创建一个线程：\n#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;DWORD WINAPI ThreadProc(LPVOID lpParameters){    while (true)    {        //睡眠 1 秒，Windows 上的 Sleep 函数参数事件单位为毫秒        Sleep(1000);        printf(\"I am New Thread!\\n\");    }}int main(){    DWORD dwThreadID;    HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &amp;dwThreadID);    if (hThread == NULL)    {        printf(\"Failed to CreateThread.\\n\");    }    while (true)    {        Sleep(1000);        //权宜之计，让主线程不要提前退出    }    return 0;}\n上述代码片段利用 CreateThread 函数在主线程创建了一个工作线程，线程函数为 ThreadProc，线程函数名 ThreadProc 符合 Windows 程序设计风格。\nWindows CRT 提供的线程创建函数这里的 CRT，指的是 C Runtime（C 运行时），通俗地说就是 C 函数库。在 Windows 操作系统上，微软实现的 C 库也提供了一套用于创建线程的函数（当然这个函数底层还是调用相应的操作系统平台的线程创建 API）。在实际项目开发中推荐使用这个函数来创建线程而不是使用 CreateThread 函数。\nWindows C 库创建线程常用的函数是 _beginthreadex，声明位于 process.h 头文件中，其签名如下：\nuintptr_t _beginthreadex(    void *security,     unsigned stack_size,     unsigned ( __stdcall *start_address )( void * ),     void *arglist,     unsigned initflag,     unsigned *thrdaddr   );  \n函数签名基本上和 Windows 上的 CreateThread 函数基本一致，这里就不再赘述了。\n以下是使用 _beginthreadex 创建线程的一个例子：\n#include &lt;process.h&gt;//#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;unsigned int __stdcall threadfun(void* args){    while (true)    {                //Sleep(1000);        printf(\"I am New Thread!\\n\");    }}int main(int argc, char* argv[]){    unsigned int threadid;    _beginthreadex(0, 0, threadfun, 0, 0, &amp;threadid);    while (true)    {        //Sleep(1000);        //权宜之计，让主线程不要提前退出    }    return 0;}\n上述代码片段利用 _beginthreadex 函数在主线程创建了一个工作线程，线程函数为 threadfun。\nC++ 11 提供的 std::thread 类无论是 Linux 还是 Windows 上创建线程的 API，都有一个非常不方便的地方，就是线程函数的签名必须是固定的格式（参数个数和类型、返回值类型都有要求）。C++11 新标准引入了一个新的类 std::thread（需要包含头文件 &lt;thread&gt;），使用这个类的可以将任何签名形式的函数作为线程函数。以下代码分别创建两个线程，线程函数签名不一样：\n#include &lt;stdio.h&gt;#include &lt;thread&gt;void threadproc1(){    while (true)    {        printf(\"I am New Thread 1!\\n\");    }}void threadproc2(int a, int b){    while (true)    {        printf(\"I am New Thread 2!\\n\");    }}int main(){    //创建线程t1    std::thread t1(threadproc1);    //创建线程t2    std::thread t2(threadproc2, 1, 2);    while (true)    {        //Sleep(1000);        //权宜之计，让主线程不要提前退出    }    return 0;}\n当然， std::thread 在使用上容易犯一个错误，即在 std::thread 对象在线程函数运行期间必须是有效的。什么意思呢？我们来看一个例子：\n#include &lt;stdio.h&gt;#include &lt;thread&gt;void threadproc(){    while (true)    {        printf(\"I am New Thread!\\n\");    }}void func(){    std::thread t(threadproc);}int main(){    func();    while (true)    {        //Sleep(1000);        //权宜之计，让主线程不要提前退出    }    return 0;}\n上述代码在 func 中创建了一个线程，然后又在 main 函数中调用 func 方法，乍一看好像代码没什么问题，但是在实际运行时程序会崩溃。崩溃的原因是，当 func 函数调用结束后，func 中局部变量 t （线程对象）被销毁了，而此时线程函数仍然在运行。这就是我所说的，使用 std::thread 类时，必须保证线程函数运行期间，其线程对象有效。这是一个很容易犯的错误，解决这个问题的方法是，std::thread 对象提供了一个 detach 方法，这个方法让线程对象与线程函数脱离关系，这样即使线程对象被销毁，仍然不影响线程函数的运行。我们只需要在 func 函数中调用 detach 方法即可，代码如下：\n//其他代码保持不变，这里就不重复贴出来了void func(){    std::thread t(threadproc);    t.detach();}\n然而，在实际编码中，这也是一个不推荐的做法，原因是我们需要使用线程对象去控制和管理线程的运行和生命周期。所以，我们的代码应该尽量保证线程对象在线程运行期间有效，而不是单纯地调用 detach 方法使线程对象与线程函数的运行分离。\n总结本讲介绍了 Linux 和 Windows 平台的线程创建基础 API，同时也介绍了 CRT 和 C++ 11 语言标准提供的创建线程的方法（它们可以方便我们写跨平台代码），但是读者一定要明白 CRT 和 C++ 11 创建线程的函数其实现是在对应的操作系统平台调用我们介绍的线程创建函数。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"线程 ID 的用途及原理","url":"/2021/10/18/CPP-multithreaded-1/","content":"音乐小港\n    \n\n\n线程 ID 的用途及原理前面介绍了如何创建一个线程，本讲我们来介绍一下线程 ID 的内容，线程 ID 一般是用于标识一个线程的整形数值。\n线程 ID一个线程创建成功以后，我们可以拿到一个线程 ID。我们可以使用线程 ID 来标识和区分线程，例如在日志文件中，把打印日志的所在的线程 ID 也一起打印出来，我们通过线程 ID 来确定日志内容是不是属于同一个线程上下文。创建线程时，上文也介绍了可以通过 pthread_create 函数的第一个参数 thread （linux平台）和 CreateThread 函数的最后一个参数 lpThreadId （Windows平台）得到线程的 ID。大多数时候，我们需要在当前调用线程中获取当前线程的 ID，在 Linux 平台上可以使用 pthread_self 函数（还有另外两种方式，下问介绍），在 Windows 平台上可以使用 GetCurrentThreadID 函数获取，这两个函数的签名分别如下：\npthread_t pthread_self(void);DWORD GetCurrentThreadId();\n这两个函数比较简单，这里就不介绍了，无论是 pthread_t 还是 DWORD 类型，都是一个 32 位无符号整型值。\n在 Windows 7 操作系统中可以在任务管理器中查看某个进程的线程数量：\n\n上图中标红的一栏即每个进程的线程数量，例如对于 vmware-tray.exe 进程一共有三个线程。如果读者打开任务管理器没有看到线程数这一列，可以点击任务管理器的 【查看】- 【选择列】菜单，在弹出的对话框中勾选线程数即可显示出线程数这一列。\nLinux 系统线程 ID 的本质Linux 系统中有三种方式可以获取一个线程的 ID。\n方法一调用 pthread_create 函数时，第一个参数在函数调用成功后可以得到线程 ID：\n#include &lt;pthread.h&gt;pthread_t tid;pthread_create(&amp;tid, NULL, thread_proc, NULL);\npthread_create 函数我们在前面篇幅中已经介绍过了。\n方法二在需要获取 ID 的线程中调用 pthread_self() 函数获取。\n#include &lt;pthread.h&gt;pthread_t tid = pthread_self();\n方法三通过系统调用获取线程 ID\n#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;int tid = syscall(SYS_gettid);\n方法一和方法二获取的线程 ID 结果是一样的，这是一个 pthread_t，输出时本质上是一块内存空间地址，示意图如下：\n\n由于不同的进程可能有同样地址的内存块，因此方法一和方法二获取的线程 ID 可能不是全系统唯一的，一般是一个很大的数字（内存地址）。而方法三获取的线程 ID 是系统范围内全局唯一的，一般是一个不会太大的整数，这个数字也是就是所谓的 LWP （Light Weight Process，轻量级进程，早期的 Linux 系统的线程是通过进程来实现的，这种线程被称为轻量级线程）的 ID。\n我们来看一段具体的代码：\n#include &lt;sys/syscall.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;pthread.h&gt;void* thread_proc(void* arg){    pthread_t* tid1 = (pthread_t*)arg;    int tid2 = syscall(SYS_gettid);    pthread_t tid3 = pthread_self();    while(true)    {        printf(\"tid1: %ld, tid2: %ld, tid3: %ld\\n\", *tid1, tid2, tid3);        sleep(1);    }}int main(){        pthread_t tid;    pthread_create(&amp;tid, NULL, thread_proc, &amp;tid);    pthread_join(tid, NULL);    return 0;}\n上述代码在新开的线程中使用上面介绍的三种方式获取线程 ID，并打印出来，输出结果如下：\ntid1: 140185007511296, tid2: 60837, tid3: 140185007511296\ntid2 即 LWP 的 ID，而 tid1 和 tid3 是一个内存地址，转换成 16 进制即：\n0x7F7F5D935700\n这与我们用 pstack 命令看到的线程 ID 是一样的：\n[root@localhost ~]# ps -efL | grep linuxtidroot     60712 60363 60712  0    2 13:25 pts/1    00:00:00 ./linuxtidroot     60712 60363 60713  0    2 13:25 pts/1    00:00:00 ./linuxtidroot     60720 60364 60720  0    1 13:25 pts/3    00:00:00 grep --color=auto linuxtid[root@localhost ~]# pstack 60712Thread 2 (Thread 0x7fd897a50700 (LWP 60713)):#0  0x00007fd897b15e2d in nanosleep () from /lib64/libc.so.6#1  0x00007fd897b15cc4 in sleep () from /lib64/libc.so.6#2  0x0000000000400746 in thread_proc (arg=0x7fff390921c8) at linuxtid.cpp:15#3  0x00007fd898644dd5 in start_thread () from /lib64/libpthread.so.0#4  0x00007fd897b4eead in clone () from /lib64/libc.so.6Thread 1 (Thread 0x7fd898a6e740 (LWP 60712)):#0  0x00007fd898645f47 in pthread_join () from /lib64/libpthread.so.0#1  0x000000000040077e in main () at linuxtid.cpp:25[root@localhost ~]# ps -ef | grep linuxtidroot     60838 60363  0 14:27 pts/1    00:00:00 ./linuxtidroot     60846 60364  0 14:28 pts/3    00:00:00 grep --color=auto linuxtid[root@localhost ~]# pstack 60838Thread 2 (Thread 0x7f7f5d935700 (LWP 60839)):#0  0x00007f7f5d9fae2d in nanosleep () from /lib64/libc.so.6#1  0x00007f7f5d9facc4 in sleep () from /lib64/libc.so.6#2  0x0000000000400746 in thread_proc (arg=0x7fff0523ae68) at linuxtid.cpp:15#3  0x00007f7f5e529dd5 in start_thread () from /lib64/libpthread.so.0#4  0x00007f7f5da33ead in clone () from /lib64/libc.so.6Thread 1 (Thread 0x7f7f5e953740 (LWP 60838)):#0  0x00007f7f5e52af47 in pthread_join () from /lib64/libpthread.so.0#1  0x000000000040077e in main () at linuxtid.cpp:25\nC++11 的获取当前线程 ID 的方法C++11 的线程库可以使用 std::thisthread 类的 getid 获取当前线程的 id，这是一个类静态方法。\n当然也可以使用 std::thread 的 get_id 获取指定线程的 id，这是一个类实例方法。\n但是 get_id 方法返回的是一个包装类型的 std::thread::id 对象，不可以直接强转成整型，也没有提供任何转换成整型的接口。所以，我们一般使用 std::cout 这样的输出流来输出，或者先转换为 std::ostringstream 对象，再转换成字符串类型，然后把字符串类型转换成我们需要的整型。这一点，个人觉得算是 C++11 线程库获取线程 id 一个不太方便的地方。\n//test_cpp11_thread_id.cpp#include &lt;thread&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;void worker_thread_func(){    while (true)    {    }}int main(){    std::thread t(worker_thread_func);    //获取线程 t 的 ID    std::thread::id worker_thread_id = t.get_id();    std::cout &lt;&lt; \"worker thread id: \" &lt;&lt; worker_thread_id &lt;&lt; std::endl;    //获取主线程的线程 ID    std::thread::id main_thread_id = std::this_thread::get_id();    //先将 std::thread::id 转换成 std::ostringstream 对象    std::ostringstream oss;    oss &lt;&lt; main_thread_id;    //再将 std::ostringstream 对象转换成std::string    std::string str = oss.str();    std::cout &lt;&lt; \"main thread id: \" &lt;&lt; str &lt;&lt; std::endl;    //最后将 std::string 转换成整型值    unsigned long long threadid = std::stoull(str);    std::cout &lt;&lt; \"main thread id: \" &lt;&lt; threadid &lt;&lt; std::endl;    while (true)    {        //权宜之计，让主线程不要提前退出    }    return 0;}\n在 Linux x64 系统上编译并运行程序，输出结果如下：\n[root@myaliyun codes]# g++ -g -o test_cpp11_thread_id test_cpp11_thread_id.cpp -lpthread[root@myaliyun codes]# ./test_cpp11_thread_id worker thread id: 139875808245504main thread id: 139875825641280main thread id: 139875825641280\n编译成 Windows x86 程序运行结果如下：\n\n总结线程 ID 在实际编码中是一个很重要的上下文信息，因此熟练地获取某个线程的线程 ID，是多线程编程的基本功之一。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Linux 线程同步之互斥体","url":"/2021/10/18/CPP-multithreaded-10/","content":"音乐小港\n    \n\n\nLinux 线程同步之互斥体介绍完 Windows 上的常用多线程同步内核对象后，我们来看一下 Linux 下的线程同步对象。本讲我们介绍一下 Linux 操作系统的 mutex 对象。\nLinux mutex 的用法介绍Linux 互斥体的用法和 Windows 的临界区对象用法很相似，一般也是通过限制多个线程同时执行某段代码来达到保护资源的目的。和接下来要介绍的信号量、条件变量一样，Linux 互斥体都实现在 NPTL （Native POSIX Thread Library）。在 NPTL 中我们使用数据结构 pthread_mutex_t 来表示一个互斥体对象（定义于 pthread.h 头文件中）。互斥体对象我们可以使用两种方式来初始化：\n\n使用 PTHREAD_MUTEX_INITIALIZER 直接给互斥体变量赋值示例代码如下：\n#include &lt;pthread.h&gt;pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;\n使用 pthread_mutex_init 函数初始化如果互斥量是动态分配的或者需要给互斥量设置属性，则需要使用 pthread_mutex_init 函数来初始化互斥体，这个函数的签名如下：\nint pthread_mutex_init(pthread_mutex_t* restrict mutex,                       const pthread_mutexattr_t* restrict attr);\n参数 mutex 即我们需要初始化的 mutex 对象的指针，参数 attr 是需要设置的互斥体属性，通常情况下，使用默认属性可以将这个参数设置为 NULL，后面会详细介绍每一种属性的用法。如果函数执行成功则会返回 0，如果执行失败则会返回一个具体的错误码信息。\npthread_mutex_init 代码示例如下：\n#include &lt;pthread.h&gt;pthread_mutex_t mymutex;pthread_mutex_init(&amp;mutex, NULL);\n当不再需要一个互斥体对象时，可以使用 pthread_mutex_destroy 函数来销毁它， pthread_mutex_destroy 函数的签名如下：\nint pthread_mutex_destroy(pthread_mutex_t* mutex);\n参数 mutex 即我们需要销毁的互斥体对象，如果函数执行成功会返回 0，如果执行失败会返回一个错误码表面出错原因。这里我们需要注意两点：\n\n使用 PTHREAD_MUTEX_INITIALIZER 初始化的互斥量无须销毁；\n\n不要去销毁一个已经加锁或正在被条件变量使用的互斥体对象，当互斥量处于已加锁的状态或者正在和条件变量配合使用时，调用 pthread_mutex_destroy 函数会返回 EBUSY 错误。以下代码段演示了尝试销毁一个被锁定的 mutex 对象：\n//test_destroy_locked_mutex.cpp#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;int main(){    pthread_mutex_t mymutex;    pthread_mutex_init(&amp;mymutex, NULL);    int ret = pthread_mutex_lock(&amp;mymutex);    //尝试对被锁定的mutex对象进行销毁    ret = pthread_mutex_destroy(&amp;mymutex);    if (ret != 0)    {        if (ret == EBUSY)            printf(\"EBUSY\\n\");        printf(\"Failed to destroy mutex.\\n\");    }    ret = pthread_mutex_unlock(&amp;mymutex);    //尝试对已经解锁的mutex对象进行销毁    ret = pthread_mutex_destroy(&amp;mymutex);    if (ret == 0)        printf(\"Succeeded to destroy mutex.\\n\");    return 0;}\n编译上述代码并执行得到我们期望的结果：\n[root@myaliyun codes]# g++ -g -o test_destroy_locked_mutex test_destroy_locked_mutex.cpp -lpthread[root@myaliyun codes]# ./test_destroy_locked_mutex EBUSYFailed to destroy mutex.Succeed to destroy mutex.\n在实际开发中，如果我们遵循正确的使用 mutex 的规范，如创建 mutex 对象后再对其加锁，加锁后才对其进行解锁操作，解锁后才做销毁操作，那么编码时一般不用考虑 pthread_mutex_init/pthread_mutex_destroy/pthread_mutex_lock/pthread_mutex_unlock 等函数的返回值。\n\n\n对于互斥体的加锁和解锁操作我们一般使用以下三个函数：\nint pthread_mutex_lock(pthread_mutex_t* mutex);int pthread_mutex_trylock(pthread_mutex_t* mutex);int pthread_mutex_unlock(pthread_mutex_t* mutex);\n参数 mutex 设置为我们需要加锁和解锁的互斥体对象，上述函数执行成功则返回 0；如果执行失败则返回一个错误码表示具体的出错原因。具体错误码，随互斥体对象的属性类型的不同而不同。\n设置互斥体对象的属性需要创建一个 pthread_mutexattr_t 类型的对象，和互斥体对象一样，需要使用 pthread_mutexattr_init 函数初始化之，当不需要这个属性对象时，记得使用 pthread_mutexattr_destroy 去销毁它，这两个函数的签名如下：\nint pthread_mutexattr_init(pthread_mutexattr_t* attr);int pthread_mutexattr_destroy(pthread_mutexattr_t* attr);\n使用 pthread_mutexattr_settype/pthread_mutexattr_gettype 设置或获取想要的属性类型：\nint pthread_mutexattr_settype(pthread_mutexattr_t* attr, int type);int pthread_mutexattr_gettype(const pthread_mutexattr_t* restrict attr, int* restrict type);\nmutex 锁的类型属性类型一般有如下取值：\nPTHREAD_MUTEX_NORMAL（普通锁）这是互斥体对象的默认属性（即上文中介绍的 pthread_mutex_init 第二个函数设置为 NULL）。当一个线程对一个普通锁加锁以后，其他线程会阻塞在 pthread_mutex_lock 调用处， 直到对互斥体加锁的线程释放了锁，我们来用一段实例代码来验证一下：\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;pthread_mutex_t mymutex;int             resourceNo = 0;void* worker_thread(void* param){    pthread_t threadID = pthread_self();    printf(\"thread start, ThreadID: %d\\n\", threadID);    while (true)    {        pthread_mutex_lock(&amp;mymutex);        printf(\"Mutex lock, resourceNo: %d, ThreadID: %d\\n\", resourceNo, threadID);        resourceNo++;        printf(\"Mutex unlock, resourceNo: %d, ThreadID: %d\\n\", resourceNo, threadID);        pthread_mutex_unlock(&amp;mymutex);        //休眠1秒        sleep(1);    }    return NULL;}int main(){    pthread_mutexattr_t mutex_attr;    pthread_mutexattr_init(&amp;mutex_attr);    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);    //创建5个工作线程    pthread_t threadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;threadID[i], NULL, worker_thread, NULL);    }    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(threadID[i], NULL);    }    pthread_mutex_destroy(&amp;mymutex);    pthread_mutexattr_destroy(&amp;mutex_attr);    return 0;}\n上述代码创建了 5 个工作线程，由于使用了互斥体保护资源 resourceNo，因而每次在 pthread_mutex_lock 与 pthread_mutex_unlock 之间的输出都是连续的，一个线程必须完成了这个工作，其他线程才有机会获得执行这段代码的机会，当一个线程拿到锁后，其他线程会阻塞在 pthread_mutex_lock 处。\n程序执行结果如下：\n[root@localhost testmultithread]# ./testthread start, ThreadID: 520349440Mutex lock, resourceNo: 0, ThreadID: 520349440Mutex unlock, resourceNo: 1, ThreadID: 520349440thread start, ThreadID: 545527552Mutex lock, resourceNo: 1, ThreadID: 545527552Mutex unlock, resourceNo: 2, ThreadID: 545527552thread start, ThreadID: 511956736Mutex lock, resourceNo: 2, ThreadID: 511956736Mutex unlock, resourceNo: 3, ThreadID: 511956736thread start, ThreadID: 537134848Mutex lock, resourceNo: 3, ThreadID: 537134848Mutex unlock, resourceNo: 4, ThreadID: 537134848thread start, ThreadID: 528742144Mutex lock, resourceNo: 4, ThreadID: 528742144Mutex unlock, resourceNo: 5, ThreadID: 528742144Mutex lock, resourceNo: 5, ThreadID: 545527552Mutex unlock, resourceNo: 6, ThreadID: 545527552Mutex lock, resourceNo: 6, ThreadID: 537134848Mutex unlock, resourceNo: 7, ThreadID: 537134848Mutex lock, resourceNo: 7, ThreadID: 528742144Mutex unlock, resourceNo: 8, ThreadID: 528742144Mutex lock, resourceNo: 8, ThreadID: 520349440Mutex unlock, resourceNo: 9, ThreadID: 520349440Mutex lock, resourceNo: 9, ThreadID: 511956736Mutex unlock, resourceNo: 10, ThreadID: 511956736Mutex lock, resourceNo: 10, ThreadID: 545527552Mutex unlock, resourceNo: 11, ThreadID: 545527552Mutex lock, resourceNo: 11, ThreadID: 537134848Mutex unlock, resourceNo: 12, ThreadID: 537134848Mutex lock, resourceNo: 12, ThreadID: 520349440Mutex unlock, resourceNo: 13, ThreadID: 520349440Mutex lock, resourceNo: 13, ThreadID: 528742144Mutex unlock, resourceNo: 14, ThreadID: 528742144Mutex lock, resourceNo: 14, ThreadID: 511956736Mutex unlock, resourceNo: 15, ThreadID: 511956736Mutex lock, resourceNo: 15, ThreadID: 528742144Mutex unlock, resourceNo: 16, ThreadID: 528742144Mutex lock, resourceNo: 16, ThreadID: 545527552Mutex unlock, resourceNo: 17, ThreadID: 545527552Mutex lock, resourceNo: 17, ThreadID: 520349440Mutex unlock, resourceNo: 18, ThreadID: 520349440Mutex lock, resourceNo: 18, ThreadID: 537134848Mutex unlock, resourceNo: 19, ThreadID: 537134848Mutex lock, resourceNo: 19, ThreadID: 511956736Mutex unlock, resourceNo: 20, ThreadID: 511956736Mutex lock, resourceNo: 20, ThreadID: 545527552Mutex unlock, resourceNo: 21, ThreadID: 545527552Mutex lock, resourceNo: 21, ThreadID: 528742144Mutex unlock, resourceNo: 22, ThreadID: 528742144Mutex lock, resourceNo: 22, ThreadID: 520349440Mutex unlock, resourceNo: 23, ThreadID: 520349440Mutex lock, resourceNo: 23, ThreadID: 537134848Mutex unlock, resourceNo: 24, ThreadID: 537134848Mutex lock, resourceNo: 24, ThreadID: 511956736Mutex unlock, resourceNo: 25, ThreadID: 511956736Mutex lock, resourceNo: 25, ThreadID: 528742144Mutex unlock, resourceNo: 26, ThreadID: 528742144Mutex lock, resourceNo: 26, ThreadID: 545527552Mutex unlock, resourceNo: 27, ThreadID: 545527552Mutex lock, resourceNo: 27, ThreadID: 520349440Mutex unlock, resourceNo: 28, ThreadID: 520349440Mutex lock, resourceNo: 28, ThreadID: 511956736Mutex unlock, resourceNo: 29, ThreadID: 511956736Mutex lock, resourceNo: 29, ThreadID: 537134848Mutex unlock, resourceNo: 30, ThreadID: 537134848\n一个线程如果对一个已经加锁的普通锁再次使用 pthread_mutex_lock 加锁，程序会阻塞在第二次调用 pthread_mutex_lock 代码处。测试代码如下：\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;int main(){    pthread_mutex_t mymutex;    pthread_mutexattr_t mutex_attr;    pthread_mutexattr_init(&amp;mutex_attr);    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);    int ret = pthread_mutex_lock(&amp;mymutex);    printf(\"ret = %d\\n\", ret);    ret = pthread_mutex_lock(&amp;mymutex);    printf(\"ret = %d\\n\", ret);    pthread_mutex_destroy(&amp;mymutex);    pthread_mutexattr_destroy(&amp;mutex_attr);    return 0;}\n编译并使用 gdb 将程序运行起来，程序只输出了一行，我们按 Ctrl + C （下文中 ^C 字符）将 gdb 中断下来，然后使用 bt 命令发现程序确实阻塞在第二个 pthread_mutex_lock 函数调用处：\n[root@localhost testmultithread]# g++ -g -o test test.cpp -lpthread[root@localhost testmultithread]# gdb testReading symbols from /root/testmultithread/test...done.(gdb) rStarting program: /root/testmultithread/test [Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".ret = 0^CProgram received signal SIGINT, Interrupt.0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64(gdb) bt#0  0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0#1  0x00007ffff7bc8dcb in _L_lock_883 () from /lib64/libpthread.so.0#2  0x00007ffff7bc8c98 in pthread_mutex_lock () from /lib64/libpthread.so.0#3  0x00000000004007f4 in main () at ConsoleApplication10.cpp:17(gdb) \n在这种类型的情况， pthread_mutex_trylock 函数如果拿不到锁，不会阻塞，函数会立即返回，并返回 EBUSY 错误码。\nPTHREAD_MUTEX_ERRORCHECK（检错锁）如果一个线程使用 pthread_mutex_lock 对已经加锁的互斥体对象再次加锁，pthread_mutex_lock 会返回 EDEADLK。\n我们验证一下线程对自己已经加锁的互斥体对象再次加锁是什么行为？\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;int main(){    pthread_mutex_t mymutex;    pthread_mutexattr_t mutex_attr;    pthread_mutexattr_init(&amp;mutex_attr);    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);    int ret = pthread_mutex_lock(&amp;mymutex);    printf(\"ret = %d\\n\", ret);    ret = pthread_mutex_lock(&amp;mymutex);    printf(\"ret = %d\\n\", ret);    if (ret == EDEADLK)    {        printf(\"EDEADLK\\n\");    }    pthread_mutex_destroy(&amp;mymutex);    pthread_mutexattr_destroy(&amp;mutex_attr);    return 0;}\n编译并运行程序，程序输出结果确实如上面所说：\n[root@localhost testmultithread]# g++ -g -o test11 test.cpp -lpthread[root@localhost testmultithread]# ./test11ret = 0ret = 35EDEADLK\n再来看一下，一个线程加锁，其他线程再次加锁的效果：\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;pthread_mutex_t mymutex;void* worker_thread(void* param){    pthread_t threadID = pthread_self();    printf(\"thread start, ThreadID: %d\\n\", threadID);    while (true)    {        int ret = pthread_mutex_lock(&amp;mymutex);        if (ret == EDEADLK)        {            printf(\"EDEADLK, ThreadID: %d\\n\", threadID);        }         else            printf(\"ret = %d, ThreadID: %d\\n\", ret, threadID);        //休眠1秒        sleep(1);    }    return NULL;}int main(){    pthread_mutexattr_t mutex_attr;    pthread_mutexattr_init(&amp;mutex_attr);    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);    int ret = pthread_mutex_lock(&amp;mymutex);    printf(\"ret = %d\\n\", ret);    //创建5个工作线程    pthread_t threadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;threadID[i], NULL, worker_thread, NULL);    }    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(threadID[i], NULL);    }    pthread_mutex_destroy(&amp;mymutex);    pthread_mutexattr_destroy(&amp;mutex_attr);    return 0;}\n编译程序，然后使用 gdb 运行起来，发现程序并没有有任何输出，按 Ctrl + C 中断下来，输入 info thread 命令发现工作线程均阻塞在 pthread_mutex_lock 函数调用处。操作及输出结果如下：\n[root@localhost testmultithread]# g++ -g -o test8 ConsoleApplication8.cpp -lpthread[root@localhost testmultithread]# ./test8ret = 0thread start, ThreadID: -1821989120thread start, ThreadID: -1830381824thread start, ThreadID: -1838774528thread start, ThreadID: -1847167232thread start, ThreadID: -1813596416^C[root@localhost testmultithread]# gdb test8GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7Copyright (C) 2013 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"and \"show warranty\" for details.This GDB was configured as \"x86_64-redhat-linux-gnu\".For bug reporting instructions, please see:&lt;http://www.gnu.org/software/gdb/bugs/&gt;...Reading symbols from /root/testmultithread/test8...done.(gdb) rStarting program: /root/testmultithread/test8 [Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".ret = 0[New Thread 0x7ffff6fd2700 (LWP 3276)]thread start, ThreadID: -151181568[New Thread 0x7ffff67d1700 (LWP 3277)]thread start, ThreadID: -159574272[New Thread 0x7ffff5fd0700 (LWP 3278)]thread start, ThreadID: -167966976[New Thread 0x7ffff57cf700 (LWP 3279)]thread start, ThreadID: -176359680[New Thread 0x7ffff4fce700 (LWP 3280)]thread start, ThreadID: -184752384^CProgram received signal SIGINT, Interrupt.0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64(gdb) bt#0  0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0#1  0x00000000004009e9 in main () at ConsoleApplication8.cpp:50(gdb) inf threads  Id   Target Id         Frame   6    Thread 0x7ffff4fce700 (LWP 3280) \"test8\" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0  5    Thread 0x7ffff57cf700 (LWP 3279) \"test8\" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0  4    Thread 0x7ffff5fd0700 (LWP 3278) \"test8\" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0  3    Thread 0x7ffff67d1700 (LWP 3277) \"test8\" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0  2    Thread 0x7ffff6fd2700 (LWP 3276) \"test8\" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0* 1    Thread 0x7ffff7fee740 (LWP 3272) \"test8\" 0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0(gdb)\n通过上面的实验，如果互斥体的属性是 PTHREAD_MUTEX_ERRORCHECK，当前线程重复调用 pthread_mutex_lock 会直接返回 EDEADLOCK，其他线程如果对这个互斥体再次调用 pthread_mutex_lock 会阻塞在该函数的调用处。\nPTHREAD_MUTEX_RECURSIVE（嵌套锁）该属性允许同一个线程对其持有的互斥体重复加锁，每次成功调用 pthread_mutex_lock 一次，该互斥体对象的锁引用计数就会增加一次，相反，每次成功调用 pthread_mutex_unlock 一次，锁引用计数就会减少一次，当锁引用计数值为 0 时允许其他线程获得该锁，否则其他线程调用 pthread_mutex_lock 时尝试获取锁时，会阻塞在那里。这种方式很好理解，这里就不贴示例代码了。\n总结我们来总结下 Linux 互斥体对象的使用要点：\n\n虽然在上文演示了同一个线程对一个互斥体对象反复进行加锁，但在实际开发中，我们需要用到这种场景的情形非常少；\n与 Windows 的临界区对象一样，一些有很多出口的逻辑中，为了避免因忘记调用 pthread_mutex_unlock 出现死锁或者在逻辑出口处有大量解锁的重复代码出现，建议使用 RAII 技术将互斥体对象封装起来，具体方式在上文中已经介绍过了，这里不再赘述。\n\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Linux 线程同步之信号量","url":"/2021/10/18/CPP-multithreaded-11/","content":"音乐小港\n    \n\n\nLinux 线程同步之信号量与 Windows 的 Semaphore 对象使用原理一样，Linux 的信号量本质上也是暗含着“资源有多份，可以同时被多个线程访问”的意味，故信号量的原理这里不再赘述。\nLinux 信号量常用的一组 API 函数是：\n#include &lt;semaphore.h&gt;int sem_init(sem_t* sem, int pshared, unsigned int value);int sem_destroy(sem_t* sem);int sem_post(sem_t* sem);int sem_wait(sem_t* sem);int sem_trywait(sem_t* sem);int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout);\n\n函数 sem_init 用于初始化一个信号量，第一个参数 sem 传入需要初始化的信号量对象的地址；第二个参数 pshared 表示该信号量是否可以被共享，取值为 0 表示该信号量可以在同一个进程多个线程之间共享，取值为非 0 表示可以在多个进程之间共享；第三个参数 value 用于设置信号量初始状态下资源的数量。函数 sem_init 函数调用成功返回 0，失败返回 -1，实际编码中只要我们的写法得当一般不用关心该函数的返回值。\n函数 sem_destroy 用于销毁一个信号量。\n函数 sem_post 将信号量的资源计数递增 1，并解锁该信号量对象，这样其他由于使用 sem_wait 被阻塞的线程会被唤醒。\n如果当前信号量资源计数为 0，函数 sem_wait 会阻塞调用线程；直到信号量对象的资源计数大于 0 时被唤醒，唤醒后将资源计数递减 1，然后立即返回；函数 sem_trywait 是函数 sem_wait 的非阻塞版本，如果当前信号量对象的资源计数等于 0，sem_trywait 会立即返回不会阻塞调用线程，返回值是 ﹣1，错误码 errno 被设置成 EAGAIN；函数 sem_timedwait 是带有等待时间的版本，等待时间在第二个参数 abs_timeout 中设置，这是个结构体的定义如下：struct timespec{    time_t tv_sec;      /* 秒 */    long   tv_nsec;     /* 纳秒 [0 .. 999999999] */};\nsem_timedwait 在参数 abs_timeout 设置的时间内等待信号量对象的资源计数大于0，否则超时返回，返回值为 ﹣1，错误码 errno 是 ETIMEDOUT。当使用 sem_timedwait 时，参数 abs_timeout 不能设置为 NULL，否则程序会在运行时调用 sem_timedwait 产生崩溃。\n\n\n注意：\nsem_wait、sem_trywait、sem_timedwait 函数将资源计数递减一时会同时锁定信号量对象，因此当资源计数为 1 时，如果有多个线程调用 sem_wait 等函数等待该信号量时，只会有一个线程被唤醒。当 sem_wait 函数返回时，会释放对该信号量的锁。\nsem_wait、sem_trywait、sem_timedwait 函数调用成功后返回值均为 0，调用失败返回 ﹣1，可以通过错误码 errno 获得失败原因。\nsem_wait、sem_trywait、sem_timedwait 可以被 Linux 信号中断，被信号中断后，函数立即返回，返回值是 ﹣1，错误码 errno 为 EINTR。\n\n虽然上述函数没有以 pthread_ 作为前缀，实际使用这个系列的函数时需要链接 pthread 库。\n我们看一个信号量的具体使用示例：\n#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;list&gt;#include &lt;semaphore.h&gt;#include &lt;iostream&gt;class Task{public:    Task(int taskID)    {        this-&gt;taskID = taskID;    }    void doTask()    {        std::cout &lt;&lt; \"handle a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; pthread_self() &lt;&lt; std::endl;     }private:    int taskID;};pthread_mutex_t  mymutex;std::list&lt;Task*&gt; tasks;sem_t            mysemaphore;void* consumer_thread(void* param){        Task* pTask = NULL;    while (true)    {        if (sem_wait(&amp;mysemaphore) != 0)            continue;        if (tasks.empty())            continue;        pthread_mutex_lock(&amp;mymutex);           pTask = tasks.front();        tasks.pop_front();        pthread_mutex_unlock(&amp;mymutex);        pTask-&gt;doTask();        delete pTask;    }    return NULL;}void* producer_thread(void* param){    int taskID = 0;    Task* pTask = NULL;    while (true)    {        pTask = new Task(taskID);        pthread_mutex_lock(&amp;mymutex);        tasks.push_back(pTask);        std::cout &lt;&lt; \"produce a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; pthread_self() &lt;&lt; std::endl;         pthread_mutex_unlock(&amp;mymutex);        //释放信号量，通知消费者线程        sem_post(&amp;mysemaphore);        taskID ++;        //休眠1秒        sleep(1);    }    return NULL;}int main(){    pthread_mutex_init(&amp;mymutex, NULL);    //初始信号量资源计数为0    sem_init(&amp;mysemaphore, 0, 0);    //创建5个消费者线程    pthread_t consumerThreadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);    }    //创建一个生产者线程    pthread_t producerThreadID;    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);    pthread_join(producerThreadID, NULL);    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(consumerThreadID[i], NULL);    }    sem_destroy(&amp;mysemaphore);    pthread_mutex_destroy(&amp;mymutex);    return 0;}\n以上代码中我们创建一个生产者线程和 5 个消费者线程，初始信号量计数为 0 代表开始没有可执行任务，因此 5 个消费线程均阻塞在 sem_wait 调用处，接着生产者每隔 1 秒产生一个任务，然后通过调用 sem_post 将信号量资源计数增加一，此时其中一个线程会被唤醒，然后从任务队列中取出任务，执行任务，由于任务对象是 new 出来的，需要 delete 掉以避免内存泄露。\n有读者可能会奇怪，在调用 sem_wait 和 sem_post 时会对信号量对象进行加锁和解锁，为什么这里还需要使用一个 mutex？这个 mutex 是用来保护队列 tasks 的，因为多个线程会同时读写之。这个例子类似于银行里多个客户等待柜台有空闲办理取钱业务，每次有空闲的柜台，就可以告诉客户，但是多人同时取钱时，银行的资金总账户增减一定是原子性的。\n编译并生成文件 semaphore ，然后运行之，输出结果如下：\n[root@localhost testsemaphore]# g++ -g -o semaphore semaphore.cpp -lpthread[root@localhost testsemaphore]# ./semaphore produce a task, taskID: 0, threadID: 140055260595968handle a task, taskID: 0, threadID: 140055277381376produce a task, taskID: 1, threadID: 140055260595968handle a task, taskID: 1, threadID: 140055277381376produce a task, taskID: 2, threadID: 140055260595968handle a task, taskID: 2, threadID: 140055268988672produce a task, taskID: 3, threadID: 140055260595968handle a task, taskID: 3, threadID: 140055294166784produce a task, taskID: 4, threadID: 140055260595968handle a task, taskID: 4, threadID: 140055302559488produce a task, taskID: 5, threadID: 140055260595968handle a task, taskID: 5, threadID: 140055285774080produce a task, taskID: 6, threadID: 140055260595968handle a task, taskID: 6, threadID: 140055277381376produce a task, taskID: 7, threadID: 140055260595968handle a task, taskID: 7, threadID: 140055268988672produce a task, taskID: 8, threadID: 140055260595968handle a task, taskID: 8, threadID: 140055294166784produce a task, taskID: 9, threadID: 140055260595968handle a task, taskID: 9, threadID: 140055302559488...更多输出结果省略...\n点击这里下载课程源代码。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Linux 线程同步之条件变量","url":"/2021/10/18/CPP-multithreaded-12/","content":"音乐小港\n    \n\n\nLinux 线程同步之条件变量有人说 Linux 条件变量（Condition Variable）是最不会用错的一种线程同步对象，确实是这样，但这必须建立在你对条件变量熟练使用的基础之上。我们先来讨论一下为什么会存在条件变量这样一种机制。\n为什么需要使用条件变量实际应用中，我们常常会有类似如下需求：\n//以下是伪码，m 的类型是 pthread_mutex_t，并且已经初始化过了int WaitForTrue(){    pthread_mutex_lock(&amp;m);    while (condition is false)      //条件不满足    {        pthread_mutex_unlock(&amp;m);   //解锁等待其他线程改变 condition        sleep(n);                   //睡眠n秒        //n秒后再次加锁验证条件是否满足        pthread_mutex_lock(&amp;m);    }    return 1;}\n以上逻辑可以表示成如下流程图：\n\n这段逻辑的用途是我们需要反复判断一个多线程共享条件是否满足，一直到该条件满足为止，由于该条件被多个线程操作因此每次判断之前都需要进行加锁操作，判断完毕后需要进行解锁操作。但是上述逻辑存在严重的效率问题，假设解锁离开临界区后，此时由于其他线程修改了条件导致条件满足了，此时程序仍然需要睡眠 n 秒后才能得到反馈。因此我们需要这样一种机制：\n\n某个线程 A 在条件不满足的情况下，主动让出互斥量，让其他线程去折腾，线程在此处等待，等待条件的满足；一旦条件满足，线程就可以被立刻唤醒。线程 A 之所以可以安心等待，依赖的是其他线程的协作，它确信会有一个线程在发现条件满足以后，将向它发送信号，并且让出互斥量。如果其他线程不配合（不发信号，不让出互斥量），这个主动让出互斥量并等待事件发生的线程 A 就真的要等到花儿都谢了。\n\n这个例子解释了为什么需要条件等待，但是条件等待还不是条件变量的全部功能。\n条件变量为什么要与互斥体对象结合很多第一次学习 Linux 条件变量的读者会觉得困惑：为什么条件变量一定要与一个互斥体对象结合使用？我们来看下，假设条件变量不与互斥体对象结合的效果。\n1 //m的类型是 pthread_mutex_t，并且已经初始化过了，cv 是条件变量2 pthread_mutex_lock(&amp;m)3 while(condition_is_false)4 {5     pthread_mutex_unlock(&amp;m);6     //解锁之后，等待之前，可能条件已经满足，信号已经发出，但是该信号可能会被错过7     cond_wait(&amp;cv);8     pthread_mutex_lock(&amp;m);9 }\n上述代码中，假设线程 A 执行完第 5 行代码 pthread_mutex_unlock(&amp;m); 后 CPU 时间片被剥夺，此时另外一个线程 B 获得该互斥体对象 m，然后发送条件信号，等线程 A 重新获得时间片后，由于该信号已经被错过了，这样可能会导致线程 A 在 第 7 行 cond_wait(&amp;cv); 无限阻塞下去。\n造成这个问题的根源是释放互斥体对象与条件变量等待唤醒不是原子操作，即解锁和等待这两个步骤必须是同一个原子性的操作，以确保 cond_wait 唤醒之前不会有其他线程获得这个互斥体对象。\n条件变量的使用介绍了这么多，我们来正式介绍一下条件变量相关的系统 API 的使用方法。\n条件变量的初始化和销毁可以使用如下 API 函数：\nint pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr);int pthread_cond_destroy(pthread_cond_t* cond);\n在 Linux 系统中 pthread_cond_t 即是条件变量的类型，当然和前面介绍的互斥体一样，也可以使用如下方式去初始化一个条件变量：\npthread_cond_t cond = PTHREAD_COND_INITIALIZER;\n等待条件变量的满足可以使用如下 API 函数：\nint pthread_cond_wait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex);int pthread_cond_timedwait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex, const struct timespec* restrict abstime);\n一般情况下如果条件变量代表的条件不会满足，调用 pthread_cond_wait 的线程会一直等待下去；pthread_cond_timedwait 是 pthread_cond_wait 非阻塞版本，它会在指定时间内等待条件满足，超过参数 abstime 设置的时候后 pthread_cond_timedwait 函数会立即返回。\n\n注意：对于参数 abstime，正如其名字暗示的，这是一个 absolute time（绝对时间），也就是说，如果你打算让函数等待 5 秒，那么你应该先得到当前系统的时间，然后加上 5 秒计算出最终的时间作为参数 abstime 的值。\n\n因调用 pthread_cond_wait 等待的线程可以被以下 API 函数唤醒：\nint pthread_cond_signal(pthread_cond_t* cond);int pthread_cond_broadcast(pthread_cond_t* cond);     \npthread_cond_signal 一次唤醒一个线程，如果有多个线程调用 pthread_cond_wait 等待，具体哪个线程被唤醒是不确定的（可以认为是随机的）；pthread_cond_broadcast 可以同时唤醒多个调用 pthread_cond_wait 等待的线程。前者相当于发送一次条件通知，后者广播一次条件通知。成功等待到条件信号，pthread_cond_signal 和 pthread_cond_broadcast 返回 0，反之返回非 0 值，具体错误原因可以通过错误码 errno 获得。\n我们将前文中介绍信号量的示例代码用条件变量来改写下：\n#include &lt;pthread.h&gt;#include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;list&gt;#include &lt;semaphore.h&gt;#include &lt;iostream&gt;class Task{public:    Task(int taskID)    {        this-&gt;taskID = taskID;    }    void doTask()    {        std::cout &lt;&lt; \"handle a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; pthread_self() &lt;&lt; std::endl;     }private:    int taskID;};pthread_mutex_t  mymutex;std::list&lt;Task*&gt; tasks;pthread_cond_t   mycv;void* consumer_thread(void* param){        Task* pTask = NULL;    while (true)    {        pthread_mutex_lock(&amp;mymutex);        while (tasks.empty())        {                           //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait 会释放锁，不往下执行            //当发生变化后，条件合适，pthread_cond_wait 将直接获得锁            pthread_cond_wait(&amp;mycv, &amp;mymutex);        }        pTask = tasks.front();        tasks.pop_front();        pthread_mutex_unlock(&amp;mymutex);        if (pTask == NULL)            continue;        pTask-&gt;doTask();        delete pTask;        pTask = NULL;           }    return NULL;}void* producer_thread(void* param){    int taskID = 0;    Task* pTask = NULL;    while (true)    {        pTask = new Task(taskID);        pthread_mutex_lock(&amp;mymutex);        tasks.push_back(pTask);        std::cout &lt;&lt; \"produce a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; pthread_self() &lt;&lt; std::endl;         pthread_mutex_unlock(&amp;mymutex);        //释放信号量，通知消费者线程        pthread_cond_signal(&amp;mycv);        taskID ++;        //休眠1秒        sleep(1);    }    return NULL;}int main(){    pthread_mutex_init(&amp;mymutex, NULL);    pthread_cond_init(&amp;mycv, NULL);    //创建 5 个消费者线程    pthread_t consumerThreadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);    }    //创建一个生产者线程    pthread_t producerThreadID;    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);    pthread_join(producerThreadID, NULL);    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(consumerThreadID[i], NULL);    }    pthread_cond_destroy(&amp;mycv);    pthread_mutex_destroy(&amp;mymutex);    return 0;}\n编译并执行上述程序，输出结果如下：\n[root@localhost testsemaphore]# g++ -g -o cv cv.cpp -lpthread[root@localhost testsemaphore]# ./cvproduce a task, taskID: 0, threadID: 140571200554752handle a task, taskID: 0, threadID: 140571242518272produce a task, taskID: 1, threadID: 140571200554752handle a task, taskID: 1, threadID: 140571225732864produce a task, taskID: 2, threadID: 140571200554752handle a task, taskID: 2, threadID: 140571208947456produce a task, taskID: 3, threadID: 140571200554752handle a task, taskID: 3, threadID: 140571242518272produce a task, taskID: 4, threadID: 140571200554752handle a task, taskID: 4, threadID: 140571234125568produce a task, taskID: 5, threadID: 140571200554752handle a task, taskID: 5, threadID: 140571217340160produce a task, taskID: 6, threadID: 140571200554752handle a task, taskID: 6, threadID: 140571225732864produce a task, taskID: 7, threadID: 140571200554752handle a task, taskID: 7, threadID: 140571208947456produce a task, taskID: 8, threadID: 140571200554752handle a task, taskID: 8, threadID: 140571242518272...更多输出结果省略...\n条件变量最关键的一个地方就是需要清楚地记得 pthread_cond_wait 在条件满足与不满足时的两种行为，这是难点也是重点：\n\n当 pthread_cond_wait 函数阻塞时，它会释放其绑定的互斥体，并阻塞线程，因此在调用该函数前应该对互斥体有个加锁操作（上述代码的第 34 行的 pthread_mutex_lock(&amp;mymutex);）。\n当收到条件信号时， pthread_cond_wait 会返回并对其绑定的互斥体进行加锁，因此在其下面一定有个对互斥体进行解锁的操作（上述代码的第 45 行 pthread_mutex_unlock(&amp;mymutex);）。条件变量的虚假唤醒上面将互斥量和条件变量配合使用的示例代码中有个很有意思的地方，就是用了 while 语句，醒来 之后要再次判断条件是否满足。while (tasks.empty()){                    pthread_cond_wait(&amp;mycv, &amp;mymutex);}\n为什么不写成：if (tasks.empty()){                    pthread_cond_wait(&amp;mycv, &amp;mymutex);}\n答案是不得不如此。因为可能某次操作系统唤醒 pthread_cond_wait 时 tasks.empty() 可能仍然为 true，言下之意就是操作系统可能会在一些情况下唤醒条件变量，即使没有其他线程向条件变量发送信号，等待此条件变量的线程也有可能会醒来。我们将条件变量的这种行为称之为 虚假唤醒 （spurious wakeup）。因此将条件（判断 tasks.empty() 为 true）放在一个 while 循环中意味着光唤醒条件变量不行，还必须条件满足程序才能继续执行正常的逻辑。\n\n这看起来这像是个 bug，但它在 Linux 系统中是实实在在存在的。为什么会存在虚假唤醒呢？一个原因是：pthread_cond_wait 是 futex 系统调用，属于阻塞型的系统调用，当系统调用被信号中断的时候，会返回 ﹣1，并且把 errno 错误码置为 EINTR。很多这种系统调用为了防止被信号中断都会重启系统调用（即再次调用一次这个函数），代码如下：\npid_t r_wait(int *stat_loc){    int retval;    //wait 函数因为被信号中断导致调用失败会返回 ﹣1，错误码是 EINTR      //注意：这里的 while 循环体是一条空语句    while(((retval = wait(stat_loc)) == -1 &amp;&amp; (errno == EINTR));    return retval;}\n但是 pthread_cond_wait 用途有点不一样，假设 pthread_cond_wait 函数被信号中断了，在 pthread_cond_wait 返回之后，到重新调用之前，pthread_cond_signal 或 pthread_cond_broadcast 可能已经调用过。一旦错失，可能由于条件信号不再产生，再次调用 pthread_cond_wait 将导致程序无限制地等待下去。为了避免这种情况，宁可虚假唤醒，也不能再次调用 pthread_cond_wait，以免陷入无穷的等待中。\n除了上面的信号因素外，还存在以下情况：条件满足了发送信号，但等到调用 pthread_cond_wait 的线程得到 CPU 资源时，条件又再次不满足了。\n好在无论是哪种情况，醒来之后再次测试条件是否满足就可以解决虚假等待的问题。这就是使用 while 循环来判断条件，而不是使用 if 语句的原因。\n条件变量信号丢失问题上文中，我们介绍了，如果一个条件变量信号条件产生时（调用 pthread_cond_signal 或 pthread_cond_broadcast），没有相关的线程调用 pthread_cond_wait 捕获该信号，那么该信号条件就会永久性地丢失了，再次调用 pthread_cond_wait 会导致永久性的阻塞。这种情况在设计那些条件变量信号条件只会产生一次的逻辑中尤其需要注意，例如假设现在某个程序有一批等待条件变量的线程，和一个只产生一次条件变量信号的线程。为了让你的等待条件变量的线程能正常运行不阻塞，你的逻辑中，一定要确保等待的线程在产生条件变量信号的线程发送条件信号之前调用 pthread_cond_wait 。\n\n这和生活中的很多例子一样，即许多事情你只有一次机会，必须提前准备好再去尝试这次机会，这个机会不会等待你的准备，一旦错过，就不会再有第二次机会了。\n\n总结本节介绍了学习 Linux 条件变量需要掌握的重难点知识，条件变量是最常用的一种多线程编程同步技术之一，也是面试高频问题之一，建议打算从事相关工作的读者务必理解和熟练使用它。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Linux 线程同步之读写锁","url":"/2021/10/18/CPP-multithreaded-13/","content":"音乐小港\n    \n\n\nLinux 线程同步之读写锁在实际应用中，很多时候对共享变量的访问有以下特点：\n\n大多数情况下线程只是读取共享变量的值，并不修改，只有在极少数情况下，线程才会真正地修改共享变量的值。\n\n对于这种情况，读请求之间是无需同步的，它们之间的并发访问是安全的。然而写请求必须锁住读请求和其他写请求。\n这种情况在实际中是存在的，如读取一个全局对象的状态属性，大多数情况下这个状态属性值是不会变化的，偶尔才会出现被修改的情况。如果使用互斥量，完全阻止读请求并发，则会造成性能的损失。\n读写锁使用方法读写锁在 Linux 系统中使用类型 pthread_rwlock_t 表示，读写锁的初始化和销毁使用如下系统 API 函数：\n#include &lt;pthread.h&gt;int pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr);int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);\n参数 rwlock 即需要初始化和销毁的读写锁对象的地址，参数 attr 用于设置读写锁的属性，一般设置未 NULL 表示使用默认属性。函数调用成功返回 0，调用失败返回非 0 值，你可以通过检测错误码 errno 获取错误原因。\n当然，如果你不需要动态创建或者设置非默认属性的读写锁对象，也可以使用如下语法初始化一个读写锁对象：\npthread_rwlock_t myrwlock = PTHREAD_RWLOCK_INITIALIZER;\n下面是三个请求读锁的系统 API 接口：\nint pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);int pthread_rwlock_timedrdlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);\n而下面三个请求写锁的系统 API 接口：\nint pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock);int pthread_rwlock_timedwrlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);\n读锁用于共享模式：\n\n如果当前读写锁已经被某线程以读模式占有了，其他线程调用 pthread_rwlock_rdlock （请求读锁）会立刻获得读锁；\n如果当前读写锁已经被某线程以读模式占有了，其他线程调用 pthread_rwlock_wrlock （请求写锁）会陷入阻塞。\n\n写锁用的是独占模式：\n\n如果当前读写锁被某线程以写模式占有，无论调用 pthread_rwlock_rdlock 还是 pthread_rwlock_wrlock 都会陷入阻塞，即写模式下不允许任何读锁请求通过，也不允许任何写锁请求通过，读锁请求和写锁请求都要陷入阻塞，直到线程释放写锁。可以将上述读写锁逻辑总结成如下表格：\n\n|锁当前状态/其他线程请求锁类型|    请求读锁|    请求写锁||—|—||无锁|    通过|    通过||已经获得读锁|    通过|    阻止||已经获得写锁|    阻止|    阻止|无论是读锁还是写锁，锁的释放都是一个接口：\nint pthread_rwlock_unlock (pthread_rwlock_t* rwlock);\n无论是请求读锁还是写锁，都提供了 trylock 的功能（pthread_rwlock_tryrdlock 和 pthread_rwlock_trywrlock），调用线程不会阻塞，而会立即返回。如果能成功获得读锁或者写锁，函数返回 0，如果不能获得读锁或写锁时，函数返回非 0 值，此时错误码 errno 是 EBUSY。\n当然，无论是请求读锁还是写锁都提供了限时等待功能，如果不能获取读写锁，则会陷入阻塞，最多等待到参数 abstime 设置的时间；如果仍然无法获得锁，则返回，错误码 errno 是 ETIMEOUT。\n读写锁的属性上文介绍 pthread_rwlock_init 函数时，提到其第二个参数可以设置读写锁的属性，读写锁的属性类型是 pthread_rwlockattr_t ，glibc 引入了如下接口来查询和改变读写锁的类型：\n#include &lt;pthread.h&gt;int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t* attr, int pref);int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t* attr, int* pref);\npthread_rwlockattr_setkind_np 的第二个参数 pref 即设置读写锁的类型，其取值有如下几种：\nenum{    //读者优先（即同时请求读锁和写锁时，请求读锁的线程优先获得锁）    PTHREAD_RWLOCK_PREFER_READER_NP,     //不要被名字所迷惑，也是读者优先    PTHREAD_RWLOCK_PREFER_WRITER_NP,     //写者优先（即同时请求读锁和写锁时，请求写锁的线程优先获得锁）    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,                     PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP};\n当然，为了得到一个有效的 pthread_rwlockattr_t 对象，你需要调用 pthread_rwlockattr_init 函数初始化这样一个属性对象，在你不需要的时候记得使用 pthread_rwlockattr_destroy 销毁之：\nint pthread_rwlockattr_init(pthread_rwlockattr_t* attr);int pthread_rwlockattr_destroy(pthread_rwlockattr_t* attr);\n以下代码片段演示了如何初始化一个写者优先的读写锁：\npthread_rwlockattr_t attr;pthread_rwlockattr_init(&amp;attr);pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);pthread_rwlock_t rwlock;pthread_rwlock_init(&amp;rwlock, &amp;attr);\n读写锁使用示例\n#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int resourceID = 0;pthread_rwlock_t myrwlock;void* read_thread(void* param){        while (true)    {        //请求读锁        pthread_rwlock_rdlock(&amp;myrwlock);        std::cout &lt;&lt; \"read thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);        pthread_rwlock_unlock(&amp;myrwlock);    }    return NULL;}void* write_thread(void* param){    while (true)    {        //请求写锁        pthread_rwlock_wrlock(&amp;myrwlock);        ++resourceID;        std::cout &lt;&lt; \"write thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);        pthread_rwlock_unlock(&amp;myrwlock);    }    return NULL;}int main(){    pthread_rwlock_init(&amp;myrwlock, NULL);    //创建5个请求读锁线程    pthread_t readThreadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);    }    //创建一个请求写锁线程    pthread_t writeThreadID;    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);    pthread_join(writeThreadID, NULL);    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(readThreadID[i], NULL);    }    pthread_rwlock_destroy(&amp;myrwlock);    return 0;}\n上述程序中创建五个请求读锁的“读”线程和一个请求写锁的“写”线程，共享的资源是一个整形变量 resourceID，我们编译并执行得到输出结果：\n[root@localhost testmultithread]# g++ -g -o rwlock rwlock.cpp -lpthread[root@localhost testmultithread]# ./rwlockread thread ID: 140575861593856, resourceID: 0read thread ID: 140575878379264, resourceID: 0read thread ID: 140575853201152, resourceID: 0read thread ID: 140575869986560, resourceID: 0read thread ID: 140575886771968, resourceID: 0read thread ID: read thread ID: read thread ID: read thread ID: 140575861593856140575886771968, resourceID: 0, resourceID: 0140575878379264read thread ID: 140575869986560, resourceID: 0, resourceID: 0140575853201152, resourceID: 0read thread ID: read thread ID: read thread ID: 140575861593856140575853201152140575886771968, resourceID: , resourceID: 0, resourceID: 00read thread ID: 140575869986560, resourceID: 0...更多输出结果省略...\n上述输出结果，我们验证了两个结论：\n\n由于读写锁对象 myrwlock 使用了默认属性，其行为是请求读锁的线程优先获得到锁，请求写锁的线程 write_thread 很难获得锁的机会，因此结果中基本没有请求写锁线程的输出结果；\n由于多个请求读锁的线程 read_thread 可以自由获得读锁，且代码 15 行（std::cout &lt;&lt; \"read thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;）的输出不是原子性的，因而多个“读”线程的输出可能会交替，出现“错乱”现象。我们将读写锁对象 myrwlock 的属性修改成请求写锁优先，再来试一试：#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int resourceID = 0;pthread_rwlock_t myrwlock;void* read_thread(void* param){        while (true)    {        //请求读锁        pthread_rwlock_rdlock(&amp;myrwlock);        std::cout &lt;&lt; \"read thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);        pthread_rwlock_unlock(&amp;myrwlock);    }    return NULL;}void* write_thread(void* param){    while (true)    {        //请求写锁        pthread_rwlock_wrlock(&amp;myrwlock);        ++resourceID;        std::cout &lt;&lt; \"write thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);        pthread_rwlock_unlock(&amp;myrwlock);    }    return NULL;}int main(){    pthread_rwlockattr_t attr;    pthread_rwlockattr_init(&amp;attr);    //设置成请求写锁优先    pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);    pthread_rwlock_init(&amp;myrwlock, &amp;attr);    //创建5个请求读锁线程    pthread_t readThreadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);    }    //创建一个请求写锁线程    pthread_t writeThreadID;    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);    pthread_join(writeThreadID, NULL);    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(readThreadID[i], NULL);    }    pthread_rwlock_destroy(&amp;myrwlock);    return 0;}\n编译程序并运行，输出结果如下：[root@localhost testmultithread]# g++ -g -o rwlock2 rwlock2.cpp -lpthread[root@localhost testmultithread]# ./rwlock2read thread ID: 140122217539328, resourceID: 0read thread ID: 140122242717440, resourceID: 0read thread ID: 140122209146624, resourceID: 0write thread ID: 140122200753920, resourceID: 1read thread ID: 140122234324736, resourceID: 1write thread ID: 140122200753920, resourceID: 2write thread ID: 140122200753920, resourceID: 3write thread ID: 140122200753920, resourceID: 4write thread ID: 140122200753920, resourceID: 5write thread ID: 140122200753920, resourceID: 6write thread ID: 140122200753920, resourceID: 7write thread ID: 140122200753920, resourceID: 8write thread ID: 140122200753920, resourceID: 9write thread ID: 140122200753920, resourceID: 10write thread ID: 140122200753920, resourceID: 11write thread ID: 140122200753920, resourceID: 12write thread ID: 140122200753920, resourceID: 13read thread ID: 140122217539328, resourceID: 13write thread ID: 140122200753920, resourceID: 14write thread ID: 140122200753920, resourceID: 15write thread ID: 140122200753920, resourceID: 16write thread ID: 140122200753920, resourceID: 17write thread ID: 140122200753920, resourceID: 18write thread ID: 140122200753920, resourceID: 19write thread ID: 140122200753920, resourceID: 20write thread ID: 140122200753920, resourceID: 21write thread ID: 140122200753920, resourceID: 22write thread ID: 140122200753920, resourceID: 23...更多输出结果省略...\n由于将 myrwlock 设置成请求写锁优先，上述结果中几乎都是 write_thread 的输出结果。\n\n我们将 write_thread 中的 37 行 sleep 语句挪到 39 行后面，增加请求写锁线程的睡眠时间，再看看执行结果。\n#include &lt;pthread.h&gt;#include &lt;unistd.h&gt;#include &lt;iostream&gt;int resourceID = 0;pthread_rwlock_t myrwlock;void* read_thread(void* param){        while (true)    {        //请求读锁        pthread_rwlock_rdlock(&amp;myrwlock);        std::cout &lt;&lt; \"read thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        //使用睡眠模拟读线程读的过程消耗了很久的时间        sleep(1);        pthread_rwlock_unlock(&amp;myrwlock);    }    return NULL;}void* write_thread(void* param){    while (true)    {        //请求写锁        pthread_rwlock_wrlock(&amp;myrwlock);        ++resourceID;        std::cout &lt;&lt; \"write thread ID: \" &lt;&lt; pthread_self() &lt;&lt; \", resourceID: \" &lt;&lt; resourceID &lt;&lt; std::endl;        pthread_rwlock_unlock(&amp;myrwlock);        //放在这里增加请求读锁线程获得锁的几率        sleep(1);    }    return NULL;}int main(){    pthread_rwlockattr_t attr;    pthread_rwlockattr_init(&amp;attr);    //设置成请求写锁优先    pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);    pthread_rwlock_init(&amp;myrwlock, &amp;attr);    //创建5个请求读锁线程    pthread_t readThreadID[5];    for (int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);    }    //创建一个请求写锁线程    pthread_t writeThreadID;    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);    pthread_join(writeThreadID, NULL);    for (int i = 0; i &lt; 5; ++i)    {        pthread_join(readThreadID[i], NULL);    }    pthread_rwlock_destroy(&amp;myrwlock);    return 0;}\n再次编译程序并执行，得到输出结果：\n[root@localhost testmultithread]# g++ -g -o rwlock3 rwlock3.cpp -lpthread[root@localhost testmultithread]# ./rwlock3read thread ID: 140315524790016, resourceID: 0read thread ID: 140315549968128, resourceID: 0read thread ID: 140315541575424, resourceID: 0write thread ID: 140315508004608, resourceID: 1read thread ID: 140315549968128, resourceID: 1read thread ID: 140315541575424, resourceID: 1read thread ID: 140315524790016, resourceID: 1read thread ID: 140315516397312, resourceID: 1read thread ID: 140315533182720, resourceID: 1write thread ID: 140315508004608, resourceID: 2read thread ID: 140315541575424, resourceID: 2read thread ID: 140315524790016, resourceID: 2read thread ID: 140315533182720, resourceID: 2read thread ID: 140315516397312, resourceID: 2read thread ID: 140315549968128, resourceID: 2read thread ID: 140315516397312, resourceID: 2write thread ID: 140315508004608, resourceID: 3read thread ID: 140315549968128, resourceID: 3read thread ID: 140315541575424, resourceID: 3read thread ID: 140315533182720, resourceID: 3read thread ID: read thread ID: 140315524790016, resourceID: 3140315516397312, resourceID: 3read thread ID: read thread ID: read thread ID: 140315524790016140315549968128, resourceID: , resourceID: 33140315516397312, resourceID: 3read thread ID: 140315541575424, resourceID: read thread ID: 140315533182720, resourceID: 33write thread ID: 140315508004608, resourceID: 4read thread ID: 140315516397312, resourceID: 4read thread ID: 140315541575424, resourceID: 4read thread ID: 140315524790016, resourceID: 4read thread ID: 140315549968128, resourceID: 4read thread ID: 140315533182720, resourceID: 4read thread ID: 140315524790016, resourceID: 4read thread ID: 140315541575424, resourceID: 4write thread ID: 140315508004608, resourceID: 5read thread ID: 140315516397312, resourceID: 5read thread ID: 140315541575424, resourceID: 5read thread ID: 140315524790016, resourceID: 5read thread ID: 140315533182720, resourceID: 5read thread ID: 140315549968128, resourceID: 5\n这次请求读锁的线程和请求写锁的线程的输出结果分布就比较均匀了。\n以上例子比较简单，建议读者实际运行一下代码实验一下。\n总结mutex 多线程之间，无论线程对共享资源是读还是写一概加上锁，加锁期间，不允许其他线程进行任何操作，而读写锁允许多个线程的读操作，因此相对于 mutex 提高了效率， 这也是 boost::mutex 和 boost::shared_mutex 在 Linux 平台的实现原理，前者使用 mutex 实现，后者使用读写锁实现。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"锁使用实践经验总结","url":"/2021/10/18/CPP-multithreaded-15/","content":"音乐小港\n    \n\n\n锁使用实践经验总结关于锁的使用，根据我的经验总结如下几点。\n减少锁的使用实际开发中能不使用锁尽量不使用锁，当然这不是绝对的，如果使用锁也能满足性能要求，使用也无妨，一般使用了锁的代码会带来如下性能损失：\n\n加锁和解锁操作，本身有一定的开销；\n临界区的代码不能并发执行；\n进入临界区的次数过于频繁，线程之间对临界区的争夺太过激烈，若线程竞争互斥量失败，就会陷入阻塞，让出 CPU，因此执行上下文切换的次数要远远多于不使用互斥量的版本。替代锁的方式有很多，如无锁队列。\n\n明确锁的范围看下面这段代码：\nif(hashtable.is_empty()){    pthread_mutex_lock(&amp;mutex);    htable_insert(hashtable, &amp;elem);    pthread_mutex_unlock(&amp;mutex);}\n读者能看出这段代码的问题吗？代码行 4 虽然对 hashtable 的插入使用了锁做保护，但是判断 hash_table 是否为空也需要使用锁保护，因此正确的写法应该是：\npthread_mutex_lock(&amp;mutex);if(hashtable.is_empty()){       htable_insert(hashtable, &amp;elem);  }pthread_mutex_unlock(&amp;mutex);\n减少锁的粒度所谓减小锁使用粒度指的是尽量减小锁作用的临界区代码范围，临界区的代码范围越小，多个线程排队进入临界区的时间就会越短。这就类似高速公路上堵车，如果堵车的路段越长，那么后续过来的车辆通行等待时间就会越长。\n我们来看两个具体的例子：\n示例一\nvoid TaskPool::addTask(Task* task){    std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);     std::shared_ptr&lt;Task&gt; spTask;    spTask.reset(task);                m_taskList.push_back(spTask);    m_cv.notify_one();}\n上述代码中 guard 锁保护 m_taskList，仔细分析下这段代码发现，代码行 4、5 和 8 行其实没必要作为临界区内的代码的，因此建议挪到临界区外面去，修改如下：\nvoid TaskPool::addTask(Task* task){    std::shared_ptr&lt;Task&gt; spTask;    spTask.reset(task);    {        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);                     m_taskList.push_back(spTask);    }    m_cv.notify_one();}\n修改之后，guard 锁的作用范围就是 7 、8 两行了，仅对 m_taskList.push_back() 操作做保护，这样锁的粒度就变小了。\n示例二\nvoid EventLoop::doPendingFunctors(){    std::unique_lock&lt;std::mutex&gt; lock(mutex_);    for (size_t i = 0; i &lt; pendingFunctors_.size(); ++i)    {        pendingFunctors_[i]();    }}\n上述代码中 pendingFunctors_ 是被锁保护的对象，它的类型是 std::vector&lt;Functor&gt;，这样的代码效率比较低，必须等当前线程挨个处理完 pendingFunctors_ 中的元素后其他线程才能操作 pendingFunctors_ 。修改代码如下：\nvoid EventLoop::doPendingFunctors(){    std::vector&lt;Functor&gt; functors;    {        std::unique_lock&lt;std::mutex&gt; lock(mutex_);        functors.swap(pendingFunctors_);    }    for (size_t i = 0; i &lt; functors.size(); ++i)    {        functors[i]();    }   }\n修改之后的代码使用了一个局部变量 functors，然后把 pendingFunctors_ 中的内容倒换到 functors 中，这样就可以释放锁了，允许其他线程操作 pendingFunctors_ ，现在只要继续操作本地对象 functors 就可以了，提高了效率。\n避免死锁的一些建议\n一个函数中，如果有一个加锁操作，那么一定要记得在函数退出时记得解锁，且每个退出路径上都不要忘记解锁路径。例如：\nvoid some_func(){    //加锁代码    if (条件1)    {        //其他代码        //解锁代码        return;    }     else    {        //其他代码        //解锁代码        return;    }    if (条件2)    {        if (条件3)        {            //其他代码            //解锁代码            return;        }        if (条件4)        {            //其他代码            //解锁代码            return;        }       }     while (条件5)    {        if (条件6)        {            //其他代码            //解锁代码            return;        }    }}\n上述函数中每个逻辑出口处都需要写上解锁代码。前面也说过，这种逻辑非常容易因为疏忽忘记在某个地方加上解锁代码而造成死锁，因此一般建议使用 RAII 技术将加锁和解锁代码封装起来。\n\n线程退出时一定要及时释放其持有的锁实际开发中会因一些特殊需求创建一些临时线程，这些线程执行完相应的任务后就会退出。对于这类线程，如果其持有了锁，一定记得在线程退出时记得释放其持有的锁对象。\n\n多线程请求锁的方向要一致，以避免死锁假设现在有两个锁 A 和 B，线程 1 在请求了锁 A 之后再请求 B，线程 2 在请求了锁 B 后再请求锁 A，这种线程请求锁的方向就不一致了，线程 1 的方向是从 A 到 B，线程 2 的方向是从 B 到 A，多个线程请求锁的方向不一致容易造成死锁。因此建议的方式是线程 1 和 线程 2 请求锁的方向保持一致，要么都从 A 到 B，要么都从 B 到 A。\n\n当需要同一个线程重复请求一个锁时，搞清楚你所使用的锁的行为，是递增锁引用计数，还是会阻塞抑或是直接获得锁？\n避免活锁的一些建议前面说了避免“死锁”，读者应该能理解，但是这里突然出现了避免“活锁”，我相信很多人看到这个标题一下子就懵了。所谓活锁就是，当多个线程使用 trylock 系列的函数时，由于多个线程相互谦让，导致即使在某段时间内锁资源是可用的，也可能导致需要锁的线程拿不到锁。举个生活中的例子，马路上两个人迎面走来，两个人同时往一个方向避让，原来本意是给对方让路，结果还是发生了碰撞。\n\n\n我们在实际编码时，尽量避免不要过多的线程使用 trylock 请求锁，以免出现“活锁”现象，这是对资源的一种浪费。\n总结从第 08 节到 第 17 节我们介绍 Windows 和 Linux 操作系统 API 层面上的各种常用多线程同步对象，本节是对它们的使用做了一个规范性和效率性总结。学会使用锁并不难，如何高效地使用它们则是一个不断积累不断总结的过程，希望本节的经验能对读者有帮助。同时，本节介绍锁的注意事项也适用于其他编程语言。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"C++ 11/14/17 线程资源同步对象","url":"/2021/10/18/CPP-multithreaded-14/","content":"音乐小港\n    \n\n\nC++ 11/14/17 线程资源同步对象在 C/C++ 语言中直接使用操作系统提供的多线程资源同步 API 虽然功能强大，但毕竟存在诸多限制，且同样的代码却不能同时兼容 Windows 和 Linux 两个平台；再者 C/C++ 这种传统语言的使用份额正在被 Java、Python、Go 等语言慢慢蚕食，很大一部分原因是 C/C++ 这门编程语言在一些功能上缺少“完备性”，如对线程同步技术的支持，而这些功能在像 Java、Python、Go 中是标配。\n因此，C++ 11 标准新加入了很多现代语言标配的东西，其中线程资源同步对象就是其中很重要的一部分。本小节将讨论 C++ 11 标准中新增的用于线程同步的 std::mutex 和 std::condition_variable 对象的用法，有了它们我们就可以写出跨平台的多线程程序了。\nstd::mutex 系列关于 mutex 的基本概念上文已经介绍过了，这里不再赘述。\nC++ 11/14/17 中提供了如下 mutex 系列类型：\n\n\n\n互斥量\n版本\n作用\n\n\n\nmutex\nC++11\n最基本的互斥量\n\n\ntimed_mutex\nC++11\n有超时机制的互斥量\n\n\nrecursive_mutex\nC++11\n可重入的互斥量\n\n\nrecursive_timed_mutex\nC++11\n结合 timed_mutex 和 recursive_mutex 特点的互斥量\n\n\nshared_timed_mutex\nC++14\n具有超时机制的可共享互斥量\n\n\nshared_mutex\nC++17\n共享的互斥量\n\n\n这个系列的对象均提供了加锁（lock）、尝试加锁（trylock）和解锁（unlock）的方法，我们以 std::mutex 为例来看一段示例代码：\n\n\n\n\n#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;thread&gt;#include &lt;mutex&gt;// protected by g_num_mutexint g_num = 0;  std::mutex g_num_mutex;void slow_increment(int id) {    for (int i = 0; i &lt; 3; ++i) {        g_num_mutex.lock();        ++g_num;        std::cout &lt;&lt; id &lt;&lt; \" =&gt; \" &lt;&lt; g_num &lt;&lt; std::endl;        g_num_mutex.unlock();        //sleep for 1 second        std::this_thread::sleep_for(std::chrono::seconds(1));    }}int main(){    std::thread t1(slow_increment, 0);    std::thread t2(slow_increment, 1);    t1.join();    t2.join();    return 0;}\n上述代码中，创建了两个线程 t1 和 t2，在线程函数的 for 循环中调用 std::mutex.lock() 和 std::mutex.unlock() 对全局变量 g_num 进行保护。编译程序并输出结果如下：\n[root@localhost testmultithread]# g++ -g -o mutex c11mutex.cpp -std=c++0x -lpthread[root@localhost testmultithread]# ./mutex 0 =&gt; 11 =&gt; 20 =&gt; 31 =&gt; 41 =&gt; 50 =&gt; 6\n\n注意：如果你在 Linux 下编译和运行程序，在编译时需要链接 pthread 库，否则能够正常编译但是运行时程序会崩溃，崩溃原因：\nterminate called after throwing an instance of ‘std::system_error’\nwhat(): Enable multithreading to use std::thread: Operation not permitted\n\n为了避免死锁，std::mutex.lock() 和 std::mutex::unlock() 方法需要成对使用，但是如上文介绍的如果一个函数中有很多出口，而互斥体对象又是需要在整个函数作用域保护的资源，那么在编码时因为忘记在某个出口处调用 std::mutex.unlock 而造成死锁，上文中推荐使用利用 RAII 技术封装这两个接口，其实 C++ 11 标准也想到了整个问题，因为已经为我们提供了如下封装：\n\n\n\n互斥量管理\n版本\n作用\n\n\n\nlock_guard\nC++11\n基于作用域的互斥量管理\n\n\nunique_lock\nC++11\n更加灵活的互斥量管理\n\n\nshared_lock\nC++14\n共享互斥量的管理\n\n\nscope_lock\nC++17\n多互斥量避免死锁的管理\n\n\n我们这里以 std::lock_guard 为例：\n\n\n\n\nvoid func(){    std::lock_guard&lt;std::mutex&gt; guard(mymutex);    //在这里放被保护的资源操作}\nmymutex 的类型是 std::mutex，在 guard 对象的构造函数中，会自动调用 mymutex.lock() 方法加锁，当该函数出了作用域后，调用 guard 对象时析构函数时会自动调用 mymutex.unlock() 方法解锁。\n注意： mymutex 生命周期必须长于函数 func 的作用域，很多人在初学这个利用 RAII 技术封装的 std::lock_guard 对象时，可能会写出这样的代码：\n//错误的写法，这样是没法在多线程调用该函数时保护指定的数据的void func(){    std::mutex m;    std::lock_guard&lt;std::mutex&gt; guard(m);    //在这里放被保护的资源操作}\nstd::mutex 重复加锁问题另外，如果一个 std::mutex 对象已经调用了 lock() 方法，再次调用时，其行为是未定义的，这是一个错误的做法。所谓“行为未定义”即在不同平台上可能会有不同的行为。\n#include &lt;mutex&gt;int main(){    std::mutex m;    m.lock();    m.lock();    m.unlock();    return 0;}\n实际测试时，上述代码重复调用 std::mutex.lock() 方法在 Windows 平台上会引起程序崩溃。如下图所示：\n\n上述代码在 Linux 系统上运行时会阻塞在第二次调用 std::mutex.lock() 处，验证结果如下：\n[root@localhost testmultithread]# g++ -g -o mutexlock mutexlock.cpp -std=c++0x -lpthread[root@localhost testmultithread]# gdb mutexlockReading symbols from /root/testmultithread/mutexlock...done.(gdb) rStarting program: /root/testmultithread/mutexlock [Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".^CProgram received signal SIGINT, Interrupt.0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64(gdb) bt#0  0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0#1  0x00007ffff7bc8dcb in _L_lock_883 () from /lib64/libpthread.so.0#2  0x00007ffff7bc8c98 in pthread_mutex_lock () from /lib64/libpthread.so.0#3  0x00000000004006f7 in __gthread_mutex_lock (__mutex=0x7fffffffe3e0)    at /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/gthr-default.h:748#4  0x00000000004007a2 in std::mutex::lock (this=0x7fffffffe3e0) at /usr/include/c++/4.8.2/mutex:134#5  0x0000000000400777 in main () at mutexlock.cpp:7(gdb) f 5#5  0x0000000000400777 in main () at mutexlock.cpp:77        m.lock();(gdb) l2    3    int main()4    {5        std::mutex m;6        m.lock();7        m.lock();8        m.unlock();9    10        return 0;11    }(gdb)\n我们使用 gdb 运行程序，然后使用 bt 命令看到程序确实阻塞在第二个 m.lock() 的地方（代码第 7 行）。\n不管怎样，对一个已经调用 lock() 方法再次调用 lock() 方法的做法是错误的，我们实际开发中要避免这么做。\n\n有不少开发者诟病 C++ 新标准的多线程库原因之一是 C++ 11 引入了 std::mutex，却到 C++ 17 才引入 std::shared_mutex，这给使用带来了非常不方便的地方。\n\nstd::condition_variableC++ 11 提供了 std::condition_variable 这个类代表条件变量，与 Linux 系统原生的条件变量一样，同时提供了等待条件变量满足的 wait 系列方法（wait、wait_for、wait_until 方法），发送条件信号使用 notify 方法（notify_one 和 notify_all 方法），当然使用 std::condition_variable 对象时需要绑定一个 std::unique_lock 或 std::lock_guard 对象。\n\nC++ 11 中 std::condition_variable 不再需要显式调用方法初始化和销毁。\n\n我们将上文中介绍 Linux 条件变量的例子改写成 C++ 11 版本：\n#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;list&gt;#include &lt;iostream&gt;class Task{public:    Task(int taskID)    {        this-&gt;taskID = taskID;    }    void doTask()    {        std::cout &lt;&lt; \"handle a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;     }private:    int taskID;};std::mutex                mymutex;std::list&lt;Task*&gt;          tasks;std::condition_variable   mycv;void* consumer_thread(){        Task* pTask = NULL;    while (true)    {        std::unique_lock&lt;std::mutex&gt; guard(mymutex);        while (tasks.empty())        {                           //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁            mycv.wait(guard);        }        pTask = tasks.front();        tasks.pop_front();        if (pTask == NULL)            continue;        pTask-&gt;doTask();        delete pTask;        pTask = NULL;           }    return NULL;}void* producer_thread(){    int taskID = 0;    Task* pTask = NULL;    while (true)    {        pTask = new Task(taskID);        //使用括号减小guard锁的作用范围        {            std::lock_guard&lt;std::mutex&gt; guard(mymutex);            tasks.push_back(pTask);            std::cout &lt;&lt; \"produce a task, taskID: \" &lt;&lt; taskID &lt;&lt; \", threadID: \" &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;         }        //释放信号量，通知消费者线程        mycv.notify_one();        taskID ++;        //休眠1秒        std::this_thread::sleep_for(std::chrono::seconds(1));    }    return NULL;}int main(){    //创建5个消费者线程    std::thread consumer1(consumer_thread);    std::thread consumer2(consumer_thread);    std::thread consumer3(consumer_thread);    std::thread consumer4(consumer_thread);    std::thread consumer5(consumer_thread);    //创建一个生产者线程    std::thread producer(producer_thread);    producer.join();    consumer1.join();    consumer2.join();    consumer3.join();    consumer4.join();    consumer5.join();    return 0;}\n编译并执行程序输出结果如下所示：\n[root@localhost testmultithread]# g++ -g -o cpp11cv cpp11cv.cpp -std=c++0x -lpthread[root@localhost testmultithread]# ./cpp11cv produce a task, taskID: 0, threadID: 140427590100736handle a task, taskID: 0, threadID: 140427623671552produce a task, taskID: 1, threadID: 140427590100736handle a task, taskID: 1, threadID: 140427632064256produce a task, taskID: 2, threadID: 140427590100736handle a task, taskID: 2, threadID: 140427615278848produce a task, taskID: 3, threadID: 140427590100736handle a task, taskID: 3, threadID: 140427606886144produce a task, taskID: 4, threadID: 140427590100736handle a task, taskID: 4, threadID: 140427598493440produce a task, taskID: 5, threadID: 140427590100736handle a task, taskID: 5, threadID: 140427623671552produce a task, taskID: 6, threadID: 140427590100736handle a task, taskID: 6, threadID: 140427632064256produce a task, taskID: 7, threadID: 140427590100736handle a task, taskID: 7, threadID: 140427615278848produce a task, taskID: 8, threadID: 140427590100736handle a task, taskID: 8, threadID: 140427606886144produce a task, taskID: 9, threadID: 140427590100736handle a task, taskID: 9, threadID: 140427598493440...更多输出结果省略...\n\n需要注意的是，如果在 Linux 平台上，std::condition_variable 也存在虚假唤醒这一现象，如何避免与上文中介绍 Linux 原生的条件变量方法一样。\n\n总结除了 std::mutex、std::condition_variable 类，C++ 11/14/17 还同步引入的其他一些多线程资源同步辅助类，如 std::lock_guard、std::unique_lock 等，它们被加入 C++ 语言中极大地方便了 C++ 的跨平台开发。当然，读者一定要明白，这些引入的对象其实就是前面章节介绍的 mutex、条件变量等操作系统平台的多线程资源同步 API 的封装。\n\n从笔者自身的开发经历来说，自从有了 std::mutex、std::condition_variable 等对象，我在项目中大量使用他们，很少再使用操作系统本身提供的多线程资源同步 API 了，它们也在各种开源 C++ 项目中广泛使用。\n\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"线程池与队列系统的设计","url":"/2021/10/18/CPP-multithreaded-18/","content":"音乐小港\n    \n\n\n线程池与队列系统的设计在很多新手的认知中，线程池和队列系统 是一项非常高深的技术，其实也不然，当你熟练掌握了多线程编程技术后，这一切将会变的很容易，你需要克服的是内心的恐惧而已。\n线程池的设计原理所谓线程池不过是一组线程而已，一般情况下，我们需要异步执行一些任务，这些任务的产生和执行是存在于我们程序的整个生命周期的，与其让操作系统频繁地为我们创建和销毁线程，通常需要创建一组在程序生命周期内不会退出的线程，为了不浪费系统资源，我们的基本要求是当有任务需要执行时，这些线程可以自动拿到任务去执行，没有任务时这些线程处于阻塞或者睡眠状态。这里就涉及到这些处理任务的工作线程的唤醒与睡眠，如果理解了上文中介绍的各种线程同步技术，相信现在对如何唤醒和睡眠线程已经很熟悉了。\n既然在程序生命周期内会产生很多任务，那么这些任务必须有一个存放的地方，而这个地方就是队列，因此不要一提到队列就认为是一个具体的 list，它可以是一个全局变量、链表等。而线程池中的线程从队列中如何取任务，则也可以设计得非常灵活，如从尾部放入任务，从头部取出，或者从头部放入，从尾部取出等。而队列也可以根据实际应用设计得“丰富多彩”，如可以根据任务得优先级，设计多个队列（如分为高中低三个级别、分为关键和普通两个级别）。\n这本质上就是生产者消费者模式，产生任务的线程是生产者，线程池中的线程是消费者。当然，这不是绝对的，线程池中的线程处理一个任务以后可能会产生一个新的关联任务，那么此时这个工作线程又是生产者的角色。\n既然会有多个线程同时操作这个队列，根据多线程程序的原则，这个队列我们一般需要对其加锁，以避免多线程竞争产生非预期的结果。\n当然，技术上除了要解决线程池的创建、往队列中投递任务、从队列中取任务处理，我们还需要做一些善后工作，如线程池的清理，即如何退出线程池中的工作线程和清理任务队列。\n这就是线程池和任务队列的核心原理，希望读者能认真体会。\n说了这么多，结合前文介绍的，具体的实现也变得很容易，我们来看一个具体的例子：\n/**  * 任务池模型，TaskPool.h * zhangyl 2019.02.14 */#include &lt;thread&gt;#include &lt;mutex&gt;#include &lt;condition_variable&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;memory&gt;#include &lt;iostream&gt;class Task{public:    virtual void doIt()    {        std::cout &lt;&lt; \"handle a task...\" &lt;&lt; std::endl;    }    virtual ~Task()    {        //为了看到一个 task 的销毁，这里刻意补上其析构函数        std::cout &lt;&lt; \"a task destructed...\" &lt;&lt; std::endl;    }};class TaskPool final{public:    TaskPool();    ~TaskPool();    TaskPool(const TaskPool&amp; rhs) = delete;    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;public:    void init(int threadNum = 5);    void stop();    void addTask(Task* task);    void removeAllTasks();private:    void threadFunc();private:    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;    std::mutex                                  m_mutexList;    std::condition_variable                     m_cv;    bool                                        m_bRunning;    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;};\n/** * 任务池模型，TaskPool.cpp * zhangyl 2019.02.14 */#include \"TaskPool.h\"TaskPool::TaskPool() : m_bRunning(false){}TaskPool::~TaskPool(){    removeAllTasks();}void TaskPool::init(int threadNum/* = 5*/){    if (threadNum &lt;= 0)        threadNum = 5;    m_bRunning = true;    for (int i = 0; i &lt; threadNum; ++i)    {        std::shared_ptr&lt;std::thread&gt; spThread;        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this)));        m_threads.push_back(spThread);    }}void TaskPool::threadFunc(){    std::shared_ptr&lt;Task&gt; spTask;    while (true)    {        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList);        while (m_taskList.empty())        {                             if (!m_bRunning)                break;            //如果获得了互斥锁，但是条件不满足的话，m_cv.wait() 调用会释放锁，且挂起当前            //线程，因此不往下执行            //当发生变化后，条件满足，m_cv.wait() 将唤醒挂起的线程，且获得锁            m_cv.wait(guard);        }        if (!m_bRunning)            break;        spTask = m_taskList.front();        m_taskList.pop_front();        if (spTask == NULL)            continue;        spTask-&gt;doIt();        spTask.reset();    }    std::cout &lt;&lt; \"exit thread, threadID: \" &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;}void TaskPool::stop(){    m_bRunning = false;    m_cv.notify_all();    //等待所有线程退出    for (auto&amp; iter : m_threads)    {        if (iter-&gt;joinable())            iter-&gt;join();    }}void TaskPool::addTask(Task* task){    std::shared_ptr&lt;Task&gt; spTask;    spTask.reset(task);    {        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);                     m_taskList.push_back(spTask);        std::cout &lt;&lt; \"add a Task.\" &lt;&lt; std::endl;    }    m_cv.notify_one();}void TaskPool::removeAllTasks(){    {        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);        for (auto&amp; iter : m_taskList)        {            iter.reset();        }        m_taskList.clear();    }}\n上述代码封装了一个简单的任务队列模型，我们可以这么使用这个 TaskPool 对象：\n#include \"TaskPool.h\"#include &lt;chrono&gt;int main(){    TaskPool threadPool;    threadPool.init();    Task* task = NULL;    for (int i = 0; i &lt; 10; ++i)    {        task = new Task();        threadPool.addTask(task);    }    std::this_thread::sleep_for(std::chrono::seconds(5));    threadPool.stop();    return 0;}\n程序执行结果如下：\n\n由于退出线程的输出提示不是原子的，多个线程并行执行，因此上图中这部分的输出出现了“错乱”。\n上述代码演示了一个基本的多线程队列模型，虽然简单，但是具有典型性，可以应付实际生产中的一部分需求，你可以基于这个基础模型进行扩展，不管怎么扩展其基本原理都是一样的。\n例如，如果生产者和消费者（即产生任务者和处理任务者）的速度差不多，可以将队列改成环形队列，以节省内存空间。另外，很多应用为了追求效率，利用一些技巧将队列无锁化。这些都是仁者见仁智者见智的扩展了，本文不再介绍。不管如何，希望读者一定要理解线程池和任务队列的基本设计原理，只有这样你才能做更多高级的扩展和设计。\n消息中间件基于生产者消费者理论模型的队列系统在实际开发中实在是太常用了，以至于在一组服务中可能每个进程都需要一个这样的队列系统。既然如此，出于复用和解耦的目的，业界产生了许多独立的队列系统，这些队列系统或以一个独立的进程运行或以支持分布式的一组服务运行。我们把这种独立的队列系统称之为消息中间件。这些消息中间件在功能上做了丰富的扩展，如消费的方式、主备切换、容灾容错，数据自动备份和过期数据自动清理等等，比较典型的有 Kafka、ActiveMQ、RabbitMQ、````` 等。下图是 Kafka 官网提供的一张介绍 Kafka 作用的图片：\n\n下图是笔者开发过的一个金融交易系统后台服务拓扑图，其大量使用消息中间件 Kafka：\n\n整个交易的流程如下：\n\n前端通过 HTTP 请求向下单服务请求下单，下单服务在校验完数据后，会向消息中间件 A1 投递一条下单请求；\n成交服务订阅了消息中间件 A1 的消息，取出下单请求，结合自己的成交规则，如果可以成交，向消息中间件 A2 投递一条成交后的消息；\n结算服务订阅了消息中间件A2，从其中拿到成交消息后，对用户资金账户进行结算，结算完成后，用户的下单就算正式完成了，然后产生一条行情消息投递给消息中间件 A3；\n行情推送服务器从消息中间件 A3 中拿到行情消息后推送给所有已经连接的客户端。上述过程中，每个消息中间件（Kafka）都有一个生产者和消费者，虚线箭头表示短连接，实线箭头表示长连接。当然，实际的金融交易系统要比这里的模型复杂许多，这里为了演示方便做了大量简化。\n\n有了这种专门的队列系统，生产者和消费者将最大化解耦，利用消息中间件提供的对外消息接口，生产者只需要负责生产消息，它不必关心谁是消费者，消费者也不用关心生产者是谁、何时有数据，而队列系统本身也不关心自己有多少生产者和消费者。当然，这种消息中间件还有其他一些非常优秀的功能，如对数据的备份、负载和容灾容错措施。建议学有余力的读者适当地去了解一两种开源的队列系统的使用方法，如果掌握其设计思路那就善莫大焉了。\n总结本节基于生产者和消费者模型介绍了线程池和衍生出来的消息中间件，线程池是开发中常用的技术手段之一，希望读者务必掌握其原理和编写方法，而消息中间件广泛地用于多服务系统之间，建议了解一两种开源的消息中间件的使用方法。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"线程局部存储","url":"/2021/10/18/CPP-multithreaded-16/","content":"音乐小港\n    \n\n\n线程局部存储对于一个存在多个线程的进程来说，有时候我们需要有一份数据是每个线程都拥有的，也就是说每个线程自己操作自己的这份数据，这有点类似 C++ 类的实例属性，每个实例对象操作的都是自己的属性。我们把这样的数据称之为线程局部存储（Thread Local Storage，TLS），对应的存储区域叫做线程局部存储区。\nWindows 的线程局部存储Windows 系统将线程局部存储区分成 TLS_MINIMUM_AVAILABLE 个块，每一块通过一个索引值对外提供访问。\n\nTLS_MINIMUM_AVAILABLE 的默认是 64。在 winnt.h 中定义：\n# define TLS_MINIMUM_AVAILABLE 64\n\n\nWindows 中使用函数 TlsAlloc 获得一个线程局部存储块的索引：\nDWORD TlsAlloc();\n如果这个函数调用失败，则返回值是 TLS_OUT_OF_INDEXES（0xFFFFFFFF）；如果函数调用成功，得到一个索引，接下来就可以利用这个索引去往这个内存块中存储数据或者从这个内存块中得到数据，分别使用如下两个 API 函数：\nLPVOID TlsGetValue(DWORD dwTlsIndex);BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);\n当你不再需要这个存储区域时，你应该释放它，释放调用函数：\nBOOL TlsFree(DWORD dwTlsIndex);\n当然，使用线程局部存储除了使用上面介绍的 API 函数外，Microsoft VC++ 编译器还提供了如下方法定义一个线程局部变量：\n__declspec(thread) int g_mydata = 1;\n我们看一个具体例子：\n#include &lt;Windows.h&gt;#include &lt;iostream&gt;__declspec(thread) int g_mydata = 1;DWORD __stdcall WorkerThreadProc1(LPVOID lpThreadParameter){    while (true)    {        ++g_mydata;        //std::cout &lt;&lt; \"g_mydata = \" &lt;&lt; g_mydata &lt;&lt; \", ThreadID = \" &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;        Sleep(1000);    }    return 0;}DWORD __stdcall WorkerThreadProc2(LPVOID lpThreadParameter){    while (true)    {               std::cout &lt;&lt; \"g_mydata = \" &lt;&lt; g_mydata &lt;&lt; \", ThreadID = \" &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;        Sleep(1000);    }    return 0;}int main(){    HANDLE hWorkerThreads[2];    hWorkerThreads[0] = CreateThread(NULL, 0, WorkerThreadProc1, NULL, 0, NULL);    hWorkerThreads[1] = CreateThread(NULL, 0, WorkerThreadProc2, NULL, 0, NULL);    CloseHandle(hWorkerThreads[0]);    CloseHandle(hWorkerThreads[1]);    while (true)    {        Sleep(1000);    }    return 0;}\n上述代码中全局变量 g_mydata 是一个线程局部变量，因此该进程中每一个线程都会拥有这样一个变量副本，由于是不同的副本，WorkerThreadProc1 中将这个变量不断递增，对 WorkerThreadProc2 的 g_mydata 不会造成任何影响，因此其值始终是 1。程序执行结果如下：\n\n\n需要说明的是，在 Windows 系统中被声明成线程局部变量的对象，在编译器生成可执行文件时，会在最终的 PE 文件中专门生成一个叫 tls 的节，这个节用于存放这些线程局部变量。\n\nLinux 的线程局部存储Linux 系统上的 NTPL 提供了一套函数接口来实现线程局部存储的功能：\nint pthread_key_create(pthread_key_t* key, void (*destructor)(void*));int pthread_key_delete(pthread_key_t key);int pthread_setspecific(pthread_key_t key, const void* value);void* pthread_getspecific(pthread_key_t key);\npthread_key_create 函数调用成功会返回 0 值，调用失败返回非 0 值，函数调用成功会为线程局部存储创建一个新键，用户通过参数 key 去设置（调用 pthread_setspecific）和获取（pthread_getspecific）数据，因为进程中的所有线程都可以使用返回的键，所以参数 key 应该指向一个全局变量。\n参数 destructor 是一个自定义函数指针，其签名是：\nvoid* destructor(void* value){    /*多是为了释放 value 指针指向的资源*/}\n线程终止时，如果 key 关联的值不是 NULL，那么 NTPL 会自动执行定义的 destructor 函数；如果无须解构，可以将 destructor 设置为 NULL。\n我们来看一个具体例子：\n#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//线程局部存储 keypthread_key_t thread_log_key;void write_to_thread_log(const char* message){    if (message == NULL)        return;    FILE* logfile = (FILE*)pthread_getspecific(thread_log_key);    fprintf(logfile, \"%s\\n\", message);    fflush(logfile);} void close_thread_log(void* logfile){    char logfilename[128];    sprintf(logfilename, \"close logfile: thread%ld.log\\n\", (unsigned long)pthread_self());    printf(logfilename);    fclose((FILE *)logfile);} void* thread_function(void* args){    char logfilename[128];    sprintf(logfilename, \"thread%ld.log\", (unsigned long)pthread_self());    FILE* logfile = fopen(logfilename, \"w\");    if (logfile != NULL)    {        pthread_setspecific(thread_log_key, logfile);        write_to_thread_log(\"Thread starting...\");    }    return NULL;} int main(){    pthread_t threadIDs[5];     pthread_key_create(&amp;thread_log_key, close_thread_log);    for(int i = 0; i &lt; 5; ++i)    {        pthread_create(&amp;threadIDs[i], NULL, thread_function, NULL);    }    for(int i = 0; i &lt; 5; ++i)    {        pthread_join(threadIDs[i], NULL);    }    return 0;}\n上述程序一共创建 5 个线程，每个线程都会自己生成一个日志文件，每个线程将自己的日志写入自己的文件中，当线程执行结束时，会关闭打开的日志文件句柄。\n程序运行结果如下：\n\n生成的 5 个日志文件中，其内容都写入了一行“Thread starting…”。\n上面的程序首先调用 pthread_key_create 函数来申请一个槽位。在 NPTL 实现下，pthread_key_t 是无符号整型，pthread_key_create 调用成功时会将一个小于 1024 的值填入第一个入参指向的 pthread_key_t 类型的变量中。之所以小于 1024，是因为 NPTL 实现一共提供了 1024 个槽位。\n如图所示，记录槽位分配情况的数据结构 pthread_keys 是进程唯一的，pthread_keys 结构示意图如下：\n\n和 Windows 一样 Linux gcc 编译器也提供了一个关键字 __thread 去简化定义线程局部变量。例如：\n__thread int val = 0;\n我们再来看一个示例：\n#include &lt;pthread.h&gt;#include &lt;iostream&gt;#include &lt;unistd.h&gt;//线程局部存储 key__thread int g_mydata = 99;void* thread_function1(void* args){    while (true)    {        g_mydata ++;    }    return NULL;} void* thread_function2(void* args){    while (true)    {               std::cout &lt;&lt; \"g_mydata = \" &lt;&lt; g_mydata &lt;&lt; \", ThreadID: \" &lt;&lt; pthread_self() &lt;&lt; std::endl;        sleep(1);    }    return NULL;} int main(){    pthread_t threadIDs[2];     pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);    for(int i = 0; i &lt; 2; ++i)    {        pthread_join(threadIDs[i], NULL);    }    return 0;}\n由于 thread_function1 修改的是自己的 g_mydata，因此 thread_function2 输出 g_mydata 的值始终是 99。\n[root@localhost testmultithread]# g++ -g -o linuxtls2 linuxtls2.cpp -lpthread[root@localhost testmultithread]# ./linuxtls2g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096g_mydata = 99, ThreadID: 140243186276096...更多输出结果省略...\nC++ 11 的 thread_local 关键字C++ 11 标准提供了一个新的关键字 thread_local 来定义一个线程变量。使用方法如下：\nthread_local int g_mydata = 1;\n有了这个关键字，使用线程局部存储的代码同时在 Windows 和 Linux 运行了。示例如下：\n#include &lt;thread&gt;#include &lt;chrono&gt;#include &lt;iostream&gt;thread_local int g_mydata = 1;void thread_func1(){    while (true)    {        ++g_mydata;    }}void thread_func2(){    while (true)    {        std::cout &lt;&lt; \"g_mydata = \" &lt;&lt; g_mydata &lt;&lt; \", ThreadID = \" &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;        std::this_thread::sleep_for(std::chrono::seconds(1));    }}int main(){    std::thread t1(thread_func1);    std::thread t2(thread_func2);    t1.join();    t2.join();    return 0;}\n需要注意的是，如果读者是在 Windows 平台下，虽然 thread_local 关键字在 C++ 11 标准中引入，但是 Visual Studio 2013 （支持 C++ 11 语法的最低的一个版本）编译器却并不支持这个关键字，建议在 Visual Studio 2015 及以上版本中测试上述代码。\n总结最后关于线程局部存储变量，我还再强调两点：\n\n对于线程变量，每个线程都会有该变量的一个拷贝，并行不悖，互不干扰，该局部变量一直都在，直到线程退出为止；\n系统的线程局部存储区域内存空间并不大，因此尽量不要利用这个空间存储大的数据块，如果不得不使用大的数据块，可以将大的数据块存储在堆内存中，再将该堆内存的地址指针存储在线程局部存储区域。\n\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"C 库的非线程安全函数","url":"/2021/10/18/CPP-multithreaded-17/","content":"音乐小港\n    \n\n\nC 库的非线程安全函数我们先来看一段代码：\n#include &lt;time.h&gt;int main(){    time_t tNow = time(NULL);    time_t tEnd = tNow + 1800;    //注意下面两行的区别    struct tm* ptm = localtime(&amp;tNow);    struct tm* ptmEnd = localtime(&amp;tEnd);    char szTmp[50] = { 0 };    strftime(szTmp, 50, \"%H:%M:%S\", ptm);    //struct tm* ptmEnd = localtime(&amp;tEnd);    char szEnd[50] = { 0 };    strftime(szEnd, 50, \"%H:%M:%S\", ptmEnd);    printf(\"%s \\n\", szTmp);    printf(\"%s \\n\", szEnd);    return 0;}\n程序执行结果如下图所示：\n20:53:4820:53:48\n很奇怪是不是？tNow 和 tEnd 明明相差 1800 秒。我们调整一下代码第 9 行的位置：\n#include &lt;time.h&gt;int main(){    time_t tNow = time(NULL);    time_t tEnd = tNow + 1800;    //注意下面两行的区别    struct tm* ptm = localtime(&amp;tNow);        char szTmp[50] = { 0 };    strftime(szTmp, 50, \"%H:%M:%S\", ptm);    struct tm* ptmEnd = localtime(&amp;tEnd);    char szEnd[50] = { 0 };    strftime(szEnd, 50, \"%H:%M:%S\", ptmEnd);    printf(\"%s \\n\", szTmp);    printf(\"%s \\n\", szEnd);    return 0;}\n这次输出结果正确了：\n20:25:4420:55:44\n为什么会出现这种情况呢？我们来看下 localtime 函数的签名：\nstruct tm* localtime(const time_t* timep);\n这个函数返回值一个 tm 结构体指针类型，而我们外部并不需要释放这个指针指向的内存，因此断定这个函数内部一定使用了一个全局变量或函数内部的静态变量。这样的话，当再次调用这个函数时有可能前一次调用结果就被后一个结果覆盖了。我们简化一下这种模型：\nint* func(int k){    static int result;    result = k;    return &amp;result;}\n当多个线程甚至单个线程调用这个函数时，如两个线程分别调用上述函数：\n//线程1调用int* p1 = func(1);//线程2调用int* p2 = func(2);\n那么 * p1 和 * p2 的结果会是什么呢？结论是可能是 1 也可能是 2，甚至既不是 1 也不是 2。原因我们在前面《为什么整形变量赋值操作不是原子》的小节已经介绍过了。\n像 localtime 这类 CRT 提供的具有上述行为的函数，我们称为非线程安全函数。因此在实际开发中应避免在多线程程序中使用这类函数，这类函数还有如 strtok，甚至连操作系统提供的 socket 函数 gethostbyname 也不是线程安全的。\nchar* strtok(char* str, const char* delim);struct hostent* gethostbyname(const char* name);\n为什么会出现这类函数呢？是因为最初编写很多 CRT 函数时，还没有多线程技术，所以很多函数内部实现都使用了函数内部的静态变量和全局变量。随着多线程技术的出现，很多函数出现了对应的多线程安全版本，如 localtime_r、strtok_r。在这些函数内部很多改用了线程局部存储 技术来替代原来使用静态变量或者全局变量的做法。\n因此，在实际开发中如果一个 CRT 函数可能被多个线程调用，要注意其是否是多线程安全函数，如果不是多线程安全的，要改用其线程安全的版本。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"协程技术与总结","url":"/2021/10/18/CPP-multithreaded-19/","content":"音乐小港\n    \n\n\n协程技术与总结协程我们知道，线程是操作系统的内核对象，多线程编程时，如果线程数过多，就会导致频繁的上下文切换，这些对性能是一种额外的损耗。例如，在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 连接是很不明智的，因此现在的主流做法是利用操作系统提供了基于事件模式的异步编程模型，用少量的线程来服务大量的网络连接和 IO。但是采用异步和基于事件的编程模型，让程序代码变得复杂，非常容易出错，也提高排查错误的难度。\n协程，是在应用层模拟的线程，它避免了上下文切换的额外损耗，同时又兼顾了多线程的优点，简化了高并发程序的复杂度。还是以上面高并发的网络服务器为例，可以为每一个 socket 连接使用一个协程来处理，在兼顾性能的情况下，代码也清晰。\n协程是在1963 年由 Melvin E. Conway USAF, Bedford, MA 等人提出的一个概念，且协程的概念是早于线程提出的。但是由于协程是非抢占式的调度，无法实现公平的任务调用，也无法直接利用多核 CPU 的优势，因此，我们不能武断地说协程是比线程更高级的技术。尽管协程的概念早于线程提出，但是目前主流的操作系统原生 API 并不支持协程技术，新兴的一些高级编程语言如 Golang 都是在语言的运行时环境中自己利用线程技术模拟了一套协程。\n这些语言协程的内部实现上都是是基于线程的，思路是维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？\n以 Golang 为例，Golang 对操作系统的各种 IO 函数（如 Linux 的 epoll、select，Windows 的 IOCP 等）进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 IO 函数，当这些异步函数返回 busy 或 blocking 时，Golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行。\n由于 Golang 是从编译器和语言基础库多个层面对协程做了实现，因而，Golang 的协程是目前各类存在协程概念的语言中实现的最完整和成熟的，十万个协程同时运行也毫无压力。带来的优势就是，程序员可以在编写 Golang 代码的时候，可以更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。\n现今之所以协程技术这么流行是因为大多数设计喜欢使用异步编程以追求程序的性能，这就强行的将线性的程序逻辑打乱，程序逻辑变得非常的混乱与复杂。对程序状态的管理也变得异常困难，例如 NodeJS 那恶心的层层 Callback。在我们疯狂被 NodeJS 的层层回调恶心到的时候，Golang 作为名门之后开始进入广大开发者的视野，并且迅速的在 Web 后端攻城略地。例如，以 Docker 以及围绕 Docker 展开的整个容器生态圈为代表，其最大的卖点就是协程技术，至此协程技术开始真正的流行与被讨论起来。\n腾讯公司开源了一套 C/C++ 版本的协程库 libco，有兴趣的读者可以研究一下其实现原理。\n因此，协程技术从来不是什么新东西，只是人们为了从重复复杂的底层技术中解脱出来，能够快速专注业务开发而带来的产物。万变不离其宗，只要我们掌握了多线程编程的技术的核心原理，我们也能快速的学习协程技术。\n课程总结至此，本课程也就全部结束了。在整个课程中介绍了目前主流的 C/C++ 开发环境下的两个操作系统 Windows 和 Linux 系统层面上的线程原理和多线程资源同步技术的方方面面，同时基于这些基础知识延伸出了更高级的线程池技术和队列系统，也介绍了目前前沿的协程技术。\n无论某种编程语言和其运行时环境（如 Java、Python）对操作系统的线程功能增加了多少中间层、封装了多少功能的，操作线程提供的线程相关 API 和同步接口是最基础的，且由于这些接口是操作系统提供的，它们在相当长的时间内都会基本保持不变，一旦你理解并熟练使用它们，你不仅可以灵活地学习和开发出强大的多线程程序来，同时也能快速地理解其他语言中的各种线程同步概念和技术。\n多线程编程技术是怎么强调也不过份基本功，希望读者能够非常熟练地掌握它们，这种熟练掌握不仅是理解其原理，一定是熟悉到具体的 API 层面来上。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"整型变量的原子操作","url":"/2021/10/18/CPP-multithreaded-4/","content":"音乐小港\n    \n\n\n整型变量的原子操作从本讲开始，我们讨论的主题为线程之间的同步技术。所谓线程同步技术，指的是多个线程同时操作某个资源（从程序的术语来说，这里的资源可能是一个简单的整型变量，也可能是一个复杂的 C++ 对象）。多线程同时操作资源指的是多线程同时对资源的读和写，我们需要采取一些特殊的措施去保护这些资源，以免引起一些资源访问冲突（如死锁）或者得到意料外的结果。\n当然，最简单的资源类型应该就是整形变量了。这里给大家说个小故事：在我刚开始参加工作的那年，公司安排我开发一款即时通讯软件（IM，类似于 QQ 聊天软件），在这之前我心里也知道如果多线程操作一个整型值是要加锁的，但是当时为了图代码简便，而且在实际调试的时候，没有加锁的代码也从来没出过问题。于是我就心存侥幸了，觉得对整型值加锁真是多此一举。\n我们的软件有类似于 QQ 这种单人聊天功能，每个用户都有一个整型的 userid，问题就出在这里。当时公司的老板和他媳妇儿也使用这款软件，问题来了：有一天早上老板在这个软件上给他媳妇发了一段亲密的话，问题是，由于多线程操作他媳妇儿的 userid 没加锁，最终变成了另外一个人的 userid，而这个 userid 恰好是我的账户。于是老板发给他媳妇儿的聊天内容就被发给我了。我当时看到聊天内容很奇怪，还回复了他一句，并且还带上了我自己的姓名……事情的结果，可想而知了，老板非常尴尬也非常生气……从那以后，老板看我的眼神都是怪怪的。我自知理亏，再也不侥幸了，凡是多线程读写整型变量都养成加锁的好习惯。\n为什么整型变量赋值操作不是原子的\n那么为什么整型变量的操作不是原子性的呢？常见的整型变量操作有如下几种情况：\n\n给整型变量赋值一个确定的值，如：\nint a = 1;\n这条指令操作一般是原子的，因为对应着一条计算机指令，CPU 将立即数 1 搬运到变量 a 的内存地址中即可，汇编指令如下：\nmov dword ptr [a], 2\n然后这确是最不常见的情形，由于现代编译器一般存在优化策略，如果变量 a 的值在编译期间就可以计算出来（例如这里的例子中 a 的值就是1），那么 a 这个变量本身在正式版本的软件中（release 版）就很有可能被编译器优化掉，凡是使用 a 的地方，直接使用常量 1 来代替。因此实际的执行指令中，这样的指令存在的可能性比较低。\n\n变量自身增加或者减去一个值，如：\na ++;\n从 C/C++ 语法的级别来看，这是一条语句，是原子的；但是从实际执行的二进制指令来看，也不是原子的，其一般对应三条指令，首先将变量 a 对应的内存值搬运到某个寄存器（如 eax ）中，然后将该寄存器中的值自增 1，再将该寄存器中的值搬运回 a 代表的内存中：\nmov eax, dword ptr [a]inc eaxmov dword ptr [a], eax\n现在假设 a 的值是 0，有两个线程，每个线程对变量 a 的值递增 1，我们预想的结果应该是 2，可实际运行的结果可能是 1！是不是很奇怪？分析如下：\nint a = 0;//线程1void thread_func1(){    a ++;}//线程2void thread_func2(){    a ++;}\n\n\n我们预想的结果是线程 1 和 线程 2 的三条指令各自执行，最终 a 的值变为 2，但是由于操作系统线程调度的不确定性，线程 1 执行完指令 ① 和 ② 后，eax 寄存器中的值变为 1，此时操作系统切换到 线程2 执行，执行指令 ③ ④ ⑤，此时 eax 的值变为 1；接着操作系统切回线程 1 继续执行，执行指令 ⑥，得到 a 的最终结果 1。\n\n把一个变量的值赋值给另外一个变量，或者把一个表达式的值赋值给另外一个变量，如\nint a = b;\n从 C/C++ 语法的级别来看，这也是一条语句，是原子的；但是从实际执行的二进制指令来看，由于现代计算机 CPU 架构体系的限制，数据不可以直接从内存搬运到另外一块内存，必须借助寄存器中转，这条语句一般对应两条计算机指令，即将变量 b 的值搬运到某个寄存器（如 eax）中，再从该寄存器搬运到变量 a 的内存地址：\nmov eax, dword ptr [b]mov dword ptr [a], eax \n既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺 CPU 时间片，切换到另外一个线程而产生不确定的情况。这和上一种情况类似，就不再详细分析了。\n说点题外话，网上很多人强调某些特殊的整型数值类型（如 bool 类型）的操作是原子的，这是由于，某些 CPU 生产商开始有意识地从硬件平台保证这一类操作的原子性，但这并不是每一种类型的 CPU 架构都支持，在这一事实成为标准之前，我们在多线程操作整型时还是老老实实使用下文介绍的原子操作或线程同步技术来对这些数据类型进行保护。\n\n\nWindows 平台上整型变量的原子操作整型变量的原子操作是一些非常常用且实用的操作，因此 Windows 操作系统也提供了 API 级别的支持，使用这些 API 可以直接对整型变量进行原子操作，而不用借助专门的锁对象，在 Windows 平台上，它们是 Interlocked 系列函数。这里给出 Interlocked 常用的 API 的一个列表：\n\n\n\n函数名\n函数说明\n\n\n\nInterlockedIncrement\n将 32 位整型变量自增 1\n\n\nInterlockedDecrement\n将 32 位整型变量自减 1\n\n\nInterlockedExchangeAdd\n将 32 位整型值增加 n （n 可以是负值）\n\n\nInterlockedXor\n将 32 位整型值与 n 进行异或操作\n\n\nInterlockedCompareExchange\n将 32 位整型值与 n1 进行比较，如果相等，则替换成 n2\n\n\n上表中仅列出了与 32 位（bit）整型相关的 API 函数，Windows 还提供了对 8 位、16 位以及 64 位的整型变量进行原子操作的 API，读者在实际使用时可以自行参考 MSDN。\n我们以上表中 InterlockedIncrement 为例来说明这类函数的用法，InterlockedIncrement 的函数签名是：\nLONG InterlockedIncrement(LONG volatile *Addend);\n这个函数的作用是将变量 Addend 自增 1，并返回自增后的值。\n\n注意：这里的 LONG 型即 long 型，在 32 位系统中，LONG 占 4个字节。\n\n我们来写一个例子来验证一下：\n#include &lt;Windows.h&gt;\nint main(){    LONG nPreValue = 99;    LONG nPostValue = InterlockedIncrement(&amp;nPreValue);    printf(\"nPreValue=%d, nPostValue=%d\\n\", nPreValue, nPostValue);    return 0;}\n程序执行结果：\n\nC++11 对整型变量原子操作的支持在 C++ 98/03 标准中，如果想对整型变量进行原子操作，要么利用操作系统提供的相关原子操作 API，要么利用对应操作系统提供的锁对象来对变量进行保护，无论是哪种方式，编写的代码都无法实现跨平台操作。例如上一小介绍的 Interlocked 系列 API 代码仅能运行于 Windows 系统，无法移植到 Linux 系统。C++ 11 新标准发布以后，改变了这种困境，新标准提供了对整型变量原子操作的相关库，即 std::atomic ，这是一个模板类型：\ntemplate&lt;class T&gt;struct atomic;\n你可以传入具体的整型类型（如 bool、char、short、int、uint 等）对模板进行实例化，实际上 stl 库也提供了这些实例化的模板类型：\n\n上表中仅列出了 C++ 11 支持的常用的整型原子变量，完整的列表读者可以参考这里。\n有了 C++ 语言本身对原子变量的支持以后，我们就可以“愉快地”写出跨平台的代码了，来看一段代码：\n#include &lt;atomic&gt;#include &lt;stdio.h&gt;int main(){    std::atomic&lt;int&gt; value;    value = 99;    printf(\"%d\\n\", (int)value);    //自增1，原子操作    value++;    printf(\"%d\\n\", (int)value);    return 0;}\n以上代码可以同时在 Windows 和 Linux 平台上运行，但是有读者可能会根据个人习惯将上述代码写成如下形式：\n#include &lt;atomic&gt;#include &lt;stdio.h&gt;int main(){    std::atomic&lt;int&gt; value = 99;    printf(\"%d\\n\", (int)value);    //自增1，原子操作    value++;    printf(\"%d\\n\", (int)value);    return 0;}\n代码仅仅做了一点简单的改动，这段代码在 Windows 平台上运行良好，但是在 Linux 平台上会无法编译通过（这里指的是在支持 C++ 11 语法的 G++ 编译中编译），提示错误是：\nerror: use of deleted function ‘std::atomic&lt;int&gt;::atomic(const std::atomic&lt;int&gt;&amp;)’\n产生这个错误的原因是 “std::atomic\\ value = 99;” 这一行代码调用的是 std::atomic 的拷贝构造函数，对于 int 型，其形式一般如下：\nstd::atomic&lt;int&gt;::atomic(const std::atomic&lt;int&gt;&amp; rhs);\n而根据 C++ 11 的规范，这个拷贝构造函数是默认使用 =delete 语法禁止编译器生成的，g++ 遵循了这个标准，参见这里：\natomic&amp; operator=( const atomic&amp; ) = delete;\n因此 Linux 平台上编译器会提示错误，而 Windows 的 VC++ 编译器没有遵循这个规范。而对于代码：\nvalue = 99;\ng++ 和 VC++ 同时实现规范中的：\nT operator=( T desired )\n\n因此，如果读者想利用 C++ 11 提供的 std::atomic 库编写跨平台的代码，在使用 std::atomic 提供的方法时建议参考官方 std::atomic 提供的接口说明来使用，而不是想当然地认为一个方法在此平台上可以运行，在另外一个平台也能有相同的行为，避免出现上面说的这种情形。\n\n上述代码中之所以可以对 value 进行自增（++）操作是因为 std::atomic 类内部重载了 operator++ 运算符，除此以外， std::atomic 还提供了大量有用的方法，这些方法读者一定会觉得似曾相似：\n\n上表中各个函数基本上是见名知义，读者不必死记硬背，需要时知道如何查询即可。\n总结本讲介绍了整型变量的原子操作，以及为何多线程操作一个整型变量是不安全的。整型变量的原子操作是实际开发中非常常用一个技术场景，建议读者熟练掌握。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"如何等待线程结束","url":"/2021/10/18/CPP-multithreaded-2/","content":"音乐小港\n    \n\n\n如何等待线程结束前面课程介绍了创建线程，既然线程可以创建，线程也应该可以结束。那如何等待一个线程结束呢？\n实际项目开发中，我们常常会有这样一种需求，即一个线程需要等待另外一个线程执行完任务退出后再继续执行。这在 Linux 和 Windows 操作系统中都提供了相应的操作系统 API，我们来分别介绍一下。\nLinux 下等待线程结束Linux 线程库提供了 pthread_join 函数，用来等待某线程的退出并接收它的返回值。这种操作被称为连接（joining），pthread_join 函数签名如下：\nint pthread_join(pthread_t thread, void** retval);\n\n参数 thread，需要等待的线程 id。\n参数 retval，输出参数，用于接收等待退出的线程的退出码（Exit Code），线程退出码可以通过调用 pthread_exit 退出线程时指定，也可以在线程函数中通过 return 语句返回。#include &lt;pthread.h&gt;void pthread_exit(void* value_ptr);&amp;nbsp;\n参数 value_ptr 的值可以在 pthread_join 中拿到，没有可以设置为 NULL。\n\npthread_join 函数等待其他线程退出期间会挂起等待的线程，被挂起的线程不会消耗宝贵任何 CPU 时间片。直到目标线程退出后，等待的线程会被唤醒。\n我们通过一个实例来演示一下这个函数的使用方法，实例功能如下：\n程序启动时，开启一个工作线程，工作线程将当前系统时间写入文件中后退出，主线程等待工作线程退出后，从文件中读取出时间并显示在屏幕上。代码如下：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;pthread.h&gt;#define TIME_FILENAME \"time.txt\"void* fileThreadFunc(void* arg){    time_t now = time(NULL);    struct tm* t = localtime(&amp;now);    char timeStr[32] = {0};    snprintf(timeStr, 32, \"%04d/%02d/%02d %02d:%02d:%02d\",              t-&gt;tm_year+1900,             t-&gt;tm_mon+1,             t-&gt;tm_mday,             t-&gt;tm_hour,             t-&gt;tm_min,             t-&gt;tm_sec);    //文件不存在，则创建；存在，则覆盖    FILE* fp = fopen(TIME_FILENAME, \"w\");    if (fp == NULL)    {      printf(\"Failed to create time.txt.\\n\");        return;    }    size_t sizeToWrite = strlen(timeStr) + 1;    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);    if (ret != sizeToWrite)    {        printf(\"Write file error.\\n\");    }    fclose(fp);}int main(){    pthread_t fileThreadID;    int ret = pthread_create(&amp;fileThreadID, NULL, fileThreadFunc, NULL);    if (ret != 0)    {        printf(\"Failed to create fileThread.\\n\");        return -1;    }    int* retval;    pthread_join(fileThreadID, (void**)&amp;retval);    //使用r选项，要求文件必须存在    FILE* fp = fopen(TIME_FILENAME, \"r\");    if (fp == NULL)    {        printf(\"open file error.\\n\");        return -2;    }    char buf[32] = {0};    int sizeRead = fread(buf, 1, 32, fp);    if (sizeRead == 0)    {      printf(\"read file error.\\n\");      return -3;    }    printf(\"Current Time is: %s.\\n\", buf);    return 0;}\n程序执行结果如下：\n[root@localhost threadtest]# ./testCurrent Time is: 2018/09/24 21:06:01.\nWindows 下等待线程结束Windows 下使用 API WaitForSingleObject 或 WaitForMultipleObjects 函数，前者用于等待一个线程结束，后者可以同时等待多个线程结束。这是两个非常重要的函数，它们的作用不仅可以用于等待线程退出，还可以用于等待其他线程同步对象，本文后面的将详细介绍这两个函数。与 Linux 的 pthread_join 函数不同，Windows 的WaitForSingleObject 函数提供了可选择等待时间的精细控制。\n这里我们仅演示等待线程退出。\nWaitForSingleObject 函数签名如下：\nDWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);\n\n参数 hHandle 是需要等待的对象的句柄，等待线程退出，传入线程句柄。\n参数 dwMilliseconds 是需要等待的毫秒数，如果使用 INFINITE 宏，则表示无限等待下去。\n返回值：该函数的返回值有点复杂，我们后面文章具体介绍。当 dwMilliseconds 参数使用 INFINITE 值，该函数会挂起当前等待线程，直到等待的线程退出后，等待的线程才会被唤醒，WaitForSingleObject 后的程序执行流继续执行。我们将上面的 Linux 示例代码改写成 Windows 版本的：#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;Windows.h&gt;#define TIME_FILENAME \"time.txt\"DWORD WINAPI FileThreadFunc(LPVOID lpParameters){    time_t now = time(NULL);    struct tm* t = localtime(&amp;now);    char timeStr[32] = { 0 };    sprintf_s(timeStr, 32, \"%04d/%02d/%02d %02d:%02d:%02d\",              t-&gt;tm_year + 1900,              t-&gt;tm_mon + 1,              t-&gt;tm_mday,              t-&gt;tm_hour,              t-&gt;tm_min,              t-&gt;tm_sec);    //文件不存在，则创建；存在，则覆盖    FILE* fp = fopen(TIME_FILENAME, \"w\");    if (fp == NULL)    {        printf(\"Failed to create time.txt.\\n\");        return 1;    }    size_t sizeToWrite = strlen(timeStr) + 1;    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);    if (ret != sizeToWrite)    {        printf(\"Write file error.\\n\");    }    fclose(fp);    return 2;}int main(){    DWORD dwFileThreadID;    HANDLE hFileThread = CreateThread(NULL, 0, FileThreadFunc, NULL, 0,                                       &amp;dwFileThreadID);    if (hFileThread == NULL)    {        printf(\"Failed to create fileThread.\\n\");        return -1;    }    //无限等待，直到文件线程退出，否则程序将一直挂起    WaitForSingleObject(hFileThread, INFINITE);    //使用r选项，要求文件必须存在    FILE* fp = fopen(TIME_FILENAME, \"r\");    if (fp == NULL)    {        printf(\"open file error.\\n\");        return -2;    }    char buf[32] = { 0 };    int sizeRead = fread(buf, 1, 32, fp);    if (sizeRead == 0)    {        printf(\"read file error.\\n\");        return -3;    }    printf(\"Current Time is: %s.\\n\", buf);    return 0;}\n与 Linux 版本一样，我们得到类似的程序执行结果：\n\n\nC++ 11 提供的等待线程结果函数可以想到，C++ 11 的 std::thread 既然统一了 Linux 和 Windows 的线程创建函数，那么它应该也提供等待线程退出的接口，确实如此，std::thread 的 join 方法就是用来等待线程退出的函数。当然使用这个函数时，必须保证该线程还处于运行中状态，也就是说等待的线程必须是可以 “join”的，如果需要等待的线程已经退出，此时调用join 方法，程序会产生崩溃。因此，C++ 11 的线程库同时提供了一个 joinable 方法来判断某个线程是否可以 join，如果不确定线程是否可以“join”，可以先调用 joinable 函数判断一下是否需要等待。\n还是以上面的例子为例，改写成 C++11 的代码：\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;#include &lt;thread&gt;#define TIME_FILENAME \"time.txt\"void FileThreadFunc(){    time_t now = time(NULL);    struct tm* t = localtime(&amp;now);    char timeStr[32] = { 0 };    sprintf_s(timeStr, 32, \"%04d/%02d/%02d %02d:%02d:%02d\",              t-&gt;tm_year + 1900,              t-&gt;tm_mon + 1,              t-&gt;tm_mday,              t-&gt;tm_hour,              t-&gt;tm_min,              t-&gt;tm_sec);    //文件不存在，则创建；存在，则覆盖    FILE* fp = fopen(TIME_FILENAME, \"w\");    if (fp == NULL)    {        printf(\"Failed to create time.txt.\\n\");        return;    }    size_t sizeToWrite = strlen(timeStr) + 1;    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);    if (ret != sizeToWrite)    {        printf(\"Write file error.\\n\");    }    fclose(fp);}int main(){    std::thread t(FileThreadFunc);    if (t.joinable())        t.join();    //使用 r 选项，要求文件必须存在    FILE* fp = fopen(TIME_FILENAME, \"r\");    if (fp == NULL)    {        printf(\"open file error.\\n\");        return -2;    }    char buf[32] = { 0 };    int sizeRead = fread(buf, 1, 32, fp);    if (sizeRead == 0)    {        printf(\"read file error.\\n\");        return -3;    }    printf(\"Current Time is: %s.\\n\", buf);    return 0;}\n总结在 A 线程等待 B 线程结束，相当于 A 线程和 B 线程在该点汇集（或连接），这就是 join 函数的语义来源，因此很多其他编程语言也使用 join 一词表示等待线程结束。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Windows 线程资源同步之临界区","url":"/2021/10/18/CPP-multithreaded-5/","content":"音乐小港\n    \n\n\nWindows 线程资源同步之临界区前面章节介绍了多线程编程的一些基础内容，从本讲开始，我将系统地介绍一遍 Windows 和 Linux 操作系统下各种常用的多线程资源同步对象。\n在开始介绍 Windows 多线程资源同步之前，我们来介绍两个重要的 Windows API 函数 WaitForSingleObject 和 WaitForMultipleObjects，Windows 上所有多线程同步对象基本上都是通过这两个函数完成的，前者只能一次操作一个资源同步对象，后者可以同时操作多个资源同步对象。\nWaitForSingleObject 与 WaitForMultipleObjects 函数先来说 WaitForSingleObject，这个函数的签名是：\nDWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);\n这个函数的作用是等待一个内核对象，在 Windows 系统上一个内核对象通常使用其句柄来操作，参数 hHandle 即需要等待的内核对象，参数 dwMilliseconds 是等待这个内核对象的最大时间，时间单位是毫秒，其类型是 DWORD，这是一个 unsigned long 类型。如果我们需要无限等待下去，可以将这个参数值设置为 INFINITE 宏。\n在 Windows 上可以调用 WaitForSingleObject 等待的常见对象如下表所示：\n\n\n\n可以被等待的对象\n等待对象成功的含义\n对象类型\n\n\n\n线程\n等待线程结束\nHANDLE\n\n\nProcess\n等待进程结束\nHANDLE\n\n\nEvent（事件）\n等待 Event 有信号\nHANDLE\n\n\nMutex (互斥体)\n等待持有 Mutex 的线程释放该 Mutex，等待成功，拥有该 Mutex\nHANDLE\n\n\nSemaphore（信号量）\n等待该 Semaphore 对象有信号\nHANDLE\n\n\n上面介绍的等待线程对象上文中已经详细介绍过了，这里不再重复了，等待进程退出与等待线程退出类似，也不再赘述。下文中我们将详细介绍 Event、Mutex、Semaphore 这三种类型的资源同步对象，这里我们先接着介绍 WaitForSingleObject 函数的用法，该函数的返回值一般有以下类型：\n\nWAIT_FAILED，表示 WaitForSingleObject 函数调用失败了，可以通过 GetLastError() 函数得到具体的错误码；\nWAIT_OBJECT_0，表示 WaitForSingleObject 成功“等待”到设置的对象；\nWAIT_TIMEOUT，等待超时；\nWAIT_ABANDONED，当等待的对象是 Mutex 类型时，如果持有该 Mutex 对象的线程已经结束，但是没有在结束前释放该 Mutex，此时该 Mutex 已经处于废弃状态，其行为是未知的，不建议再使用。\n\nWaitForSingleObject 如其名字一样，只能“等待”单个对象，如果需要同时等待多个对象可以使用 WaitForMultipleObjects，除了对象的数量变多了，其用法基本上和 WaitForSingleObject 一样。 WaitForMultipleObjects 函数签名如下：\nDWORD WaitForMultipleObjects(    DWORD        nCount,    const HANDLE *lpHandles,    BOOL         bWaitAll,    DWORD        dwMilliseconds);\n参数 lpHandles 是需要等待的对象数组指针，参数 nCount 指定了该数组的长度，参数 bWaitAll 表示是否等待数组 lpHandles 所有对象有“信号”，取值为 TRUE 时，WaitForMultipleObjects 会等待所有对象有信号才会返回，取值为 FALSE 时，当其中有一个对象有信号时，立即返回，此时其返回值表示哪个对象有信号。\n在参数 bWaitAll 设置为 FALSE 的情况下， 除了上面介绍的返回值是 WAITFAILED 和 WAITTIMEOUT 以外，返回值还有另外两种情形（分别对应 WaitForSingleObject 返回值是 WAIT_OBJECT_0 和 WAIT_ABANDONED 两种情形）：\n\nWAIT_OBJECT_0 to (WAIT_OBJECT_0 + nCount– 1)，举个例子，假设现在等待三个对象 A1、A2、A3，它们在数组 lpHandles 中的下标依次是 0、1、2，某次 WaitForMultipleObjects 返回值是 Wait_OBJECT_0 + 1，则表示对象 A2 有信号，导致 WaitForMultipleObjects 调用成功返回。\n\n伪码如下：\nHANDLE waitHandles[3];waitHandles[0] = hA1Handle;waitHandles[1] = hA2Handle;waitHandles[2] = hA3Handle;DWORD dwResult = WaitForMultipleObjects(3, waitHandles, FALSE, 3000);switch(dwResult){    case WAIT_OBJECT_0 + 0:        //A1 有信号        break;    case WAIT_OBJECT_0 + 1:        //A2 有信号        break;    case WAIT_OBJECT_0 + 2:        //A3 有信号        break;    default:        //出错或超时        break;}\n\nWAIT_ABANDONED_0 to (WAIT_ABANDONED_0 + nCount– 1)，这种情形与上面的使用方法相同，通过 nCount - 1 可以知道是等待对象数组中哪个对象始终没有被其他线程释放使用权。\n\n\n这里说了这么多理论知识，读者将在下文介绍的 Windows 常用的资源同步对象章节中看到具体的示例代码。\n\nWindows 的临界区对象在所有的 Windows 资源同步对象中，CriticalSection （临界区对象，有些书上翻译成“关键段”）是最简单易用的，从程序的术语来说，它防止多线程同时执行其保护的那段代码（临界区代码），即临界区代码某一时刻只允许一个线程去执行，示意图如下：\n\nWindows 没有公开 CriticalSection 数据结构的定义，我们一般使用如下五个 API 函数操作临界区对象：\nvoid InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);\nInitializeCriticalSection 和 DeleteCriticalSection 用于初始化和销毁一个 CRITICAL_SECTION 对象；位于EnterCriticalSection 和 LeaveCriticalSection 之间的代码即临界区代码；调用 EnterCriticalSection 的线程会尝试“进入“临界区，如果进入不了，则会阻塞调用线程，直到成功进入或者超时；TryEnterCriticalSection 会尝试进入临界区，如果可以进入，则函数返回 TRUE ，如果无法进入则立即返回不会阻塞调用线程，函数返回 FALSE。LeaveCriticalSection 函数让调用线程离开临界区，离开临界区以后，临界区的代码允许其他线程调用 EnterCriticalSection 进入。\n\nEnterCriticalSection 超时时间很长，可以在注册表 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager 这个位置修改参数 CriticalSectionTimeout 的值调整，当然实际开发中我们从来不会修改这个值，如果你的代码等待时间较长最终超时，请检查你的逻辑设计是否合理。\n\n我们来看一段实例代码：\n#include &lt;Windows.h&gt;#include &lt;list&gt;#include &lt;iostream&gt;#include &lt;string&gt; CRITICAL_SECTION       g_cs;int                    g_number = 0;DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter){    DWORD dwThreadID = GetCurrentThreadId();        while (true)    {        EnterCriticalSection(&amp;g_cs);          std::cout &lt;&lt; \"EnterCriticalSection, ThreadID: \" &lt;&lt; dwThreadID &lt;&lt; std::endl;        g_number++;        SYSTEMTIME st;        //获取当前系统时间        GetLocalTime(&amp;st);        char szMsg[64] = { 0 };        sprintf(szMsg,                 \"[%04d-%02d-%02d %02d:%02d:%02d:%03d]NO.%d, ThreadID: %d.\",                 st.wYear, st.wMonth, st.wDay,                   st.wHour, st.wMinute, st.wSecond, st.wMilliseconds,                 g_number, dwThreadID);        std::cout &lt;&lt; szMsg &lt;&lt; std::endl;        std::cout &lt;&lt; \"LeaveCriticalSection, ThreadID: \" &lt;&lt; dwThreadID &lt;&lt; std::endl;        LeaveCriticalSection(&amp;g_cs);        //睡眠1秒        Sleep(1000);    }    return 0;}int main(){    InitializeCriticalSection(&amp;g_cs);    HANDLE hWorkerThread1 = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    HANDLE hWorkerThread2 = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    WaitForSingleObject(hWorkerThread1, INFINITE);    WaitForSingleObject(hWorkerThread2, INFINITE);    //关闭线程句柄    CloseHandle(hWorkerThread1);    CloseHandle(hWorkerThread2);    DeleteCriticalSection(&amp;g_cs);    return 0;}\n上述程序执行输出结果如下：\nEnterCriticalSection, ThreadID: 1224[2019-01-19 22:25:41:031]NO.1, ThreadID: 1224.LeaveCriticalSection, ThreadID: 1224EnterCriticalSection, ThreadID: 6588[2019-01-19 22:25:41:031]NO.2, ThreadID: 6588.LeaveCriticalSection, ThreadID: 6588EnterCriticalSection, ThreadID: 6588[2019-01-19 22:25:42:031]NO.3, ThreadID: 6588.LeaveCriticalSection, ThreadID: 6588EnterCriticalSection, ThreadID: 1224[2019-01-19 22:25:42:031]NO.4, ThreadID: 1224.LeaveCriticalSection, ThreadID: 1224EnterCriticalSection, ThreadID: 1224[2019-01-19 22:25:43:031]NO.5, ThreadID: 1224.LeaveCriticalSection, ThreadID: 1224EnterCriticalSection, ThreadID: 6588[2019-01-19 22:25:43:031]NO.6, ThreadID: 6588.LeaveCriticalSection, ThreadID: 6588EnterCriticalSection, ThreadID: 1224[2019-01-19 22:25:44:031]NO.7, ThreadID: 1224.LeaveCriticalSection, ThreadID: 1224EnterCriticalSection, ThreadID: 6588[2019-01-19 22:25:44:031]NO.8, ThreadID: 6588.LeaveCriticalSection, ThreadID: 6588\n在上述代码中我们新建两个工作线程，线程函数都是 WorkerThreadProc。线程函数在 15 行调用 EnterCriticalSection 进入临界区，在 30 行调用 LeaveCriticalSection 离开临界区，16 ～ 29 行之间的代码即临界区的代码，这段代码由于受到临界区对象 g_cs 的保护，因为每次只允许一个工作线程执行这段代码。虽然临界区代码中有多个输出，但是这些输出一定都是连续的，不会出现交叉输出的结果。\n细心的读者会发现上述输出中存在同一个的线程连续两次进入临界区，这是有可能的。也就是说，当其中一个线程离开临界区，即使此时有其他线程在这个临界区外面等待，由于线程调度的不确定性，此时正在等待的线程也不会有先进入临界区的优势，它和刚离开这个临界区的线程再次竞争进入临界区是机会均等的。我们来看一张图：\n\n上图中我们将线程函数的执行流程绘制成一个流程图，两个线程竞争进入临界区可能存在如下情形，为了表述方便，将线程称为 A、B。\n\n情形一：线程 A 被唤醒获得 CPU 时间片进入临界区，执行流程 ①，然后执行临界区代码输出 → 线程 B 获得 CPU 时间片，执行流程 ②，然后失去 CPU 时间片进入休眠 → 线程 A 执行完临界区代码离开临界区后执行流程 ⑤，然后失去 CPU 时间片进入休眠 → 线程 B 被唤醒获得 CPU 时间片执行流程 ③、①，然后执行临界区代码输出。\n这种情形下，线程 A 和线程 B 会轮流进入临界区执行代码。\n\n情形二：线程 A 被唤醒获得 CPU 时间片进入临界区，执行流程 ①，然后执行临界区代码输出 → 线程 B 获得 CPU 时间片，执行流程 ③，然后执行流程 ② 在临界区外面失去 CPU 时间片进入休眠 → 线程 A 执行完临界区代码离开临界区后执行流程 ④、① 。\n这种情形下，会出现某个线程连续两次甚至更多次的进入临界区执行代码。\n\n\n如果某个线程在尝试进入临界区时因无法阻塞而进入睡眠状态，当其他线程离开这个临界区后，之前因为这个临界区而阻塞的线程可能会被唤醒进行再次竞争，也可能不被唤醒。但是存在这样一种特例，假设现在存在两个线程 A 和 B，线程 A 离开临界区的线程再也不需要再次进入临界区，那么线程 B 在被唤醒时一定可以进入临界区。线程 B 从睡眠状态被唤醒，这涉及到一次线程的切换，有时候这种开销是不必要的，我们可以让 B 简单地执行一个循环等待一段时间后去进去临界区，而不是先睡眠再唤醒，与后者相比，执行这个循环的消耗更小。这就是所谓的“自旋”，在这种情形下，Windows 提供了另外一个初始化临界区的函数 InitializeCriticalSectionAndSpinCount，这个函数比 InitializeCriticalSection 多一个自旋的次数：\nBOOL InitializeCriticalSectionAndSpinCount(      LPCRITICAL_SECTION lpCriticalSection,      DWORD              dwSpinCount);\n参数 dwSpinCount 是自旋的次数，利用自旋来代替让 CPU 进入睡眠和再次被唤醒，消除线程上下文切换带来的消耗，提高效率。当然，在实际开发中这种方式是靠不住的，线程调度是操作系统内核的策略，应用层上的应用不应该假设线程的调度策略是按预想的来执行。但是理解线程与临界区之间的原理有利于编写出更高效的应用来。\n需要说明的是，临界区对象通过保护一段代码不被多个线程同时执行，进而来保证多个线程之间读写一个对象是安全的。由于同一时刻只有一个线程可以进入临界区，因此这种对资源的操作是排他的，即对于同一个临界区对象，不会出现多个线程同时操作该资源，哪怕是资源本身可以在同一时刻被多个线程进行操作，如多个线程对资源进行读操作，这就带来了效率问题。\n我们一般将进入临界区的线程称为该临界区的拥有者（owner）——临界区持有者。\n最后，为了避免死锁，EnterCriticalSection 和 LeaveCriticalSection 需要成对使用，尤其是在具有多个出口的函数中，记得在每个分支处加上 LeaveCriticalSection。伪码如下：\nvoid someFunction(){    EnterCriticalSection(&amp;someCriticalSection);    if (条件A)    {        if (条件B)        {            LeaveCriticalSection(&amp;someCriticalSection);            //出口1            return;        }        LeaveCriticalSection(&amp;someCriticalSection);        //出口2        return;    }    if (条件C)    {        LeaveCriticalSection(&amp;someCriticalSection);        // 出口3        return;    }    if (条件C)    {        LeaveCriticalSection(&amp;someCriticalSection);        // 出口4        return;    }}\n上述代码中，为了能让临界区对象被正常的释放，在函数的每个出口都加上了 LeaveCriticalSection 调用，如果函数的出口非常多，这样的代码太难维护了。因此一般建议使用 RAII 技术将临界区 API 封装成对象，该对象在函其作用域内进入临界区，在出了其作用域后自动离开临界区，示例代码如下：\nclass CCriticalSection{public:    CCriticalSection(CRITICAL_SECTION&amp; cs) : mCS(cs)    {        EnterCriticalSection(&amp;mCS);    }    ~CCriticalSection()    {        LeaveCriticalSection(&amp;mCS);    }private:    CRITICAL_SECTION&amp; mCS;};\n利用 CCriticalSection 类，我们可以对上述伪码进行优化：\nvoid someFunction(){    CCriticalSection autoCS(someCriticalSection);    if (条件A)    {        if (条件B)        {             //出口1            return;        }        //出口2        return;    }    if (条件C)    {              // 出口3        return;    }    if (条件C)    {                // 出口4        return;    }}\n上述代码中由于变量 autoCS 会在出了函数作用域后调用其析构函数，在析构函数中调用 LeaveCriticalSection 自动离开临界区。\n总结本讲介绍了 WaitForSingleObject 和 WaitForMultipleObjects 这两个重要的 Windows API 函数，同时介绍了 Windows 上第一个线程同步对象——临界区，为了避免因函数有多个出口造成的编码疏漏，我们介绍了使用 RAII 封装临界区对象的方法。临界区对象是 Windows 系统多线程资源同步最常用的对象之一。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"线程函数传 C++ 类实例指针惯用法","url":"/2021/10/18/CPP-multithreaded-3/","content":"音乐小港\n    \n\n\n线程函数传 C++ 类实例指针惯用法前面的内容介绍了除了 C++ 11 的线程库提供了的 std::thread 类对线程函数签名没有特殊要求外，无论是 Linux 还是 Windows 的线程函数的签名都必须是指定的格式，即参数和返回值必须是规定的形式。如果使用 C++ 面向对象的方式对线程函数进行封装，那么线程函数就不能是类的实例方法，即必须是类的静态方法。那么，为什么不能是类的实例方法呢？我们以 Linux 的线程函数签名为例：\nvoid threadFunc(void* arg);\n假设，将线程的基本功能封装到一个 Thread 类中，部分代码如下：\nclass Thread{public:    Thread();    ~Thread();    void start();    void stop();    void* threadFunc(void* arg);};\n由于 threadFunc 是一个类实例方法，无论是类的实例方法还是静态方法，C++ 编译器在编译时都会将这些函数“翻译”成全局函数，即去掉类的域限制。对于实例方法，为了保证类方法的正常功能，C++ 编译器在翻译时，会将类的实例对象地址（也就是 this 指针）作为第一个参数传递给该方法，也就是说，翻译后的 threadFunc 的签名变成了如下形式（伪代码）：\nvoid* threadFunc(Thread* this, void* arg);\n这样的话，就不符合线程函数签名要求了。因此如果一个线程函数作为类方法，只能是静态方法而不能是实例方法。\n当然，如果是使用 C++ 11 的 std::thread 类就没有这个限制，即使类成员函数是类的实例方法也可以，但是必须显式地将线程函数所属的类对象实例指针（在类的内部就是 this 指针）作为构造函数参数传递给 std::thread，还是需要传递类的 this 指针，这在本质上是一样的，代码实例如下：\n#include &lt;thread&gt;#include &lt;memory&gt;#include &lt;stdio.h&gt;class Thread{public:    Thread()    {    }    ~Thread()    {    }    void Start()    {        m_stopped = false;        //threadFunc 是类的非静态方法，因此作为线程函数，第一个参数必须传递类实例地址，即 this 指针        m_spThread.reset(new std::thread(&amp;Thread::threadFunc, this, 8888, 9999));    }    void Stop()    {        m_stopped = true;        if (m_spThread)        {            if (m_spThread-&gt;joinable())                m_spThread-&gt;join();        }    }private:    void threadFunc(int arg1, int arg2)    {        while (!m_stopped)        {            printf(\"Thread function use instance method.\\n\");        }          }private:    std::shared_ptr&lt;std::thread&gt;  m_spThread;    bool                          m_stopped;};int main(){    Thread mythread;    mythread.Start();    while (true)    {        //权宜之计，让主线程不要提前退出    }    return 0;}\n上述代码中使用了 C++ 11 新增的智能指针 std::shared_ptr 类来包裹了一下 new 出来的 std::thread 对象，这样我们就不需要自己手动 delete 这个 std::thread 对象了。\n综上所述，如果不使用 C++ 11 的语法，那么线程函数只能作为类的静态方法，且函数签名必须按规定的签名格式来。如果是类的静态方法，那么就没法访问类的实例方法了，为了解决这个问题，在实际开发中往往会在创建线程时将当前对象的地址（this 指针）传递给线程函数，然后在线程函数中，将该指针转换成原来的类实例，再通过这个实例就可以访问类的所有方法了。代码示例如下：\n.h 文件代码如下：\n/** * Thread.h */#ifdef WIN32//#include &lt;windows.h&gt;typedef HANDLE THREAD_HANDLE ;#else//#include &lt;pthread.h&gt;typedef pthread_t THREAD_HANDLE ;#endif/**定义了一个线程对象*/class  CThread  {public:    /**构造函数    */    CThread();    /**析构函数    */    virtual ~CThread();    /**创建一个线程    * @return true:创建成功 false:创建失败    */    virtual bool Create();    /**获得本线程对象存储的线程句柄    * @return 本线程对象存储的线程句柄线程句柄    */    THREAD_HANDLE GetHandle();    /**线程睡眠 seconds 秒    * @param seconds 睡眠秒数    */    void OSSleep(int nSeconds);    void SleepMs(int nMilliseconds);    bool Join();    bool IsCurrentThread();    void ExitThread();private:    #ifdef WIN32    static DWORD WINAPI _ThreadEntry(LPVOID pParam);#else    static void* _ThreadEntry(void* pParam);#endif    /**虚函数，子类可做一些实例化工作    * @return true:创建成功 false:创建失败    */    virtual bool InitInstance();    /**虚函数，子类清楚实例    */    virtual void ExitInstance();    /**线程开始运行，纯虚函数，子类必须继承实现    */    virtual void Run() = 0;private:     THREAD_HANDLE  m_hThread;  /**&lt; 线程句柄 */     DWORD          m_IDThread;};\n.cpp 文件如下：\n/** * Thread.cpp */#include \"Thread.h\"#ifdef WIN32DWORD WINAPI CThread::_ThreadEntry(LPVOID pParam)#elsevoid* CThread::_ThreadEntry(void* pParam)#endif{    CThread *pThread = (CThread *)pParam;    if(pThread-&gt;InitInstance())    {        pThread-&gt;Run();    }    pThread-&gt;ExitInstance();    return NULL;}CThread::CThread(){    m_hThread = (THREAD_HANDLE)0;    m_IDThread = 0;}CThread::~CThread(){}bool CThread::Create(){    if (m_hThread != (THREAD_HANDLE)0)    {        return true;    }    bool ret = true;#ifdef WIN32    m_hThread = ::CreateThread(NULL,0,_ThreadEntry,this,0,&amp;m_IDThread);    if(m_hThread==NULL)    {        ret = false;    }#else    ret = (::pthread_create(&amp;m_hThread,NULL,&amp;_ThreadEntry , this) == 0);#endif    return ret;}bool CThread::InitInstance(){    return true;}void CThread::ExitInstance(){}void CThread::OSSleep(int seconds){#ifdef WIN32    ::Sleep(seconds*1000);#else    ::sleep(seconds);#endif}void CThread::SleepMs(int nMilliseconds){#ifdef WIN32    ::Sleep(nMilliseconds);#else    ::usleep(nMilliseconds);#endif}bool CThread::IsCurrentThread(){#ifdef WIN32    return ::GetCurrentThreadId() == m_IDThread;#else    return ::pthread_self() == m_hThread;#endif}bool CThread::Join(){        THREAD_HANDLE hThread = GetHandle();    if(hThread == (THREAD_HANDLE)0)    {        return true;    }#ifdef WIN32    return (WaitForSingleObject(hThread,INFINITE) != 0);#else    return (pthread_join(hThread, NULL) == 0);#endif}void CThread::ExitThread(){#ifdef WIN32    ::ExitThread(0);#else#endif}\n上述代码 CThread 类封装了一个线程的常用的操作，使用宏 WIN32 来分别实现了 Windows 和 Linux 两个操作系统平台的线程操作。其中 InitInstance 和 ExitInstance 方法为虚函数，在继承 CThread 的子类中可以改写这两个方法，根据实际需要在线程函数正式业务逻辑前后做一些初始化和反初始化工作，而纯虚接口 Run 方法必须改写，改写成您的线程实际执行函数。\n在线程函数中通过在创建线程时（调用 CreateThread 或 pthread_create 方法）时，将当前对象的 this 指针作为线程的函数的唯一参数传入，这样在线程函数中，可以通过线程函数参数得到对象的指针，通过这个指针就可以自由访问类的实例方法了。这一技巧非常常用，它广泛地用于各类开源 C++ 项目或者实际的商业 C++ 项目中，希望读者能理解并熟练掌握它。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Windows 线程资源同步之 Event","url":"/2021/10/18/CPP-multithreaded-6/","content":"音乐小港\n    \n\n\nWindows 线程资源同步之 Event前面一讲我们介绍了 WaitForSingleObject 和 WaitForMultipleObjects 函数，它们是 Windows 多线程编程基础 API，所有资源同步对象都得和它们打交道；然后介绍了可以临界区对象，并且介绍了一个把临界区当自旋锁的扩展用法。本讲我们来介绍 Windows 最常用的多线程同步对象 —— Event。\nEvent 使用方法本节讨论的 Event 对象不是 Windows UI 事件驱动机制中的事件，而是多线程资源同步中的 Event 对象，它也是 Windows 内核对象之一。在 Windows 多线程程序设计中，使用频率较高，我们先来学习一下如何创建 Event 对象，然后逐步展开。创建 Event 的 Windows API 函数签名是：\nHANDLE CreateEvent(  LPSECURITY_ATTRIBUTES lpEventAttributes,  BOOL                  bManualReset,  BOOL                  bInitialState,  LPCTSTR               lpName);\n参数和返回值的说明如下。\n\n参数 lpEventAttributes，这个参数设置了 Event 对象的安全属性，Windows 中所有的内核对象都可以设置这个属性，我们一般设置为 NULL，即使用默认安全属性。\n参数 bManualReset，这个参数设置 Event 对象受信（变成有信号状态）时的行为，当设置为 TRUE 时，表示需要手动调用 ResetEvent 函数去将 Event 重置成无信号状态；当设置为 FALSE，Event 事件对象受信后会自动重置为无信号状态。\n参数 bInitialState 设置 Event 事件对象初始状态是否是受信的，TRUE 表示有信号，FALSE 表示无信号。\n参数 lpName 可以设置 Event 对象的名称，如果不需要设置名称，可以将该参数设置为 NULL。一个 Event 对象根据是否设置了名称分为具名对象（具有名称的对象）和匿名对象。Event 对象是可以通过名称在不同进程之间共享的，通过这种方式共享很有用，后面我们会详细介绍。\n返回值，如果成功创建 Event 对象返回对象的句柄，如果创建失败返回 NULL。\n\n一个无信号的 Event 对象，我们可以通过 SetEvent 将其变成受信状态，SetEvent 的函数签名如下：\nBOOL SetEvent(HANDLE hEvent);\n我们将参数 hEvent 设置为需要设置信号的 Event 句柄即可。\n同理，一个已经受信的 Event 对象，可以使用 ResetEvent 对象将其变成无信号状态，ResetEvent 的函数签名如下：\nBOOL ResetEvent(HANDLE hEvent);\n参数 hEvent 即我们需要重置的 Event 对象句柄。\n说了这么多，来看一个具体的例子。假设现在有两个线程，其中一个是主线程，主线程等待工作线程执行某一项耗时的任务完成后，将任务结果显示出来。代码如下：\n#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;bool        g_bTaskCompleted = false;std::string g_TaskResult;DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter){    //使用 Sleep 函数模拟一个很耗时的操作    //睡眠3秒    Sleep(3000);    g_TaskResult = \"task completed\";    g_bTaskCompleted = true;    return 0;}int main(){    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);     while (true)    {        if (g_bTaskCompleted)        {            std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;            break;        }                else            std::cout &lt;&lt; \"Task is in progress...\" &lt;&lt; std::endl;    }    CloseHandle(hWorkerThread);    return 0;}\n上述代码在主线程（main 函数）创建一个工作线程，然后主线程进入一个无限循环等待布尔变量 gbTaskCompleted 变成真值；工作线程（WorkerThreadProc 为线程函数）休眠 3 秒后将变量 gbTaskCompleted 设置为真后主线程得以退出循环，并打印代表条件满足后的结果。\n程序执行结果如下图所示：\n\n在上述代码中，主线程为了等待工作线程完成任务后获取结果，使用了一个循环去不断查询任务完成标识，这是很低效的一种做法，等待的线程（主线程）做了很多无用功，对 CPU 时间片也是一种浪费。我们使用 Event 对象来改写一下上述代码：\n#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;bool        g_bTaskCompleted = false;std::string g_TaskResult;HANDLE      g_hTaskEvent = NULL;DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter){    //使用 Sleep 函数模拟一个很耗时的操作    //睡眠3秒    Sleep(3000);    g_TaskResult = \"task completed\";    g_bTaskCompleted = true;    //设置事件信号    SetEvent(g_hTaskEvent);    return 0;}int main(){    //创建一个匿名的手动重置初始无信号的事件对象    g_hTaskEvent = CreateEvent(NULL, TRUE, FALSE, NULL);    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);         DWORD dwResult = WaitForSingleObject(g_hTaskEvent, INFINITE);    if (dwResult == WAIT_OBJECT_0)    {        std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;    }        CloseHandle(hWorkerThread);    CloseHandle(g_hTaskEvent);    return 0;}\n在上述代码中，主线程在工作线程完成任务之前会一直阻塞代码 29 行，没有任何消耗，当工作线程完成任务后调用 SetEvent 让事件对象受信，这样主线程会立即得到通知，从 WaitForSingleObject 返回，此时任务已经完成，就可以得到任务结果了。\n在实际的开发中，可以利等待的时间去做一点其他的事情，在我们需要的时候去检测一下事件对象是否有信号即可。另外，Event 对象有两个显著的特点：\n\n与临界区对象（以及接下来要介绍的 Mutex 对象）相比，Event 对象没有被谁持让持有者线程变成其 owner 这一说法，因此 Event 对象可以同时唤醒多个等待的工作线程。\n手动重置的 Event 对象一旦变成受信状态，其信号不会丢失，也就是说当 Event 从无信号变成有信号时，即使某个线程当时没有调用 WaitForSingleObject 等待该 Event 对象受信，而是在这之后才调用 WaitForSingleObject ，仍然能检测到事件的受信状态，即不会丢失信号，而后面要介绍的条件变量就可能会丢失信号。Event 使用示例蘑菇街开源的即时通讯 Teamtalk pc 版（代码下载地址请点击这里）在使用 socket 连接服务器时，使用 Event 对象设计了一个超时做法。传统的做法是将 socket 设置为非阻塞的，调用完 connect 函数之后，调用 select 函数检测 socket 是否可写，在 select 函数里面设置超时时间。Teamtalk 的做法如下： //TcpClientModule_Impl.cpp 145行 IM::Login::IMLoginRes* TcpClientModule_Impl::doLogin(CString &amp;linkaddr, UInt16 port    ,CString&amp; uName,std::string&amp; pass){    //imcore::IMLibCoreConnect 中通过 connect 连接服务器    m_socketHandle = imcore::IMLibCoreConnect(util::cStringToString(linkaddr), port);    imcore::IMLibCoreRegisterCallback(m_socketHandle, this);    if(util::waitSingleObject(m_eventConnected, 5000))    {        IM::Login::IMLoginReq imLoginReq;        string&amp; name = util::cStringToString(uName);        imLoginReq.set_user_name(name);        imLoginReq.set_password(pass);        imLoginReq.set_online_status(IM::BaseDefine::USER_STATUS_ONLINE);        imLoginReq.set_client_type(IM::BaseDefine::CLIENT_TYPE_WINDOWS);        imLoginReq.set_client_version(\"win_10086\");        if (TCPCLIENT_STATE_OK != m_tcpClientState)            return 0;        sendPacket(IM::BaseDefine::SID_LOGIN, IM::BaseDefine::CID_LOGIN_REQ_USERLOGIN, ++g_seqNum            , &amp;imLoginReq);        m_pImLoginResp-&gt;Clear();        util::waitSingleObject(m_eventReceived, 10000);    }    return m_pImLoginResp;}\nutil::waitSingleObject 即封装 API WaitForSingleObject 函数：//utilCommonAPI.cpp 197行BOOL waitSingleObject(HANDLE handle, Int32 timeout){    int t = 0;    DWORD waitResult = WAIT_FAILED;    do    {        int timeWaiter = 500;        t += timeWaiter;        waitResult = WaitForSingleObject(handle, timeWaiter);    } while ((WAIT_TIMEOUT == waitResult) &amp;&amp; (t &lt; timeout));    return (WAIT_OBJECT_0 == waitResult);}\n等待的 m_eventConnected 对象即是一个 Event 类型：//定义HANDLE                            m_eventConnected;//在 TcpClientModule_Impl 构造函数中初始化//m_eventConnected = CreateEvent(NULL, FALSE, FALSE, NULL);\n这个 WaitForSingleObejct 何时会返回呢？如果网络线程中 connect 函数可以正常连接服务器，会让 m_eventConnected 受信，这样 WaitForSingleObejct 函数就会返回了，接着组装登录数据包接着发数据。void TcpClientModule_Impl::onConnectDone(){    m_tcpClientState = TCPCLIENT_STATE_OK;    ::SetEvent(m_eventConnected);    m_bDoReloginServerNow = FALSE;    if (!m_pServerPingTimer)    {        _startServerPingTimer();    }}\n归纳起来，这里利用了一个 Event 对象实现了一个同步登录的过程，网络连接最大超时事件设置成了 5000 毫秒（5 秒）：util::waitSingleObject(m_eventConnected, 5000)\n总结Event 对象是 Windows 多线程最常用的同步对象之一，其特点是简单易用，如果多个线程都是等待一个 Event 对象受信，无法精确控制唤醒指定数量的线程，后面我们用信号量来解决该问题。\n\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Windows 线程同步之 Mutex","url":"/2021/10/18/CPP-multithreaded-7/","content":"音乐小港\n    \n\n\nWindows 线程同步之 MutexMutex（ 互斥量）采用的是英文 Mutual Exclusive（互相排斥之意）的缩写。见名知义，Windows 中的 Mutex 对象在同一个时刻最多只能属于一个线程，当然也可以不属于任何线程，获得 Mutex 对象的线程成为该 Mutex 的拥有者（owner）。我们可以在创建 Mutex 对象时设置 Mutex 是否属于创建它的线程，其他线程如果希望获得该 Mutex，则可以调用 WaitForSingleObject 进行申请。创建 Mutex 的 API 是 CreateMutex，其函数签名如下：\nHANDLE CreateMutex(      LPSECURITY_ATTRIBUTES lpMutexAttributes,      BOOL                  bInitialOwner,      LPCTSTR               lpName);\n参数和返回值说明：\n\n参数 lpMutexAttributes 用法同 CreateEvent，上面已经介绍过了，一般设置为 NULL；\n参数 bInitialOwner，设置调用 CreateMutex 的线程是否立即拥有该 Mutex 对象，TRUE 拥有，FALSE 不拥有，不拥有时，其他线程调用 WaitForSingleObject 可以获得该 Mutex 对象；\n参数 lpName，Mutex 对象的名称，Mutex 对象和 Event 对象一样，也可以通过名称在多个线程之间共享，如果不需要名称则可以将该参数设置为 NULL，根据是否具有名称 Mutex 对象分为具名 Mutex 和匿名 Mutex；\n返回值，如果函数调用成功返回 Mutex 的句柄，调用失败返回 NULL。\n\n当一个线程不再需要该 Mutex，可以使用 ReleaseMutex 函数释放 Mutex，让其他需要等待该 Mutex 的线程有机会获得该 Mutex，ReleaseMutex 的函数签名如下：\nBOOL ReleaseMutex(HANDLE hMutex);\n参数 hMutex 即需要释放所有权的 Mutex 对象句柄。\n我们来看一段具体的实例代码：\n#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;HANDLE      g_hMutex = NULL;int         g_iResource = 0;DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter){    DWORD dwThreadID = GetCurrentThreadId();    while (true)    {        if (WaitForSingleObject(g_hMutex, 1000) == WAIT_OBJECT_0)        {            g_iResource++;            std::cout &lt;&lt; \"Thread: \" &lt;&lt; dwThreadID &lt;&lt; \" becomes mutex owner, ResourceNo: \" &lt;&lt; g_iResource  &lt;&lt; std::endl;            ReleaseMutex(g_hMutex);        }        Sleep(1000);    }    return 0;}int main(){    //创建一个匿名的 Mutex 对象，默认情况下主线程不拥有该 Mutex    g_hMutex = CreateMutex(NULL, FALSE, NULL);    HANDLE hWorkerThreads[5];     for (int i = 0; i &lt; 5; ++i)    {        hWorkerThreads[i] = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);    }    for (int i = 0; i &lt; 5; ++i)    {        //等待工作线程退出        WaitForSingleObject(hWorkerThreads[i], INFINITE);        CloseHandle(hWorkerThreads[i]);    }    CloseHandle(g_hMutex);    return 0;}\n在上述代码中，主线程创建一个 Mutex，并且设置不拥有它，然后五个工作线程去竞争获得这个 Mutex 的使用权，拿到这个 Mutex 之后就可以操作共享资源 g_iResource 了，程序的执行效果是五个工作线程随机获得该资源的使用权：\n\n互斥体对象的排他性，有点类似于公共汽车上的座位，如果一个座位已经被别人占用，其他人需要等待，如果该座位没人坐，则其他人“先到先得”。当你不需要使用的时候，要把座位腾出来让其他有需要的人使用。假设某个线程在退出后，仍然没有释放其持有的 Mutex 对象，这时候使用 WaitForSingleObject 等待该 Mutex 对象的线程，也会立即返回，返回值是 WAIT_ABANDONED，表示该 Mutex 处于废弃状态（abandoned），处于废弃状态的 Mutex 不能再使用，其行为是未定义的。\n通过上面的分析，我们知道 Windows Mutex 对象存在一个 owner 的概念，即哪个线程获取了该 Mutex 即成为该线程的 owner，事实上 Mutex 对象有一个内部属性记录了 owner，只不过微软没有公开而已。如果对 Mutex 内部实现原理感兴趣，可以阅读“开源版的 Windows” 的源码——ReactOS，其主页如下：https://reactos.org/。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"如何让程序只能启动一个实例","url":"/2021/10/18/CPP-multithreaded-9/","content":"音乐小港\n    \n\n\n如何让程序只能启动一个实例前面介绍的 Windows Event、Mutex、Semaphore 对象其创建函数 CreateX 都可以给这些对象指定一个名字，有了名字之后这些线程资源同步对象就可以通过这个名字在不同进程之间共享。\n在 Windows 系统上读者应该有这样的体验：有些程序无论双击其启动图标都只会启动一个，我们把这类程序叫做单实例程序（Single Instance）。可以利用命名的线程资源同步对象来实现这个效果，这里以互斥体为例。\n示例代码如下：\nint APIENTRY _tWinMain(_In_ HINSTANCE hInstance,                     _In_opt_ HINSTANCE hPrevInstance,                     _In_ LPTSTR    lpCmdLine,                     _In_ int       nCmdShow){    //...省略无关代码...    if (CheckInstance())    {        HWND hwndPre = FindWindow(szWindowClass, NULL);        if (IsWindow(hwndPre))        {            if (::IsIconic(hwndPre))                ::SendMessage(hwndPre, WM_SYSCOMMAND, SC_RESTORE | HTCAPTION, 0);            ::SetWindowPos(hwndPre, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);            ::SetForegroundWindow(hwndPre);            ::SetFocus(hwndPre);            return 0;        }    }    //...省略无关代码}\n上述代码在 WinMain 函数开始处先检查是否已经运行起来的程序实例，如果存在，则找到运行中的实例程序主窗口并激活之，这就是读者看到最小化很多单例程序后双击该程序图标会重新激活最小化的程序的效果实现原理。\n现在重点是 CheckInstance() 函数的实现：\nbool CheckInstance(){    HANDLE hSingleInstanceMutex = CreateMutex(NULL, FALSE, _T(\"MySingleInstanceApp\"));    if (hSingleInstanceMutex != NULL)    {        if (GetLastError() == ERROR_ALREADY_EXISTS)        {            return true;        }    }    return false;}\n我们来分析一下上述 CheckInstance 函数：\n假设首次启动这个进程，这个进程会调用 CreateMutex 函数创建一个名称为“MySingleInstanceApp”的互斥体对象。当再次准备启动一份这个进程时，再次调用 CreateMutex 函数，由于该名称的互斥体对象已经存在，将会返回已经存在的互斥体对象地址，此时通过 GetLastError() 函数得到的错误码是 ERROR_ALREADY_EXISTS 表示该名称的互斥体对象已经存在，此时我们激活已经存在的前一个实例，然后退出当前进程即可。\n完整的代码下载地址请单击这里。\n总结在 Windows 上有太多的应用场景只允许程序启动一个示例，而其原理就是本节所介绍的，希望读者可以理解并掌握该方法。如何保证程序只会启动一个实例是 Windows 开发最常用的应用场景之一，建议读者自己练习一下，尽量掌握。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Windows 线程同步之 Semaphore","url":"/2021/10/18/CPP-multithreaded-8/","content":"音乐小港\n    \n\n\nWindows 线程同步之 SemaphoreSemaphore 也是 Windows 多线程同步常用的对象之一，与上面介绍的 Event、Mutex 不同，信号量存在一个资源计数的概念，Event 对象虽然可以同时唤醒多个线程，但是它不能精确地控制同时唤醒指定数目的线程，而 Semaphore 可以。创建 Semaphore 对象的 API 函数签名如下：\nHANDLE CreateSemaphore(      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,      LONG                  lInitialCount,      LONG                  lMaximumCount,      LPCTSTR               lpName);\n参数和返回值介绍：\n\n参数 lpSemaphoreAttributes 指定了 Semaphore 对象的安全属性，一般设置为 NULL 使用默认安全属性；\n参数 lInitialCount 指定初始可用资源数量，假设初始资源数量为 2，如果有 5 个线程正在调用 WaitForSingleObject 函数等待该信号量，则有 2 个线程会被唤醒，每调用一次 WaitForSingleObject 获得 Semaphore 对象，该对象的资源计数会减少一个。\n参数 lMaximumCount 最大资源数量上限，如果使用 ReleaseSemaphore 不断增加资源计数，资源数量最大不能超过这个值，这个值必须设置大于 0。\n参数 lpName 指定 Semaphore 对象的名称，Semaphore 对象也是可以通过名称跨进程共享的，如果不需要设置名称可以将该参数设置为 NULL，设置了名称的 Semaphore 对象被称为具名信号量，反之叫匿名信号量。\n返回值：函数调用成功返回 Semaphore 对象的句柄，反之返回 NULL。如果需要增加信号量的资源计数个数，可以使用 ReleaseSemaphore 函数，其签名如下：BOOL ReleaseSemaphore(      HANDLE hSemaphore,      LONG   lReleaseCount,      LPLONG lpPreviousCount);\n参数 hSemaphore 是需要操作的信号量句柄；\n参数 lReleaseCount，需要增加的资源数量；\n参数 lpPreviousCount 是一个 long 型（32 位系统上 4 个字节）的指针，函数执行成功后，返回是上一次资源的数量，如果用不到该参数，可以设置为 NULL。\n\n信号量的使用方式类似，根据当前资源的数量按需分配资源消费者，资源消费者会让资源数量减少，如果资源数量减少为 0，消费者将全部处于挂起状态；当有新的资源来到时，消费者将继续被唤醒进行处理。\n假设现在有一个即时通讯的程序，网络线程不断从网络上收到一条条聊天消息，其他 4 个消息处理线程需要对收到的聊天信息进行加工。由于我们需要根据当前消息的数量来唤醒其中 4 个工作线程中的一个或多个，这正是信号量使用的典型案例，代码如下：\n#include &lt;Windows.h&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;time.h&gt;HANDLE                  g_hMsgSemaphore = NULL;std::list&lt;std::string&gt;  g_listChatMsg;//保护 g_listChatMsg 的临界区对象CRITICAL_SECTION        g_csMsg;DWORD __stdcall NetThreadProc(LPVOID lpThreadParameter){    int nMsgIndex = 0;    while (true)    {        EnterCriticalSection(&amp;g_csMsg);        //随机产生1～4条消息        int count = rand() % 4 + 1;        for (int i = 0; i &lt; count; ++i)        {            nMsgIndex++;            SYSTEMTIME st;            GetLocalTime(&amp;st);            char szChatMsg[64] = { 0 };            sprintf_s(szChatMsg, 64, \"[%04d-%02d-%02d %02d:%02d:%02d:%03d] A new msg, NO.%d.\",                st.wYear,                st.wMonth,                st.wDay,                st.wHour,                st.wMinute,                st.wSecond,                st.wMilliseconds,                nMsgIndex);            g_listChatMsg.emplace_back(szChatMsg);        }           LeaveCriticalSection(&amp;g_csMsg);        //增加 count 个资源数量        ReleaseSemaphore(g_hMsgSemaphore, count, NULL);    }// end while-loop    return 0;}DWORD __stdcall ParseThreadProc(LPVOID lpThreadParameter){    DWORD dwThreadID = GetCurrentThreadId();    std::string current;    while (true)    {        if (WaitForSingleObject(g_hMsgSemaphore, INFINITE) == WAIT_OBJECT_0)        {            EnterCriticalSection(&amp;g_csMsg);            if (!g_listChatMsg.empty())            {                current = g_listChatMsg.front();                g_listChatMsg.pop_front();                std::cout &lt;&lt; \"Thread: \" &lt;&lt; dwThreadID &lt;&lt; \" parse msg: \" &lt;&lt; current &lt;&lt; std::endl;            }                     LeaveCriticalSection(&amp;g_csMsg);        }    }    return 0;}int main(){    //初始化随机数种子    srand(time(NULL));    InitializeCriticalSection(&amp;g_csMsg);    //创建一个匿名的 Semaphore 对象，初始资源数量为 0    g_hMsgSemaphore = CreateSemaphore(NULL, 0, INT_MAX, NULL);    HANDLE hNetThread = CreateThread(NULL, 0, NetThreadProc, NULL, 0, NULL);    HANDLE hWorkerThreads[4];    for (int i = 0; i &lt; 4; ++i)    {        hWorkerThreads[i] = CreateThread(NULL, 0, ParseThreadProc, NULL, 0, NULL);    }    for (int i = 0; i &lt; 4; ++i)    {        //等待工作线程退出        WaitForSingleObject(hWorkerThreads[i], INFINITE);        CloseHandle(hWorkerThreads[i]);    }    WaitForSingleObject(hNetThread, INFINITE);    CloseHandle(hNetThread);    CloseHandle(g_hMsgSemaphore);    DeleteCriticalSection(&amp;g_csMsg);    return 0;}\n在上述代码中，网络线程每次随机产生 1 ～ 4 个聊天消息放入消息容器 g_listChatMsg 中，然后根据当前新产生的消息数目调用 ReleaseSemaphore 增加相应的资源计数，这样就有相应的处理线程被唤醒，从容器 g_listChatMsg 中取出消息进行处理。\n\n注意：由于会涉及到多个线程操作消息容器 g_listChatMsg，这里使用了一个临界区对象 g_csMsg 对其进行保护。\n\n程序执行效果如下：\n//这里截取输出中间部分...输出太多，部分结果省略Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.26.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.27.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.28.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.29.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.30.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.31.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.32.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.33.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.34.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.35.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.36.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.37.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.38.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.39.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.40.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.41.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.42.Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.43.Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.44.Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.45.Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.46.Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.47.Thread: 5512 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.48.Thread: 6676 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.49.Thread: 6676 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.50.\n总结起来，Semaphore 与上面介绍的 Event、Mutex 不一样，由于存在资源计数的概念，可以精准地控制同时唤醒几个等待的线程。\n\n点击这里下载课程源代码\n来源:范蠡《C/C++ 多线程编程精髓》\n","categories":["C/C++ 多线程编程精髓"],"tags":["Linux","Windows","C++ 开发"]},{"title":"Linux常用命令","url":"/2021/10/02/Common-Linux-Commands/","content":"音乐小港\n    \n\n\n常用命令介绍\n1. ctrl c: 取消命令，并且换行2. ctrl u: 清空本行命令3. tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项4. ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件5. pwd: 显示当前路径6. cd XXX: 进入XXX目录下, cd .. 返回上层目录7. cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt8. mkdir XXX: 创建目录XXX9. rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹10. mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令11. touch XXX: 创建一个文件12. cat XXX: 展示文件XXX中的内容13. 复制文本    windows/Linux下：Ctrl + insert，Mac下：command + c14. 粘贴文本    windows/Linux下：Shift + insert，Mac下：command + v\n来源链接：yxc\n\n基础命令介绍\n目录相关命令：\n\npwd：绝对路径\n\n\nls：-a 全部文件 -l 更多信息\n\n\nll：等于 ls -al\n\n\ncd：相对路径或绝对路径 ~ 为home目录 .. 上一级 . 当前目录 - 上一目录\n\n\nmkdir:\n\n语法：mkdir [选项] 目录名称  \n功能：创建文件夹  \n示例：\n\nmkdir test\n-p 创建多层目录 \nmkdir -p test/test1\n\n\n\n\nrmdir：\n\n语法：rmdir [选项] 目录名称  \n功能：删除文件夹  \n示例：\n\nrmdir test\n-p 删除多层目录 \nrmdir -p test/test1\n\n\n\n\ncp：\n\n语法：cp 源目录或文件 目标目录或文件  \n功能：复制文件，复制文件夹必须加 -r  \n示例：\n\ncp test test.txt \n将 test 复制为 test.txt ，复制时重命名）  \n\n\n-r 递归复制整个文件夹 \ncp -r test test1 \n将所有 test 目录内容复制到 test1 目录（自动创建 test1 目录））\n\n\n\n\nmv：\n\n语法：mv [选项] 源目标  \n功能描述：移动文件或重命名文件  \n示例：\n\n命名： mv test test.txt \n将 test 文件重命名为 test.txt\n\n\n移动文件： mv a.txt ./user/b.txt （相对路径移动并重命名文件）\n重命名文件夹： mv aaa/ bbb\n\n\nrm：\n\n语法：rm [选项] 文件\n功能描述：删除文件及目录\n选项： \n\n-f：force 强制执行 \n-r：recursive 递归执行\n\n示例： \n\nrm -rf test2\n\n\n文件相关命令：\n\ntouch：\n\n语法：touch [选项] 文件名\n功能描述：新建文件示例： \n\ntouch test.txt\n\n\necho：\n\n语法：echo 字符串或变量\n功能描述：输出字符串或变量值，还可以搭配从定向符将内容存储到文件\n示例：\n\necho hello\necho $SHELL\necho this is echo &gt;&gt; test.txt\n\n\ncat：\n\n语法：cat [选项] 文件名\n功能描述：查看文件内容，从第一行开始显示\n选项：\n\n-A：列出特殊字符而非空白\n-b：列出行号，空白行不算行号\n-n：列出行号，空白行也会有行号\n-v：列出一些看不出来的特殊字符\n\n示例：\n\ncat -n test.txt\n\n\nmore：\n\n语法：more [选项] 文件\n功能描述：查看文件内容，一页一页的显示\n使用说明：\n\n空格键（space）：向下翻一页\nenter：向下翻一行\nq：退出more，不在显示文件内容\nctrl+f：向下滚动一屏\nctrl+b：返回上一屏\n=：输出当前行的行号\n:f：输出文件名和当前行号\n\n\nhead：\n\n语法：head [选项] 文件\n功能描述：查看文件内容，只看头几行\n选项： \n\n-n：查看头n行\n\n示例：\n\nhead -n 2 test.txt\n只看头两行\n\n\n\n\ntail：\n\n语法：tail [选项] 文件\n功能描述：查看文件内容，只查看文件末尾几行\n选项：\n\n-n：末尾几行\n-f：follow输出文件修改的内容，用于追踪文件修改\n\n示例：\n\ntail -n 2 test.txt\n\n\nwget：\n\n语法：wget [参数] [url地址]\n功能：下载网络文件\n参数：\n\n-b：background后台下载\n-P：directory-prefix下载到指定目录\n-t：tries 最大尝试次数\n-c：continue断点续传clear\n-p：page-requisites下载页面所有内容，包括图片、视频等\n-r：recursive递归下载\n\n示例：\n\n下载百度logo \nwget https://www.baidu.com/img/bd_logo1.png\n\n\n\n\n查找命令：\n\nfind：\n\n语法：find [搜索范围] [参数] [匹配条件]\n功能描述：查找文件或目录\n参数说明：\n\n-name：按文件名称查找\n-user：按文件拥有者查找\n-size：根按文件大小查找文件\n+n 大于\n-n 小于\nn 等于\n\n\n\n示例：\n\nfind test/ -name test1.txt\nfind test/ -user root\nfind test/ -size -102400\n\n\ngrep：\n\n语法：grep [参数] 查找内容 源文件\n功能描述：在文件内搜索字符串匹配的行并输出\n参数：\n\n-c：count只输出匹配行的计数\n-n：line-number\n\n示例： \n\ngrep -n James test.txt\n\n\n压缩解压：\n\ntar：\n\n语法：tar [参数] 包名.tar.gz 待打包的内容\n功能描述：打包目录，压缩后的文件格式为.tar.gz\n参数：\n\n-c：create生成.tar打包文件\n-x：extract解包.tar文件\n-v：verbose显示详细信息\n-f：file指定压缩后的文件名\n-z：打包同时压缩\n-C：解压到指定目录\n\n常用：\n\ntar -cvf 打包名.tar 源文件名1 源文件名2 ... \n打包文件\n\n\ntar -xvf 打包文件名 \n解包\n\n\ntar -zcvf 压缩名.tar.gz 源文件名1 源文件名2 ... \n打包并压缩\n\n\ntar -zxvf 压缩文件名\n解压缩并解打包\n\n\n\n示例：\n\ntar -cvf abc.tar a.txt b.txt c.txt\ntar -xvf abc.tar\ntar -zcvf abc.tar.gz a.txt b.txt c.txt\ntar -zxvf abc.tar.gz\ntar -zcvf abc.tar.gz test/ \n压缩整个目录\n\n\n\n\nzip和unzip：\n\n语法：\n压缩：zip [参数] 包名.zip\n解压：unzip 包名.zip\n功能描述：压缩文件和目录，windows和linux通用且可以压缩目录并保留源文件\n参数： -r：recurse-paths递归压缩目录\n示例：\n\nzip test.zip test.txt test1.txt\nunzip test.zip\n\n\n进程线程命令：\n\nps：\n\n语法：ps [选项]\n功能描述：查看系统中所有进程\n参数：\n\n-a：all 显示现行终端机下的所有程序，包括其他用户的程序（比如多克隆几个会话执行不同命令，也会列出来）\n-u：userlist 以用户为主的格式来显示程序状况\n-x：显示所有程序，不以终端机来区分（前面讲过终端有很多类型，不仅显示当前终端）\n\n示例：\n\nps -aux\n配合管道命令： ps -aux | grep xxx\n\n\n\n\nkill：\n\n语法：kill [选项] 进程id\n功能描述：终止某个指定pid的服务进程\n选项： \n\n-9：强迫进程立即停止\n\n示例： \n\nkill -9 65482\n\n\n系统状态检测命令：\n\nnetstat:\n\n语法：netstat [参数]\n功能描述：显示整个系统目前网络情况，比如目前的链接、数据包传递数据、路由表内容等\n示例：\n\nnetstat\n\n\nfree：\n\n语法：free [选项]\n功能描述：显示当前系统中内存的使用信息\n选项：\n\n-m：megabytes以兆字节显示\n-h：human带单位输出\n\n\n关机：\n\nshutdown：\n\n语法：shutdown [选项] [关机时间] [提示内容]\n功能描述：关机\n选项：\n\n-h：关机\n-r：重启\n\n\n来源链接：女娲补 Linux 指令\n","categories":["Linux 基础"],"tags":["Linux","常用命令"]},{"title":"启动 GDB 调试","url":"/2021/10/10/GDB-0/","content":"音乐小港\n    \n\n\n启动 GDB 调试使用 GDB 调试程序一般有三种方式：\n\ngdb filename\ngdb attach pid\ngdb filename corename\n\n这也对应着本节课的核心内容：\n\n直接调试目标程序\n附加进程\n调试 core 文件接下来我们逐一讲解。\n\n直接调试目标程序在开发阶段或者研究别人的项目时，当编译成功生成目标二进制文件后，可以使用 gdb filename 直接启动这个程序的调试，其中 filename 是需要启动的调试程序文件名，这种方式是直接使用 GDB 启动一个程序进行调试。注意这里说的启动一个程序进行调试其实不严谨，因为实际上只是附加（attach）了一个可执行文件，并没有把程序启动起来；接着需要输入run 命令，程序才会真正的运行起来。关于 run 命令后面的课程中会详细介绍。上一课的 GDB 调试 hello_server 系列就是使用的这种方式。\n假设现在有一个程序叫 fileserver，使用 gdb fileserver 附加该程序，然后使用 run 命令启动该程序。如下图所示：\n\n附加进程在某些情况下，一个程序已经启动了，我们想调试这个程序，但是又不想重启这个程序。假设有这样一个场景，我们的聊天测试服务器程序正在运行，运行一段时间之后，发现这个聊天服务器不能接受新的客户端连接了，这时肯定是不能重启程序的，如果重启，当前程序的各种状态信息就丢失了。怎么办呢？可以使用 gdb attach 进程 ID 来将 GDB 调试器附加到聊天测试服务器程序上。例如，假设聊天程序叫 chatserver，可以使用 ps 命令获取该进程的 PID，然后使用 gdb attach 就可以调试了，操作如下：\n[zhangyl@iZ238vnojlyZ flamingoserver]$ ps -ef | grep chatserverzhangyl  21462 21414  0 18:00 pts/2    00:00:00 grep --color=auto chatserverzhangyl  26621     1  5 Oct10 ?        2-17:54:42 ./chatserver -d\n实际执行如下图所示：\n\n通过以上代码得到 chatserver 的 PID 为 26621，然后使用 gdb attach 26621 把 GDB 附加到 chatserver 进程，操作并输出如下：\n[zhangyl@localhost flamingoserver]$ gdb attach 26621Attaching to process 26661Reading symbols from /home/zhangyl/flamingoserver/chatserver...done.Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...(no debugging symbols found)...done.Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done.[New LWP 42931][New LWP 42930][New LWP 42929][New LWP 42928][New LWP 42927][New LWP 42926][New LWP 42925][New LWP 42924][New LWP 42922][Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Loaded symbols for /lib64/libpthread.so.0Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.\n为了节约篇幅，上述代码中我删掉了一些无关的信息。当提示 “Attaching to process 26621” 时就说明我们已经成功地将 GDB 附加到目标进程了。需要注意的是，程序使用了一些系统库（如 libc.so），由于这是发行版本的 Linux 系统，这些库是没有调试符号的，因而 GDB 会提示找不到这些库的调试符号。因为目的是调试 chatserver，对系统 API 调用的内部实现并不关注，所以这些提示可以不用关注，只要 chatserver 这个文件有调试信息即可。\n当用 gdb attach 上目标进程后，调试器会暂停下来，此时可以使用 continue 命令让程序继续运行，或者加上相应的断点再继续运行程序（这里提到的 continue 命令不熟悉也没有关系，后续会详细介绍这些命令的使用方法）。\n当调试完程序想结束此次调试时，而且不对当前进程 chatserver 有任何影响，也就是说想让这个程序继续运行，可以在 GDB 的命令行界面输入 detach 命令让程序与 GDB 调试器分离，这样 chatserver 就可以继续运行了：\n(gdb) detachDetaching from program: /home/zhangyl/flamingoserver/chatserver, process 42921\n然后再退出 GDB 就可以了：\n(gdb) quit[zhangyl@localhost flamingoserver]$\n调试 core 文件有时候，服务器程序运行一段时间后会突然崩溃，这并不是我们希望看到的，需要解决这个问题。只要程序在崩溃的时候有 core 文件产生，就可以使用这个 core 文件来定位崩溃的原因。当然，Linux 系统默认是不开启程序崩溃产生 core 文件这一机制的，我们可以使用 ulimit -c 命令来查看系统是否开启了这一机制。\n\n顺便提一句，ulimit 这个命令不仅仅可以查看 core 文件生成是否开启，还可以查看其他的一些功能，比如系统允许的最大文件描述符的数量等，具体可以使用 ulimit -a 命令来查看，由于这个内容与本课主题无关，这里不再赘述。\n\n[zhangyl@localhost flamingoserver]$ ulimit -acore file size          (blocks, -c) 0data seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 15045max locked memory       (kbytes, -l) 64max memory size         (kbytes, -m) unlimitedopen files                      (-n) 1024pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 4096virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited\n发现 core file size 那一行默认是 0，表示关闭生成 core 文件，可以使用“ulimit 选项名 设置值”来修改。例如，可以将 core 文件生成改成具体某个值（最大允许的字节数），这里我们使用 ulimit -c unlimited（unlimited 是 -c 选项值）直接修改成不限制大小。\n[zhangyl@localhost flamingoserver]$ ulimit -c unlimited[zhangyl@localhost flamingoserver]$ ulimit -acore file size          (blocks, -c) unlimiteddata seg size           (kbytes, -d) unlimitedscheduling priority             (-e) 0file size               (blocks, -f) unlimitedpending signals                 (-i) 15045max locked memory       (kbytes, -l) 64max memory size         (kbytes, -m) unlimitedopen files                      (-n) 1024pipe size            (512 bytes, -p) 8POSIX message queues     (bytes, -q) 819200real-time priority              (-r) 0stack size              (kbytes, -s) 8192cpu time               (seconds, -t) unlimitedmax user processes              (-u) 4096virtual memory          (kbytes, -v) unlimitedfile locks                      (-x) unlimited\n\n注意，这个命令容易记错，第一个 ulimit 是 Linux 命令， -c 选项后面的 unlimited 是选项的值，表示不限制大小，当然也可以改成具体的数值大小。很多初学者在学习这个命令时，总是把 ulimit 命令和 unlimited 取值搞混淆，如果读者能理解其含义，一般就不会混淆了。\n\n还有一个问题就是，这样修改以后，当我们关闭这个 Linux 会话，设置项的值就会被还原成 0，而服务器程序一般是以后台程序（守护进程）长周期运行，也就是说当前会话虽然被关闭，服务器程序仍然继续在后台运行，这样这个程序在某个时刻崩溃后，是无法产生 core 文件的，这种情形不利于排查问题。因此，我们希望这个选项永久生效，永久生效的方式是把“ulimit -c unlimited”这一行加到 /etc/profile 文件中去，放到这个文件最后一行即可。\n具体的例子生成的 core 文件的默认命名方式是 core.pid，举个例子，比如某个程序当时运行时其进程 ID 是 16663，那么它崩溃产生的 core 文件的名称就是 core.16663。我们来看一个具体的例子，某次我发现服务器上的 msg_server 崩溃了，产生了一个如下的 core 文件：\n-rw------- 1 root root 10092544 Sep  9 15:14 core.21985\n就可以通过这个 core.21985 文件来排查崩溃的原因，调试 core 文件的命令是：\ngdb filename corename\n其中，filename 就是程序名，这里就是 msg_server；corename 是 core.21985，我们输入 gdb msg_server core.21985 来启动调试：\n[root@myaliyun msg_server]# gdb msg_server core.21985Reading symbols from /root/teamtalkserver/src/msg_server/msg_server...done.[New LWP 21985][Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Core was generated by `./msg_server -d'.Program terminated with signal 11, Segmentation fault.#0  0x00000000004ceb1f in std::less&lt;CMsgConn*&gt;::operator() (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430, __y=@0x51: &lt;error reading variable&gt;)    at /usr/include/c++/4.8.2/bits/stl_function.h:235235           { return __x &lt; __y; }\n可以看到程序崩溃的地方是在 stl_function.h 的第 235 行，然后通过 bt 命令（后续将详细介绍该命令）查看崩溃时的调用堆栈，进一步分析就能找到崩溃的原因。\n(gdb) bt#0  0x00000000004ceb1f in std::less&lt;CMsgConn*&gt;::operator() (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430, __y=@0x51: &lt;error reading variable&gt;)    at /usr/include/c++/4.8.2/bits/stl_function.h:235#1  0x00000000004cdd70 in std::_Rb_tree&lt;CMsgConn*, CMsgConn*, std::_Identity&lt;CMsgConn*&gt;, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::_M_get_insert_unique_pos    (this=0x2283878, __k=@0x7ffca83563a0: 0x2284430) at /usr/include/c++/4.8.2/bits/stl_tree.h:1324#2  0x00000000004cd18a in std::_Rb_tree&lt;CMsgConn*, CMsgConn*, std::_Identity&lt;CMsgConn*&gt;, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::_M_insert_unique&lt;CMsgConn* const&amp;&gt; (this=0x2283878, __v=@0x7ffca83563a0: 0x2284430) at /usr/include/c++/4.8.2/bits/stl_tree.h:1377#3  0x00000000004cc8bd in std::set&lt;CMsgConn*, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::insert (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430)    at /usr/include/c++/4.8.2/bits/stl_set.h:463#4  0x00000000004cb011 in CImUser::AddUnValidateMsgConn (this=0x2283820, pMsgConn=0x2284430) at /root/teamtalkserver/src/msg_server/ImUser.h:42#5  0x00000000004c64ae in CDBServConn::_HandleValidateResponse (this=0x227f6a0, pPdu=0x22860d0) at /root/teamtalkserver/src/msg_server/DBServConn.cpp:319#6  0x00000000004c5e3d in CDBServConn::HandlePdu (this=0x227f6a0, pPdu=0x22860d0) at /root/teamtalkserver/src/msg_server/DBServConn.cpp:203#7  0x00000000005022b3 in CImConn::OnRead (this=0x227f6a0) at /root/teamtalkserver/src/base/imconn.cpp:148#8  0x0000000000501db3 in imconn_callback (callback_data=0x7f4b20 &lt;g_db_server_conn_map&gt;, msg=3 '\\003', handle=8, pParam=0x0)    at /root/teamtalkserver/src/base/imconn.cpp:47#9  0x0000000000504025 in CBaseSocket::OnRead (this=0x227f820) at /root/teamtalkserver/src/base/BaseSocket.cpp:178#10 0x0000000000502f8a in CEventDispatch::StartDispatch (this=0x2279990, wait_timeout=100) at /root/teamtalkserver/src/base/EventDispatch.cpp:386#11 0x00000000004fddbe in netlib_eventloop (wait_timeout=100) at /root/teamtalkserver/src/base/netlib.cpp:160#12 0x00000000004d18c2 in main (argc=2, argv=0x7ffca8359978) at /root/teamtalkserver/src/msg_server/msg_server.cpp:213(gdb)\n堆栈 #4 就不是库代码了，我们可以排查这里的代码，然后找到问题原因。\n自定义 core 文件名称但是细心的读者会发现一个问题：一个正在程序运行时，其 PID 是可以获取到的，但是当程序崩溃后，产生了 core 文件，尤其是多个程序同时崩溃，我们根本没法通过 core 文件名称中的 PID 来区分到底是哪个服务解决这个问题有两个方法：\n\n程序启动时，记录一下自己的 PIDvoid writePid(){      uint32_t curPid = (uint32_t) getpid();      FILE* f = fopen(\"xxserver.pid\", \"w\");      assert(f);      char szPid[32];      snprintf(szPid, sizeof(szPid), \"%d\", curPid);      fwrite(szPid, strlen(szPid), 1, f);      fclose(f);}\n我们在程序启动时调用上述 writePID 函数，将程序当时的 PID 记录到 xxserver.pid 文件中去，这样当程序崩溃时，可以从这个文件中得到进程当时运行的 PID，这样就可以与默认的 core 文件名后面的 PID 做匹配了。\n自定义 core 文件的名称和目录/proc/sys/kernel/core_uses_pid 可以控制产生的 core 文件的文件名中是否添加 PID 作为扩展，如果添加则文件内容为 1，否则为 0；**/proc/sys/kernel/core_pattern** 可以设置格式化的 core 文件保存位置或文件名。修改方式如下：echo \"/corefile/core-%e-%p-%t\" &gt; /proc/sys/kernel/core_pattern\n各个参数的说明如下：\n\n\n\n\n参数名称\n参数含义（英文）\n参数含义（中文）\n\n\n\n%p\ninsert pid into filename\n添加 pid 到 core 文件名中\n\n\n%u\ninsert current uid into filename\n添加当前 uid 到 core 文件名中\n\n\n%g\ninsert current gid into filename\n添加当前 gid 到 core 文件名中\n\n\n%s\ninsert signal that caused the coredump into the filename\n添加导致产生 core 的信号到 core 文件名中\n\n\n%t\ninsert UNIX time that the coredump occurred into filename\n添加 core 文件生成时间（UNIX）到 core 文件名中\n\n\n%h\ninsert hostname where the coredump happened into filename\n添加主机名到 core 文件名中\n\n\n%e\ninsert coredumping executable name into filename\n添加程序名到 core 文件名中\n\n\n假设现在的程序叫 test，我们设置该程序崩溃时的 core 文件名如下：\necho \"/root/testcore/core-%e-%p-%t\" &gt; /proc/sys/kernel/core_pattern\n那么最终会在 /root/testcore/ 目录下生成的 test 的 core 文件名格式如下：\n-rw-------. 1 root root 409600 Jan 14 13:54 core-test-13154-1547445291\n\n\n需要注意的是，您使用的用户必须对指定 core 文件目录具有写权限，否则生成时 会因为权限不足而导致无法生成 core 文件。\n\n小结本节课介绍了使用 GDB 调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"GDB 常用命令详解（上）","url":"/2021/10/10/GDB-1/","content":"音乐小港\n    \n\n\nGDB 常用命令详解（上）本课的核心内容如下：\n\nrun 命令\ncontinue 命令\nbreak 命令\nbacktrace 与 frame 命令\ninfo break、enable、disable 和 delete 命令\nlist 命令\nprint 和 ptype 命令\n\n为了结合实践，这里以调试 Redis 源码为例来介绍每一个命令，先介绍一些常用命令的基础用法，某些命令的高级用法会在后面讲解。\nRedis 源码下载与 debug 版本编译Redis 的最新源码下载地址可以在 Redis 官网获得，使用 wget 命令将 Redis 源码文件下载下来：\n[root@localhost gdbtest]# wget http://download.redis.io/releases/redis-4.0.11.tar.gz--2018-09-08 13:08:41--  http://download.redis.io/releases/redis-4.0.11.tar.gzResolving download.redis.io (download.redis.io)... 109.74.203.151Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.HTTP request sent, awaiting response... 200 OKLength: 1739656 (1.7M) [application/x-gzip]Saving to: ‘redis-4.0.11.tar.gz’54% [==================================================================&gt;                                                         ] 940,876     65.6KB/s  eta 9s\n解压：\n[root@localhost gdbtest]# tar zxvf redis-4.0.11.tar.gz\n进入生成的 redis-4.0.11 目录使用 makefile 命令进行编译。makefile 命令是 Linux 程序编译基本的命令，由于本课程的重点是 Linux 调试，如果读者不熟悉 Linux 编译可以通过互联网或相关书籍补充一下相关知识。\n为了方便调试，我们需要生成调试符号并且关闭编译器优化选项，操作如下：\n[root@localhost gdbtest]# cd redis-4.0.11[root@localhost redis-4.0.11]# make CFLAGS=\"-g -O0\" -j 4\n\n注意：由于 redis 是纯 C 项目，使用的编译器是 gcc，因而这里设置编译器的选项时使用的是 CFLAGS 选项；如果项目使用的语言是 C++，那么使用的编译器一般是 g++，相对应的编译器选项是 CXXFLAGS。这点请读者注意区别。\n另外，这里 makefile 使用了 -j 选项，其值是 4，表示开启 4 个进程同时编译，加快编译速度。\n\n编译成功后，会在 src 目录下生成多个可执行程序，其中 redis-server 和 redis-cli 是需要调试的程序。\n进入 src 目录，使用 GDB 启动 redis-server 这个程序：\n[root@localhost src]# gdb redis-serverReading symbols from /root/gdbtest/redis-4.0.11/src/redis-server...done.\nrun 命令默认情况下，前面的课程中我们说 gdb filename 命令只是附加的一个调试文件，并没有启动这个程序，需要输入 run 命令（简写为 r）启动这个程序：\n(gdb) rStarting program: /root/gdbtest/redis-4.0.11/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".46455:C 08 Sep 13:43:43.957 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo46455:C 08 Sep 13:43:43.957 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46455, just started46455:C 08 Sep 13:43:43.957 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf46455:M 08 Sep 13:43:43.957 * Increased maximum number of open files to 10032 (it was originally set to 1024).[New Thread 0x7ffff07ff700 (LWP 46459)][New Thread 0x7fffefffe700 (LWP 46460)][New Thread 0x7fffef7fd700 (LWP 46461)]                _._           _.-``__ ''-._      _.-``    `.  `_.  ''-._           Redis 4.0.11 (00000000/0) 64 bit  .-`` .-```.  ```\\/    _.,_ ''-._ (    '      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379 |    `-._   `._    /     _.-'    |     PID: 46455  `-._    `-._  `-./  _.-'    _.-' |`-._`-._    `-.__.-'    _.-'_.-'| |    `-._`-._        _.-'_.-'    |     http://redis.io  `-._    `-._`-.__.-'_.-'    _.-' |`-._`-._    `-.__.-'    _.-'_.-'| |    `-._`-._        _.-'_.-'    |  `-._    `-._`-.__.-'_.-'    _.-'      `-._    `-.__.-'    _.-'          `-._        _.-'              `-.__.-'46455:M 08 Sep 13:43:43.965 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.46455:M 08 Sep 13:43:43.965 # Server initialized46455:M 08 Sep 13:43:43.965 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.46455:M 08 Sep 13:43:43.965 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.46455:M 08 Sep 13:43:43.965 * Ready to accept connections\n这就是 redis-server 启动界面，假设程序已经启动，再次输入 run 命令则是重启程序。我们在 GDB 界面按 Ctrl + C 快捷键让 GDB 中断下来，再次输入 r 命令，GDB 会询问我们是否重启程序，输入 yes 确认重启。\n^CProgram received signal SIGINT, Interrupt.0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yesStarting program: /root/gdbtest/redis-4.0.11/src/redis-server\ncontinue 命令当 GDB 触发断点或者使用 Ctrl + C 命令中断下来后，想让程序继续运行，只要输入 continue 命令即可（简写为 c）。当然，如果 continue 命令继续触发断点，GDB 就会再次中断下来。\n^CProgram received signal SIGINT, Interrupt.0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6(gdb) cContinuing.\nbreak 命令break 命令（简写为 b）即我们添加断点的命令，可以使用以下方式添加断点：\n\nbreak functionname，在函数名为 functionname 的入口处添加一个断点；\nbreak LineNo，在当前文件行号为 LineNo 处添加一个断点；\nbreak filename:LineNo，在 filename 文件行号为 LineNo 处添加一个断点。这三种方式都是我们常用的添加断点的方式。举个例子，对于一般的 Linux 程序来说，main() 函数是程序入口函数，redis-server 也不例外，我们知道了函数的名字，就可以直接在 main() 函数处添加一个断点：(gdb) b mainBreakpoint 1 at 0x423450: file server.c, line 3709.\n添加好了以后，使用 run 命令重启程序，就可以触发这个断点了，GDB 会停在断点处。(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/gdbtest/redis-4.0.11/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 1, main (argc=1, argv=0x7fffffffe648) at server.c:37093709    int main(int argc, char **argv) {(gdb)\nredis-server 默认端口号是 6379 ，我们知道这个端口号肯定是通过操作系统的 socket API bind() 函数创建的，通过文件搜索，找到调用这个函数的文件，其位于 anet.c 441 行。\n\n\n我们使用 break 命令在这个地方加一个断点：\n(gdb) b anet.c:441Breakpoint 3 at 0x426cf0: file anet.c, line 441\n由于程序绑定端口号是 redis-server 启动时初始化的，为了能触发这个断点，再次使用 run 命令重启下这个程序，GDB 第一次会触发 main() 函数处的断点，输入 continue 命令继续运行，接着触发 anet.c:441 处的断点：\n(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/gdbtest/redis-4.0.11/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 1, main (argc=1, argv=0x7fffffffe648) at server.c:37093709    int main(int argc, char **argv) {(gdb) cContinuing.46699:C 08 Sep 15:30:31.403 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo46699:C 08 Sep 15:30:31.403 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46699, just started46699:C 08 Sep 15:30:31.403 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf46699:M 08 Sep 15:30:31.404 * Increased maximum number of open files to 10032 (it was originally set to 1024).Breakpoint 3, anetListen (err=0x746bb0 &lt;server+560&gt; \"\", s=10, sa=0x75edb0, len=28, backlog=511) at anet.c:441441         if (bind(s,sa,len) == -1) {(gdb)\nanet.c:441 处的代码如下：\n\n现在断点停在第 441 行，所以当前文件就是 anet.c，可以直接使用“break 行号”添加断点。例如，可以在第 444 行、450 行、452 行分别加一个断点，看看这个函数执行完毕后走哪个 return 语句退出，则可以执行：\n440     static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int                               backlog) {441         if (bind(s,sa,len) == -1) {442             anetSetError(err, \"bind: %s\", strerror(errno));443             close(s);444             return ANET_ERR;(gdb) l445         }446447         if (listen(s, backlog) == -1) {448             anetSetError(err, \"listen: %s\", strerror(errno));449             close(s);450             return ANET_ERR;451         }452         return ANET_OK;453     }454(gdb) b 444Breakpoint 3 at 0x426cf5: file anet.c, line 444.(gdb) b 450Breakpoint 4 at 0x426d06: file anet.c, line 450.(gdb) b 452Note: breakpoint 4 also set at pc 0x426d06.Breakpoint 5 at 0x426d06: file anet.c, line 452.(gdb)\n添加好这三个断点以后，我们使用 continue 命令继续运行程序，发现程序运行到第 452 行中断下来（即触发 Breakpoint 5）：\n(gdb) cContinuing.Breakpoint 5, anetListen (err=0x746bb0 &lt;server+560&gt; \"\", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:452452         return ANET_OK;\n说明 redis-server 绑定端口号并设置侦听（listen）成功，我们可以再打开一个 SSH 窗口，验证一下，发现 6379 端口确实已经处于侦听状态了：\n[root@localhost src]# lsof -i -Pn | grep redisredis-ser 46699    root   10u  IPv6 245844      0t0  TCP *:6379 (LISTEN)\nbacktrace 与 frame 命令backtrace 命令（简写为 bt）用来查看当前调用堆栈。接上，redis-server 现在中断在 anet.c:452 行，可以通过 backtrace 命令来查看当前的调用堆栈：\n(gdb) bt#0  anetListen (err=0x746bb0 &lt;server+560&gt; \"\", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:452#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)    at anet.c:487#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)    at anet.c:510#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728#4  0x000000000042fa77 in initServer () at server.c:1852#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862(gdb)\n这里一共有 6 层堆栈，最顶层是 main() 函数，最底层是断点所在的 anetListen() 函数，堆栈编号分别是 #0 ~ #5 ，如果想切换到其他堆栈处，可以使用 frame 命令（简写为 f），该命令的使用方法是“frame 堆栈编号（编号不加 #）”。在这里依次切换至堆栈顶部，然后再切换回 #0 练习一下：\n(gdb) f 1#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)    at anet.c:487487             if (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;(gdb) f 2#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)    at anet.c:510510         return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);(gdb) f 3#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:17281728                fds[*count] = anetTcp6Server(server.neterr,port,NULL,(gdb) f 4#4  0x000000000042fa77 in initServer () at server.c:18521852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)(gdb) f 5#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:38623862        initServer();(gdb)\n通过查看上面的各个堆栈，可以得出这里的调用层级关系，即：\n\nmain() 函数在第 3862 行调用了 initServer() 函数\ninitServer() 在第 1852 行调用了 listenToPort() 函数\nlistenToPort() 在第 1728 行调用了 anetTcp6Server() 函数\nanetTcp6Server() 在第 510 行调用了 _anetTcpServer() 函数\n_anetTcpServer() 函数在第 487 行调用了 anetListen() 函数\n当前断点正好位于 anetListen() 函数中info break、enable、disable 和 delete 命令在程序中加了很多断点，而我们想查看加了哪些断点时，可以使用 info break 命令（简写为 info b）：(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x0000000000423450 in main at server.c:3709        breakpoint already hit 1 time2       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:2673       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441        breakpoint already hit 1 time4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444        breakpoint already hit 1 time5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450        breakpoint already hit 1 time6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452        breakpoint already hit 1 time\n通过上面的内容片段可以知道，目前一共增加了 6 个断点，除了断点 2 以外，其他的断点均被触发一次，其他信息比如每个断点的位置（所在的文件和行号）、内存地址、断点启用和禁用状态信息也一目了然。如果我们想禁用某个断点，使用“disable 断点编号”就可以禁用这个断点了，被禁用的断点不会再被触发；同理，被禁用的断点也可以使用“enable 断点编号”重新启用。(gdb) disable 1(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep n   0x0000000000423450 in main at server.c:3709        breakpoint already hit 1 time2       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:2673       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441        breakpoint already hit 1 time4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444        breakpoint already hit 1 time5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450        breakpoint already hit 1 time6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452        breakpoint already hit 1 time\n使用 disable 1 以后，第一个断点的 Enb 一栏的值由 y 变成 n，重启程序也不会再次触发：(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/gdbtest/redis-4.0.11/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".46795:C 08 Sep 16:15:55.681 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo46795:C 08 Sep 16:15:55.681 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46795, just started46795:C 08 Sep 16:15:55.681 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf46795:M 08 Sep 16:15:55.682 * Increased maximum number of open files to 10032 (it was originally set to 1024).Breakpoint 3, anetListen (err=0x746bb0 &lt;server+560&gt; \"\", s=10, sa=0x75edb0, len=28, backlog=511) at anet.c:441441         if (bind(s,sa,len) == -1) {\n如果 disable 命令和 enable 命令不加断点编号，则分别表示禁用和启用所有断点：(gdb) disable(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep n   0x0000000000423450 in main at server.c:37092       breakpoint     keep n   0x000000000049c1f0 in _redisContextConnectTcp at net.c:2673       breakpoint     keep n   0x0000000000426cf0 in anetListen at anet.c:441        breakpoint already hit 1 time4       breakpoint     keep n   0x0000000000426d05 in anetListen at anet.c:4445       breakpoint     keep n   0x0000000000426d16 in anetListen at anet.c:4506       breakpoint     keep n   0x0000000000426d16 in anetListen at anet.c:452(gdb) enable(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x0000000000423450 in main at server.c:37092       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:2673       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441        breakpoint already hit 1 time4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:4445       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:4506       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452(gdb)\n使用“delete 编号”可以删除某个断点，如 delete 2 3 则表示要删除的断点 2 和断点 3：(gdb) delete 2 3(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x0000000000423450 in main at server.c:37094       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:4445       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:4506       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452\n同样的道理，如果输入 delete 不加命令号，则表示删除所有断点。\n\nlist 命令list 命令和后面介绍的 print 命令都是 GDB 调试中用到的频率最高的命令，list 命令（简写为 l）可以查看当前断点处的代码。使用 frame 命令切换到刚才的堆栈 #3 处，然后输入 list 命令看下效果：\n(gdb) f 4#4  0x000000000042fa77 in initServer () at server.c:18521852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)(gdb) l1847        }1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);18491850        /* Open the TCP listening socket for the user commands. */1851        if (server.port != 0 &amp;&amp;1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)1853            exit(1);18541855        /* Open the listening Unix domain socket. */1856        if (server.unixsocket != NULL) {(gdb)\n断点停在第 1852 行，输入 list 命令以后，会显示第 1852 行前后的 10 行代码，再次输入 list 命令试一下：\n(gdb) l1857            unlink(server.unixsocket); /* don't care if this fails */1858            server.sofd = anetUnixServer(server.neterr,server.unixsocket,1859                server.unixsocketperm, server.tcp_backlog);1860            if (server.sofd == ANET_ERR) {1861                serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);1862                exit(1);1863            }1864            anetNonBlock(NULL,server.sofd);1865        }1866(gdb) l1867        /* Abort if there are no listening sockets at all. */1868        if (server.ipfd_count == 0 &amp;&amp; server.sofd &lt; 0) {1869            serverLog(LL_WARNING, \"Configured to not listen anywhere, exiting.\");1870            exit(1);1871        }18721873        /* Create the Redis databases, and initialize other internal state. */1874        for (j = 0; j &lt; server.dbnum; j++) {1875            server.db[j].dict = dictCreate(&amp;dbDictType,NULL);1876            server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL);\n代码继续往后显示 10 行，也就是说，第一次输入 list 命令会显示断点处前后的代码，继续输入 list 指令会以递增行号的形式继续显示剩下的代码行，一直到文件结束为止。当然 list 指令还可以往前和往后显示代码，命令分别是“**list + （加号）”和“list - **（减号）”：\n(gdb) list -1857            unlink(server.unixsocket); /* don't care if this fails */1858            server.sofd = anetUnixServer(server.neterr,server.unixsocket,1859                server.unixsocketperm, server.tcp_backlog);1860            if (server.sofd == ANET_ERR) {1861                serverLog(LL_WARNING, \"Opening Unix socket: %s\", server.neterr);1862                exit(1);1863            }1864            anetNonBlock(NULL,server.sofd);1865        }1866(gdb) l -1847        }1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);18491850        /* Open the TCP listening socket for the user commands. */1851        if (server.port != 0 &amp;&amp;1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)1853            exit(1);18541855        /* Open the listening Unix domain socket. */1856        if (server.unixsocket != NULL) {\nlist 默认显示多少行可以通过修改相关的 GDB 配置，由于我们一般不会修改这个默认显示行数，这里就不再浪费篇幅介绍了。list 不仅可以显示当前断点处的代码，也可以显示其他文件某一行的代码，更多的用法可以在 GDB 中输入 help list 查看（也可以通过）：\n(gdb) help listList specified function or line.With no argument, lists ten more lines after or around previous listing.\"list -\" lists the ten lines before a previous ten-line listing.One argument specifies a line, and ten lines are listed around that line.Two arguments with comma between specify starting and ending lines to list.Lines can be specified in these ways:  LINENUM, to list around that line in current file,  FILE:LINENUM, to list around that line in that file,  FUNCTION, to list around beginning of that function,  FILE:FUNCTION, to distinguish among like-named static functions.  *ADDRESS, to list around the line containing that address.With two args if one is empty it stands for ten lines away from the other arg.\n上面的帮助信息中，介绍了可以使用 list FILE:LINENUM 来显示某个文件的某一行处的代码，这里不再演示是因为我觉得实用性不大。使用 GDB 的目的是调试，因此更关心的是断点附近的代码，而不是通过 GDB 阅读代码，GDB 并不是一个好的阅读工具。以我自己为例，调试 Redis 时用 GDB 调试，而阅读代码使用的却是 Visual Studio，如下图所示：\n\nprint 和 ptype 命令通过 print 命令（简写为 p）我们可以在调试过程中方便地查看变量的值，也可以修改当前内存中的变量值。切换当前断点到堆栈 #4 ，然后打印以下三个变量。\n(gdb) bt#0  anetListen (err=0x746bb0 &lt;server+560&gt; \"\", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:447#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)    at anet.c:487#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; \"\", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)    at anet.c:510#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728#4  0x000000000042fa77 in initServer () at server.c:1852#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862(gdb) f 4#4  0x000000000042fa77 in initServer () at server.c:18521852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)(gdb) l1847        }1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);18491850        /* Open the TCP listening socket for the user commands. */1851        if (server.port != 0 &amp;&amp;1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)1853            exit(1);18541855        /* Open the listening Unix domain socket. */1856        if (server.unixsocket != NULL) {(gdb) p server.port$15 = 6379(gdb) p server.ipfd$16 = {0 &lt;repeats 16 times&gt;}(gdb) p server.ipfd_count$17 = 0\n这里使用 print 命令分别打印出 server.port 、server.ipfd 、server.ipfd_count 的值，其中 server.ipfd 显示 “{0 }”，这是 GDB 显示字符串或字符数据特有的方式，当一个字符串变量或者字符数组或者连续的内存值重复若干次，GDB 就会以这种模式来显示以节约空间。\nprint 命令不仅可以显示变量值，也可以显示进行一定运算的表达式计算结果值，甚至可以显示一些函数的执行结果值。\n举个例子，我们可以输入 p &amp;server.port 来输出 server.port 的地址值，如果在 C++ 对象中，可以通过 p this 来显示当前对象的地址，也可以通过 p *this 来列出当前对象的各个成员变量值，如果有三个变量可以相加（ 假设变量名分别叫 a、b、c ），可以使用 p a + b + c 来打印这三个变量的结果值。\n假设 func() 是一个可以执行的函数，p func() 命令可以输出该变量的执行结果。举一个最常用的例子，某个时刻，某个系统函数执行失败了，通过系统变量 errno 得到一个错误码，则可以使用 p strerror(errno) 将这个错误码对应的文字信息打印出来，这样就不用费劲地去 man 手册上查找这个错误码对应的错误含义了。\nprint 命令不仅可以输出表达式结果，同时也可以修改变量的值，我们尝试将上文中的端口号从 6379 改成 6400 试试：\n(gdb) p server.port=6400$24 = 6400(gdb) p server.port$25 = 6400(gdb)\n当然，一个变量值修改后能否起作用要看这个变量的具体位置和作用，举个例子，对于表达式 int a = b / c ; 如果将 c 修改成 0 ，那么程序就会产生除零异常。再例如，对于如下代码：\nint j = 100;for (int i = 0; i &lt; j; ++i) {    printf(\"i = %d\\n\", i);}\n如果在循环的过程中，利用 print 命令将 j 的大小由 100 改成 1000 ，那么这个循环将输出 i 的值 1000 次。\n总结起来，利用 print 命令，我们不仅可以查看程序运行过程中的各个变量的状态值，也可以通过临时修改变量的值来控制程序的行为。\nGDB 还有另外一个命令叫 ptype ，顾名思义，其含义是“print type”，就是输出一个变量的类型。例如，我们试着输出 Redis 堆栈 #4 的变量 server 和变量 server.port 的类型：\n(gdb) ptype servertype = struct redisServer {    pid_t pid;    char *configfile;    char *executable;    char **exec_argv;    int hz;    redisDb *db;    ...省略部分字段...(gdb) ptype server.porttype = int\n可以看到，对于一个复合数据类型的变量，ptype 不仅列出了这个变量的类型（ 这里是一个名叫 redisServer 的结构体），而且详细地列出了每个成员变量的字段名，有了这个功能，我们在调试时就不用刻意去代码文件中查看某个变量的类型定义了。\n小结本节课介绍了 run、continue、break、backtrace、frame、info break、list、print 和 ptype 等命令，这些都是 GDB 调试过程中非常常用的命令，尤其是一些复合命令（如 info、break）是调试多线程程序的核心命令，请读者务必掌握。\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"两点间的距离","url":"/2021/10/17/Distance-between-two-points/","content":"音乐小港\n    \n\n\n两点间的距离题目给定两个点  和 ，其中  的坐标为 ， 的坐标为 ，请你计算两点间的距离是多少。\n​                                                \n输入格式输入共两行，每行包含两个双精度浮点数 ，表示其中一个点的坐标。\n输入数值均保留一位小数。\n输出格式输出你的结果，保留四位小数。\n数据范围\n输入样例1.0 7.05.0 9.0\n\n输出样例4.4721\n\nAC代码#include&lt;cstdio&gt;#include&lt;cmath&gt;int main(){    double a,b,c,d;    scanf(\"%lf%lf\\n%lf%lf\",&amp;a,&amp;b,&amp;c,&amp;d);    printf(\"%.4lf\",sqrt((a-c)*(a-c)+(b-d)*(b-d)));    return 0;}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"GDB 常用命令详解（下）","url":"/2021/10/10/GDB-3/","content":"音乐小港\n    \n\n\nGDB 常用命令详解（下）本课的核心内容：\n\ndisassemble 命令\nset args 和 show args 命令\ntbreak 命令\nwatch 命令\ndisplay 命令\n\ndisassemble 命令当进行一些高级调试时，我们可能需要查看某段代码的汇编指令去排查问题，或者是在调试一些没有调试信息的发布版程序时，也只能通过反汇编代码去定位问题，那么 disassemble 命令就派上用场了。\ninitServer () at server.c:18391839        createSharedObjects();(gdb) disassembleDump of assembler code for function initServer:   0x000000000042f450 &lt;+0&gt;:     push   %r12   0x000000000042f452 &lt;+2&gt;:     mov    $0x1,%esi   0x000000000042f457 &lt;+7&gt;:     mov    $0x1,%edi   0x000000000042f45c &lt;+12&gt;:    push   %rbp   0x000000000042f45d &lt;+13&gt;:    push   %rbx   0x000000000042f45e &lt;+14&gt;:    callq  0x421eb0 &lt;signal@plt&gt;   0x000000000042f463 &lt;+19&gt;:    mov    $0x1,%esi   0x000000000042f468 &lt;+24&gt;:    mov    $0xd,%edi   0x000000000042f46d &lt;+29&gt;:    callq  0x421eb0 &lt;signal@plt&gt;   0x000000000042f472 &lt;+34&gt;:    callq  0x42f3a0 &lt;setupSignalHandlers&gt;   0x000000000042f477 &lt;+39&gt;:    mov    0x316d52(%rip),%r8d        # 0x7461d0 &lt;server+2128&gt;   0x000000000042f47e &lt;+46&gt;:    test   %r8d,%r8d   0x000000000042f481 &lt;+49&gt;:    jne    0x42f928 &lt;initServer+1240&gt;   0x000000000042f487 &lt;+55&gt;:    callq  0x421a50 &lt;getpid@plt&gt;   0x000000000042f48c &lt;+60&gt;:    movq   $0x0,0x316701(%rip)        # 0x745b98 &lt;server+536&gt;   0x000000000042f497 &lt;+71&gt;:    mov    %eax,0x3164e3(%rip)        # 0x745980 &lt;server&gt;   0x000000000042f49d &lt;+77&gt;:    callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4a2 &lt;+82&gt;:    mov    %rax,0x3166c7(%rip)        # 0x745b70 &lt;server+496&gt;   0x000000000042f4a9 &lt;+89&gt;:    callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4ae &lt;+94&gt;:    mov    %rax,0x3166c3(%rip)        # 0x745b78 &lt;server+504&gt;   0x000000000042f4b5 &lt;+101&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4ba &lt;+106&gt;:   mov    %rax,0x3166c7(%rip)        # 0x745b88 &lt;server+520&gt;   0x000000000042f4c1 &lt;+113&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4c6 &lt;+118&gt;:   mov    %rax,0x3166c3(%rip)        # 0x745b90 &lt;server+528&gt;   0x000000000042f4cd &lt;+125&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4d2 &lt;+130&gt;:   movl   $0xffffffff,0x316d6c(%rip)        # 0x746248 &lt;server+2248&gt;   0x000000000042f4dc &lt;+140&gt;:   mov    %rax,0x31669d(%rip)        # 0x745b80 &lt;server+512&gt;   0x000000000042f4e3 &lt;+147&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4e8 &lt;+152&gt;:   mov    %rax,0x316ec9(%rip)        # 0x7463b8 &lt;server+2616&gt;   0x000000000042f4ef &lt;+159&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f4f4 &lt;+164&gt;:   mov    %rax,0x316ec5(%rip)        # 0x7463c0 &lt;server+2624&gt;   0x000000000042f4fb &lt;+171&gt;:   callq  0x423cb0 &lt;listCreate&gt;   0x000000000042f500 &lt;+176&gt;:   movl   $0x0,0x316e7e(%rip)        # 0x746388 &lt;server+2568&gt;   0x000000000042f50a &lt;+186&gt;:   mov    %rax,0x316e6f(%rip)        # 0x746380 &lt;server+2560&gt;   0x000000000042f511 &lt;+193&gt;:   movl   $0x0,0x316685(%rip)        # 0x745ba0 &lt;server+544&gt;   0x000000000042f51b &lt;+203&gt;:   callq  0x432e90 &lt;zmalloc_get_memory_size&gt;   0x000000000042f520 &lt;+208&gt;:   mov    %rax,0x316fd9(%rip)        # 0x746500 &lt;server+2944&gt;=&gt; 0x000000000042f527 &lt;+215&gt;:   callq  0x42a7b0 &lt;createSharedObjects&gt;\nGDB 默认反汇编为 AT&amp;T 格式的指令，可以通过 show disassembly-flavor 查看，如果习惯 intel 汇编格式可以用命令 set disassembly-flavor intel 来设置。\n(gdb) set disassembly-flavor intel(gdb) disassembleDump of assembler code for function initServer:   0x000000000042f450 &lt;+0&gt;:     push   r12   0x000000000042f452 &lt;+2&gt;:     mov    esi,0x1   0x000000000042f457 &lt;+7&gt;:     mov    edi,0x1   0x000000000042f45c &lt;+12&gt;:    push   rbp   0x000000000042f45d &lt;+13&gt;:    push   rbx   0x000000000042f45e &lt;+14&gt;:    call   0x421eb0 &lt;signal@plt&gt;   0x000000000042f463 &lt;+19&gt;:    mov    esi,0x1   0x000000000042f468 &lt;+24&gt;:    mov    edi,0xd   0x000000000042f46d &lt;+29&gt;:    call   0x421eb0 &lt;signal@plt&gt;   0x000000000042f472 &lt;+34&gt;:    call   0x42f3a0 &lt;setupSignalHandlers&gt;   0x000000000042f477 &lt;+39&gt;:    mov    r8d,DWORD PTR [rip+0x316d52]        # 0x7461d0 &lt;server+2128&gt;   0x000000000042f47e &lt;+46&gt;:    test   r8d,r8d   0x000000000042f481 &lt;+49&gt;:    jne    0x42f928 &lt;initServer+1240&gt;   0x000000000042f487 &lt;+55&gt;:    call   0x421a50 &lt;getpid@plt&gt;   0x000000000042f48c &lt;+60&gt;:    mov    QWORD PTR [rip+0x316701],0x0        # 0x745b98 &lt;server+536&gt;   0x000000000042f497 &lt;+71&gt;:    mov    DWORD PTR [rip+0x3164e3],eax        # 0x745980 &lt;server&gt;   0x000000000042f49d &lt;+77&gt;:    call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4a2 &lt;+82&gt;:    mov    QWORD PTR [rip+0x3166c7],rax        # 0x745b70 &lt;server+496&gt;   0x000000000042f4a9 &lt;+89&gt;:    call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4ae &lt;+94&gt;:    mov    QWORD PTR [rip+0x3166c3],rax        # 0x745b78 &lt;server+504&gt;   0x000000000042f4b5 &lt;+101&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4ba &lt;+106&gt;:   mov    QWORD PTR [rip+0x3166c7],rax        # 0x745b88 &lt;server+520&gt;   0x000000000042f4c1 &lt;+113&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4c6 &lt;+118&gt;:   mov    QWORD PTR [rip+0x3166c3],rax        # 0x745b90 &lt;server+528&gt;   0x000000000042f4cd &lt;+125&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4d2 &lt;+130&gt;:   mov    DWORD PTR [rip+0x316d6c],0xffffffff        # 0x746248 &lt;server+2248&gt;   0x000000000042f4dc &lt;+140&gt;:   mov    QWORD PTR [rip+0x31669d],rax        # 0x745b80 &lt;server+512&gt;   0x000000000042f4e3 &lt;+147&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4e8 &lt;+152&gt;:   mov    QWORD PTR [rip+0x316ec9],rax        # 0x7463b8 &lt;server+2616&gt;   0x000000000042f4ef &lt;+159&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f4f4 &lt;+164&gt;:   mov    QWORD PTR [rip+0x316ec5],rax        # 0x7463c0 &lt;server+2624&gt;   0x000000000042f4fb &lt;+171&gt;:   call   0x423cb0 &lt;listCreate&gt;   0x000000000042f500 &lt;+176&gt;:   mov    DWORD PTR [rip+0x316e7e],0x0        # 0x746388 &lt;server+2568&gt;   0x000000000042f50a &lt;+186&gt;:   mov    QWORD PTR [rip+0x316e6f],rax        # 0x746380 &lt;server+2560&gt;   0x000000000042f511 &lt;+193&gt;:   mov    DWORD PTR [rip+0x316685],0x0        # 0x745ba0 &lt;server+544&gt;   0x000000000042f51b &lt;+203&gt;:   call   0x432e90 &lt;zmalloc_get_memory_size&gt;   0x000000000042f520 &lt;+208&gt;:   mov    QWORD PTR [rip+0x316fd9],rax        # 0x746500 &lt;server+2944&gt;=&gt; 0x000000000042f527 &lt;+215&gt;:   call   0x42a7b0 &lt;createSharedObjects&gt;\nset args 和 show args 命令很多程序需要我们传递命令行参数。在 GDB 调试中，很多人会觉得可以使用 gdb filename args 这种形式来给 GDB 调试的程序传递命令行参数，这样是不行的。正确的做法是在用 GDB 附加程序后，在使用 run 命令之前，使用“set args 参数内容”来设置命令行参数。\n还是以 redis-server 为例，Redis 启动时可以指定一个命令行参数，它的默认配置文件位于 redis-server 这个文件的上一层目录，因此我们可以在 GDB 中这样传递这个参数：set args ../redis.conf（即文件 redis.conf 位于当前程序 redis-server 的上一层目录），可以通过 show args 查看命令行参数是否设置成功。\n(gdb) set args ../redis.conf(gdb) show argsArgument list to give program being debugged when it is started is \"../redis.conf \".(gdb)\n如果单个命令行参数之间含有空格，可以使用引号将参数包裹起来。\n(gdb) set args \"999 xx\" \"hu jj\"(gdb) show argsArgument list to give program being debugged when it is started is \"\"999 xx\" \"hu jj\"\".(gdb)\n如果想清除掉已经设置好的命令行参数，使用 set args 不加任何参数即可。\n(gdb) set args(gdb) show argsArgument list to give program being debugged when it is started is \"\".(gdb)\ntbreak 命令tbreak 命令也是添加一个断点，第一个字母“t”的意思是 temporarily（临时的），也就是说这个命令加的断点是临时的，所谓临时断点，就是一旦该断点触发一次后就会自动删除。添加断点的方法与上面介绍的 break 命令一模一样，这里不再赘述。\n(gdb) tbreak mainTemporary breakpoint 1 at 0x423450: file server.c, line 3704.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-4.0.9/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Temporary breakpoint 1, main (argc=1, argv=0x7fffffffe588) at server.c:37043704    int main(int argc, char **argv) {(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-4.0.9/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".21652:C 14 Sep 07:05:39.288 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo21652:C 14 Sep 07:05:39.288 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=21652, just started21652:C 14 Sep 07:05:39.288 # Warning: no config file specified, using the default config. In order to specify a config file use /root/redis-4.0.9/src/redis-server /path/to/redis.conf21652:M 14 Sep 07:05:39.289 * Increased maximum number of open files to 10032 (it was originally set to 1024).[New Thread 0x7ffff07ff700 (LWP 21653)][New Thread 0x7fffefffe700 (LWP 21654)][New Thread 0x7fffef7fd700 (LWP 21655)]                _._           _.-``__ ''-._      _.-``    `.  `_.  ''-._           Redis 4.0.9 (00000000/0) 64 bit  .-`` .-```.  ```\\/    _.,_ ''-._ (    '      ,       .-`  | `,    )     Running in standalone mode |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379 |    `-._   `._    /     _.-'    |     PID: 21652  `-._    `-._  `-./  _.-'    _.-' |`-._`-._    `-.__.-'    _.-'_.-'| |    `-._`-._        _.-'_.-'    |           http://redis.io  `-._    `-._`-.__.-'_.-'    _.-' |`-._`-._    `-.__.-'    _.-'_.-'| |    `-._`-._        _.-'_.-'    |\n上述代码，我们使用 tbreak 命令在 main() 函数处添加了一个断点，当断点触发后，再次运行程序不再触发断点，因为这个临时断点已经被删除。\nwatch 命令watch 命令是一个强大的命令，它可以用来监视一个变量或者一段内存，当这个变量或者该内存处的值发生变化时，GDB 就会中断下来。被监视的某个变量或者某个内存地址会产生一个 watch point（观察点）。\n我在数年前去北京中关村软件园应聘一个 C++ 开发的职位，当时一个面试官问了这样一个问题：有一个变量其值被意外地改掉了，通过单步调试或者挨个检查使用该变量的代码工作量会非常大，如何快速地定位到该变量在哪里被修改了？其实，面试官想要的答案是“硬件断点”。具体什么是硬件断点，我将在后面高级调试课程中介绍，而 watch 命令就可以通过添加硬件断点来达到监视数据变化的目的。watch 命令的使用方式是“watch 变量名或内存地址”，一般有以下几种形式：\n\n形式一：整型变量int i;watch i\n形式二：指针类型char *p;watch p 与 watch *p\n\n注意：watch p 与 watch *p 是有区别的，前者是查看 *(&amp;p)，是 p 变量本身；后者是 p 所指内存的内容。我们需要查看地址，因为目的是要看某内存地址上的数据是怎样变化的。\n\n\n形式三：watch 一个数组或内存区间char buf[128];watch buf\n\n这里是对 buf 的 128 个数据进行了监视，此时不是采用硬件断点，而是用软中断实现的。用软中断方式去检查内存变量是比较耗费 CPU 资源的，精确地指明地址是硬件中断。\n\n注意：当设置的观察点是一个局部变量时，局部变量无效后，观察点也会失效。在观察点失效时 GDB 可能会提示如下信息：\nWatchpoint 2 deleted because the program has left the block in which its expression is valid.\n\ndisplay 命令display 命令监视的变量或者内存地址，每次程序中断下来都会自动输出这些变量或内存的值。例如，假设程序有一些全局变量，每次断点停下来我都希望 GDB 可以自动输出这些变量的最新值，那么使用“display 变量名”设置即可。\nProgram received signal SIGINT, Interrupt.0x00007ffff71e2483 in epoll_wait () from /lib64/libc.so.6(gdb) display $ebx1: $ebx = 7988560(gdb) display /x $ebx2: /x $ebx = 0x79e550(gdb) display $eax3: $eax = -4(gdb) b mainBreakpoint 8 at 0x4201f0: file server.c, line 4003.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-5.0.3/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 8, main (argc=1, argv=0x7fffffffe4e8) at server.c:40034003    int main(int argc, char **argv) {3: $eax = 43258722: /x $ebx = 0x01: $ebx = 0(gdb)\n上述代码中，我使用 display 命令分别添加了寄存器 ebp 和寄存器 eax，ebp 寄存器分别使用十进制和十六进制两种形式输出其值，这样每次程序中断下来都会自动把这些值打印出来，可以使用 info display 查看当前已经自动添加了哪些值，使用 delete display 清除全部需要自动输出的变量，使用 delete diaplay 编号 删除某个自动输出的变量。\n(gdb) delete displayDelete all auto-display expressions? (y or n) n(gdb) delete display 3(gdb) info displayAuto-display expressions now in effect:Num Enb Expression2:   y  $ebp1:   y  $eax\n小结到目前为止已把 GDB 常用的命令都介绍完了，不知道读者是否能记得每一个命令的用途和用法？只要理解了，记忆它们其实也不难，这些基础命令，希望读者能熟练掌握。\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"GDB 实用调试技巧（上）","url":"/2021/10/11/GDB-4/","content":"音乐小港\n    \n\n\nGDB 实用调试技巧（上）本节课的核心内容：\n\n将 print 打印结果显示完整\n让被 GDB 调试的程序接收信号\n函数明明存在，添加断点时却无效\n\n将 print 打印结果显示完整当使用 print 命令打印一个字符串或者字符数组时，如果该字符串太长，print 命令默认显示不全的，我们可以通过在 GDB 中输入 set print element 0 命令设置一下，这样再次使用 print 命令就能完整地显示该变量的所有字符串了。\nvoid ChatSession::OnGetFriendListResponse(const std::shared_ptr&lt;TcpConnection&gt;&amp; conn){    std::string friendlist;    MakeUpFriendListInfo(friendlist, conn);    std::ostringstream os;    os &lt;&lt; \"{\\\"code\\\": 0, \\\"msg\\\": \\\"ok\\\", \\\"userinfo\\\":\" &lt;&lt; friendlist &lt;&lt; \"}\";    Send(msg_type_getofriendlist, m_seq, os.str());    LOG_INFO &lt;&lt; \"Response to client: userid=\" &lt;&lt; m_userinfo.userid &lt;&lt; \", cmd=msg_type_getofriendlist, data=\" &lt;&lt; os.str();    }\n以上代码中，当第一次打印 friendlist 这个变量值时，只能显示部分字符串。使用 set print element 0 设置以后就能完整地显示出来了。\n(gdb) n563         os &lt;&lt; \"{\\\"code\\\": 0, \\\"msg\\\": \\\"ok\\\", \\\"userinfo\\\":\" &lt;&lt; friendlist &lt;&lt; \"}\";(gdb) p friendlist$1 = \"[{\\\"members\\\":[{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":2,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"bj_man\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":4,\"...(gdb) set print element 0(gdb) p friendlist       $2 = \"[{\\\"members\\\":[{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":2,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"bj_man\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":4,\\\"username\\\":\\\"13811411052\\\"},{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":0,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"Half\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":5,\\\"username\\\":\\\"15618326596\\\"},{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":34,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"云淡风轻\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":7,\\\"username\\\":\\\"china001\\\"},{\\\"address\\\":\\\"上海市浦东新区南泉路1200号409室\\\",\\\"birthday\\\":20170914,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":5,\\\"gender\\\":0,\\\"mail\\\":\\\"balloonwj@qq.com\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"qqq123\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"{“id”：12}\\\",\\\"status\\\":0,\\\"userid\\\":10,\\\"username\\\":\\\"qqq\\\"},{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"be19574dcdd11fb9a96cf00f7e5f0e66\\\",\\\"facetype\\\":0,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"TzdnerC\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":15,\\\"username\\\":\\\"TzdnerC\\\"},{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0,\\\"customface\\\":\\\"\\\",\\\"facetype\\\":0,\\\"gender\\\":0,\\\"mail\\\":\\\"\\\",\\\"markname\\\":\\\"\\\",\\\"nickname\\\":\\\"Barry\\\",\\\"phonenumber\\\":\\\"\\\",\\\"signature\\\":\\\"\\\",\\\"status\\\":0,\\\"userid\\\":16,\\\"username\\\":\\\"17091203068\\\"},{\\\"address\\\":\\\"\\\",\\\"birthday\\\":19900101,\\\"clienttype\\\":0...太长了，这里省略...\n\n让被 GDB 调试的程序接收信号请看下面的代码：\nvoid prog_exit(int signo){    std::cout &lt;&lt; \"program recv signal [\" &lt;&lt; signo &lt;&lt; \"] to exit.\" &lt;&lt; std::endl;}int main(int argc, char* argv[]){    //设置信号处理    signal(SIGCHLD, SIG_DFL);    signal(SIGPIPE, SIG_IGN);    signal(SIGINT, prog_exit);    signal(SIGTERM, prog_exit);    int ch;    bool bdaemon = false;    while ((ch = getopt(argc, argv, \"d\")) != -1)    {        switch (ch)        {        case 'd':            bdaemon = true;            break;        }    }    if (bdaemon)        daemon_run();    //省略无关代码... }\n在这个程序中，我们接收到 Ctrl + C 信号（对应信号 SIGINT）时会简单打印一行信息，而当用 GDB 调试这个程序时，由于 Ctrl + C 默认会被 GDB 接收到（让调试器中断下来），导致无法模拟程序接收这一信号。解决这个问题有两种方式：\n\n在 GDB 中使用 signal 函数手动给程序发送信号，这里就是 signal SIGINT；\n改变 GDB 信号处理的设置，通过 handle SIGINT nostop print 告诉 GDB 在接收到 SIGINT 时不要停止，并把该信号传递给调试目标程序 。(gdb) handle SIGINT nostop print passSIGINT is used by the debugger. Are you sure you want to change it? (y or n) y  Signal Stop Print Pass to program Description  SIGINT No Yes Yes Interrupt(gdb)\n\n函数明明存在，添加断点时却无效有时候一个函数明明存在，并且我们的程序也存在调试符号，使用 break functionName 添加断点时 GDB 却提示：\nMake breakpoint pending on future shared library load? y/n\n\n即使输入 y 命令，添加的断点可能也不会被正确地触发，此时需要改变添加断点的方式，使用该函数所在的代码文件和行号添加断点就能达到效果。\n\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"自定义 GDB 调试命令","url":"/2021/10/11/GDB-6/","content":"音乐小港\n    \n\n\n自定义 GDB 调试命令在某些场景下，我们需要根据自己的程序情况，制定一些可以在调试时输出程序特定信息的命令，这在 GDB 中很容易做到，只要在 Linux 当前用户家（home）目录下，如 root 用户是 “**/root” 目录，非 root 用户则对应 “/home/ 用户名**”目录。\n在上述目录中自定义一个名叫 .gdbinit 文件，在 Linux 系统中以点号开头的文件名一般都是隐藏文件，因此 .gdbinit 也是一个隐藏文件，可以使用 ls -a 命令查看（a 的含义是 all 的意思，即显示所有文件，当然也就包括显示隐藏文件）；如果不存在，使用 vim 或者 touch 命令创建一个就可以，然后在这个文件中写上你自定义命令的 shell 脚本即可。\n以 Apache Web 服务器的源码为例（Apache Server 的源码下载地址请点击这里），在源码根目录下有个文件叫 .gdbinit，这个就是 Apache Server 自定义的 GDB 命令：\n# gdb macros which may be useful for folks using gdb to debug# apache.  Delete it if it bothers you.define dump_table    set $t = (apr_table_entry_t *)((apr_array_header_t *)$arg0)-&gt;elts    set $n = ((apr_array_header_t *)$arg0)-&gt;nelts    set $i = 0    while $i &lt; $n    if $t[$i].val == (void *)0L       printf \"[%u] '%s'=&gt;NULL\\n\", $i, $t[$i].key    else       printf \"[%u] '%s'='%s' [%p]\\n\", $i, $t[$i].key, $t[$i].val, $t[$i].val    end    set $i = $i + 1    endend# 省略部分代码# Set sane defaults for common signals:handle SIGPIPE noprint pass nostophandle SIGUSR1 print pass nostop\n当然在这个文件的最底部，Apache 设置了让 GDB 调试器不要处理 SIGPIPE 和 SIGUSR1 这两个信号，而是将这两个信号直接传递给被调试的程序本身（即 Apache Server）。\n\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"GDB 常用命令详解（中）","url":"/2021/10/10/GDB-2/","content":"音乐小港\n    \n\n\nGDB 常用命令详解（中）本课的核心内容：\n\ninfo 和 thread 命令\nnext、step、until、finish、return 和 jump 命令\n\ninfo 和 thread 命令在前面使用 info break 命令查看当前断点时介绍过，info 命令是一个复合指令，还可以用来查看当前进程的所有线程运行情况。下面以 redis-server 进程为例来演示一下，使用 delete 命令删掉所有断点，然后使用 run 命令重启一下 redis-server，等程序正常启动后，我们按快捷键 Ctrl+C 中断程序，然后使用 info thread 命令来查看当前进程有哪些线程，分别中断在何处：\n(gdb) deleteDelete all breakpoints? (y or n) y(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/gdbtest/redis-4.0.11/src/redis-server[Thread debugging using libthread_db enabled]...省略部分无关内容...53062:M 10 Sep 17:11:10.810 * Ready to accept connections^CProgram received signal SIGINT, Interrupt.0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6(gdb) info thread  Id   Target Id         Frame  4    Thread 0x7fffef7fd700 (LWP 53065) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  3    Thread 0x7fffefffe700 (LWP 53064) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  2    Thread 0x7ffff07ff700 (LWP 53063) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0* 1    Thread 0x7ffff7fec780 (LWP 53062) \"redis-server\" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6\n通过 info thread 的输出可以知道 redis-server 正常启动后，一共产生了 4 个线程，包括一个主线程和三个工作线程，线程编号（Id 那一列）分别是 4、3、2、1。三个工作线程（2、3、4）分别阻塞在 Linux API pthread_cond_wait 处，而主线程（1）阻塞在 epoll_wait 处。\n\n注意：虽然第一栏的名称叫 Id，但第一栏的数值不是线程的 Id，第三栏括号里的内容（如 LWP 53065）中，53065 这样的数值才是当前线程真正的 Id。那 LWP 是什么意思呢？在早期的 Linux 系统的内核里面，其实不存在真正的线程实现，当时所有的线程都是用进程来实现的，这些模拟线程的进程被称为 Light Weight Process（轻量级进程），后来 Linux 系统有了真正的线程实现，这个名字仍然被保留了下来。\n\n读者可能会有疑问：怎么知道线程 1 就是主线程？线程 2、线程 3、线程 4 就是工作线程呢？是不是因为线程 1 前面有个星号（*）？错了，线程编号前面这个星号表示的是当前 GDB 作用于哪个线程，而不是主线程的意思。现在有 4 个线程，也就有 4 个调用堆栈，如果此时输入 backtrace 命令查看调用堆栈，由于当前 GDB 作用在线程 1，因此 backtrace 命令显示的一定是线程 1 的调用堆栈：\n(gdb) bt#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6#1  0x00000000004265df in aeApiPoll (tvp=0x7fffffffe300, eventLoop=0x7ffff08350a0) at ae_epoll.c:112#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411#3  0x0000000000426aeb in aeMain (eventLoop=0x7ffff08350a0) at ae.c:501#4  0x00000000004238ef in main (argc=1, argv=0x7fffffffe648) at server.c:3899\n由此可见，堆栈 #4 的 main() 函数也证实了上面的说法，即线程编号为 1 的线程是主线程。\n如何切换到其他线程呢？可以通过“thread 线程编号”切换到具体的线程上去。例如，想切换到线程 2 上去，只要输入 thread 2 即可，然后输入 bt 就能查看这个线程的调用堆栈了：\n(gdb) info thread  Id   Target Id         Frame  4    Thread 0x7fffef7fd700 (LWP 53065) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  3    Thread 0x7fffefffe700 (LWP 53064) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  2    Thread 0x7ffff07ff700 (LWP 53063) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0* 1    Thread 0x7ffff7fec780 (LWP 53062) \"redis-server\" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6(gdb) thread 2[Switching to thread 2 (Thread 0x7ffff07ff700 (LWP 53063))]#0  0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0(gdb) bt#0  0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0#1  0x000000000047a91c in bioProcessBackgroundJobs (arg=0x0) at bio.c:176#2  0x00007ffff76c0e25 in start_thread () from /lib64/libpthread.so.0#3  0x00007ffff73ee34d in clone () from /lib64/libc.so.6\n因此利用 info thread 命令就可以调试多线程程序，当然用 GDB 调试多线程程序还有一个很麻烦的问题，我们将在后面的 GDB 高级调试技巧中介绍。请注意，当把 GDB 当前作用的线程切换到线程 2 上之后，线程 2 前面就被加上了星号：\n(gdb) info thread  Id   Target Id         Frame  4    Thread 0x7fffef7fd700 (LWP 53065) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  3    Thread 0x7fffefffe700 (LWP 53064) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0* 2    Thread 0x7ffff07ff700 (LWP 53063) \"redis-server\" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0  1    Thread 0x7ffff7fec780 (LWP 53062) \"redis-server\" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6\ninfo 命令还可以用来查看当前函数的参数值，组合命令是 info args，我们找个函数值多一点的堆栈函数来试一下：\n(gdb) thread 1[Switching to thread 1 (Thread 0x7ffff7fec780 (LWP 53062))]#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6(gdb) bt#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6#1  0x00000000004265df in aeApiPoll (tvp=0x7fffffffe300, eventLoop=0x7ffff08350a0) at ae_epoll.c:112#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411#3  0x0000000000426aeb in aeMain (eventLoop=0x7ffff08350a0) at ae.c:501#4  0x00000000004238ef in main (argc=1, argv=0x7fffffffe648) at server.c:3899(gdb) f 2#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411411             numevents = aeApiPoll(eventLoop, tvp);(gdb) info argseventLoop = 0x7ffff08350a0flags = 11(gdb)\n上述代码片段切回至主线程 1，然后切换到堆栈 #2，堆栈 #2 调用处的函数是 aeProcessEvents() ，一共有两个参数，使用 info args 命令可以输出当前两个函数参数的值，参数 eventLoop 是一个指针类型的参数，对于指针类型的参数，GDB 默认会输出该变量的指针地址值，如果想输出该指针指向对象的值，在变量名前面加上 * 解引用即可，这里使用 p *eventLoop 命令：\n(gdb) p *eventLoop$26 = {maxfd = 11, setsize = 10128, timeEventNextId = 1, lastTime = 1536570672, events = 0x7ffff0871480, fired = 0x7ffff08c2e40, timeEventHead = 0x7ffff0822080,  stop = 0, apidata = 0x7ffff08704a0, beforesleep = 0x429590 &lt;beforeSleep&gt;, aftersleep = 0x4296d0 &lt;afterSleep&gt;}\n如果还要查看其成员值，继续使用 变量名 -&gt;字段名 即可，在前面学习 print 命令时已经介绍过了，这里不再赘述。\n上面介绍的是 info 命令最常用的三种方法，更多关于 info 的组合命令在 GDB 中输入 help info 就可以查看：\n(gdb) help infoGeneric command for showing things about the program being debugged.List of info subcommands:info address -- Describe where symbol SYM is storedinfo all-registers -- List of all registers and their contentsinfo args -- Argument variables of current stack frameinfo auto-load -- Print current status of auto-loaded filesinfo auto-load-scripts -- Print the list of automatically loaded Python scriptsinfo auxv -- Display the inferior's auxiliary vectorinfo bookmarks -- Status of user-settable bookmarksinfo breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)info checkpoints -- IDs of currently known checkpointsinfo classes -- All Objective-C classesinfo common -- Print out the values contained in a Fortran COMMON blockinfo copying -- Conditions for redistributing copies of GDBinfo dcache -- Print information on the dcache performanceinfo display -- Expressions to display when program stopsinfo extensions -- All filename extensions associated with a source languageinfo files -- Names of targets and files being debuggedinfo float -- Print the status of the floating point unitinfo frame -- All about selected stack frameinfo frame-filter -- List all registered Python frame-filtersinfo functions -- All function namesinfo handle -- What debugger does when program gets various signalsinfo inferiors -- IDs of specified inferiors (all inferiors if no argument)info line -- Core addresses of the code for a source lineinfo locals -- Local variables of current stack frameinfo macro -- Show the definition of MACROinfo macros -- Show the definitions of all macros at LINESPECinfo mem -- Memory region attributesinfo os -- Show OS data ARGinfo pretty-printer -- GDB command to list all registered pretty-printersinfo probes -- Show available static probesinfo proc -- Show /proc process information about any running processinfo program -- Execution status of the programinfo record -- Info record optionsinfo registers -- List of integer registers and their contentsinfo scope -- List the variables local to a scope---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---info selectors -- All Objective-C selectorsinfo set -- Show all GDB settingsinfo sharedlibrary -- Status of loaded shared object librariesinfo signals -- What debugger does when program gets various signalsinfo skip -- Display the status of skipsinfo source -- Information about the current source fileinfo sources -- Source files in the programinfo stack -- Backtrace of the stackinfo static-tracepoint-markers -- List target static tracepoints markersinfo symbol -- Describe what symbol is at location ADDRinfo target -- Names of targets and files being debuggedinfo tasks -- Provide information about all known Ada tasksinfo terminal -- Print inferior's saved terminal statusinfo threads -- Display currently known threadsinfo tracepoints -- Status of specified tracepoints (all tracepoints if no argument)info tvariables -- Status of trace state variables and their valuesinfo type-printers -- GDB command to list all registered type-printersinfo types -- All type namesinfo variables -- All global and static variable namesinfo vector -- Print the status of the vector unitinfo vtbl -- Show the virtual function table for a C++ objectinfo warranty -- Various kinds of warranty you do not haveinfo watchpoints -- Status of specified watchpoints (all watchpoints if no argument)info win -- List of all displayed windowsType \"help info\" followed by info subcommand name for full documentation.Type \"apropos word\" to search for commands related to \"word\".Command name abbreviations are allowed if unambiguous.\nnext、step、until、finish、return 和 jump 命令这几个命令是我们用 GDB 调试程序时最常用的几个控制流命令，因此放在一起介绍。next 命令（简写为 n）是让 GDB 调到下一条命令去执行，这里的下一条命令不一定是代码的下一行，而是根据程序逻辑跳转到相应的位置。举个例子：\nint a = 0;if (a == 9){    print(\"a is equal to 9.\\n\");}int b = 10;print(\"b = %d.\\n\", b);\n如果当前 GDB 中断在上述代码第 2 行，此时输入 next 命令 GDB 将调到第 7 行，因为这里的 if 条件并不满足。\n这里有一个小技巧，在 GDB 命令行界面如果直接按下回车键，默认是将最近一条命令重新执行一遍，因此，当使用 next 命令单步调试时，不必反复输入 n 命令，直接回车就可以了。\n3704    int main(int argc, char **argv) {(gdb) n3736        spt_init(argc, argv);(gdb) n3738        setlocale(LC_COLLATE,\"\");(gdb) n3739        zmalloc_set_oom_handler(redisOutOfMemoryHandler);(gdb) n3740        srand(time(NULL)^getpid());(gdb) n3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));(gdb) n3740        srand(time(NULL)^getpid());(gdb) n3741        gettimeofday(&amp;tv,NULL);(gdb) n3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));(gdb)\n上面的执行过程等价于输入第一个 n 后直接回车：\n(gdb) n3736        spt_init(argc, argv);(gdb)3738        setlocale(LC_COLLATE,\"\");(gdb)3739        zmalloc_set_oom_handler(redisOutOfMemoryHandler);(gdb)3740        srand(time(NULL)^getpid());(gdb)3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));(gdb)\nnext 命令用调试的术语叫“单步步过”（step over），即遇到函数调用直接跳过，不进入函数体内部。而下面的 step 命令（简写为 s）就是“单步步入”（step into），顾名思义，就是遇到函数调用，进入函数内部。举个例子，在 redis-server 的 main() 函数中有个叫 spt_init(argc, argv) 的函数调用，当我们停在这一行时，输入 s 将进入这个函数内部。\n//为了说明问题本身，除去不相关的干扰，代码有删减int main(int argc, char **argv) {    struct timeval tv;    int j;    /* We need to initialize our libraries, and the server configuration. */    spt_init(argc, argv);    setlocale(LC_COLLATE,\"\");    zmalloc_set_oom_handler(redisOutOfMemoryHandler);    srand(time(NULL)^getpid());    gettimeofday(&amp;tv,NULL);    char hashseed[16];    getRandomHexChars(hashseed,sizeof(hashseed));    dictSetHashFunctionSeed((uint8_t*)hashseed);    server.sentinel_mode = checkForSentinelMode(argc,argv);    initServerConfig();    moduleInitModulesSystem();    //省略部分无关代码... }\n演示一下，先使用 b main 命令在 main() 处加一个断点，然后使用 r 命令重新跑一下程序，会触发刚才加在 main() 函数处的断点，然后使用 n 命令让程序走到 spt_init(argc, argv) 函数调用处，再输入 s 命令就可以进入该函数了：\n(gdb) b mainBreakpoint 3 at 0x423450: file server.c, line 3704.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-4.0.9/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 3, main (argc=1, argv=0x7fffffffe588) at server.c:37043704    int main(int argc, char **argv) {(gdb) n3736        spt_init(argc, argv);(gdb) sspt_init (argc=argc@entry=1, argv=argv@entry=0x7fffffffe588) at setproctitle.c:152152     void spt_init(int argc, char *argv[]) {(gdb) l147148             return 0;149     } /* spt_copyargs() */150151152     void spt_init(int argc, char *argv[]) {153             char **envp = environ;154             char *base, *end, *nul, *tmp;155             int i, error;156(gdb)\n说到 step 命令，还有一个需要注意的地方，就是当函数的参数也是函数调用时，我们使用 step 命令会依次进入各个函数，那么顺序是什么呢？举个例子，看下面这段代码：\n1  int func1(int a, int b)2  {3     int c = a + b;4     c += 2;5     return c;6  }78  int func2(int p, int q)9  {10    int t = q * p;11       return t * t;12 }1314 int func3(int m, int n)15 {16    return m + n;17 }1819 int main()20 {21    int c;22    c = func3(func1(1, 2),  func2(8, 9));23    printf(\"c=%d.\\n\", c);24    return 0;25 }\n上述代码，程序入口是 main() 函数，在第 22 行 func3 使用 func1 和 func2 的返回值作为自己的参数，在第 22 行输入 step 命令，会先进入哪个函数呢？这里就需要补充一个知识点了—— 函数调用方式，我们常用的函数调用方式有 _cdecl 和 _stdcall，C++ 非静态成员函数的调用方式是 _thiscall 。在这些调用方式中，函数参数的传递本质上是函数参数的入栈过程，而这三种调用方式参数的入栈顺序都是从右往左的，因此，这段代码中并没有显式标明函数的调用方式，采用默认 _cdecl 方式。\n当我们在第 22 行代码处输入 step 先进入的是 func2() ，当从 func2() 返回时再次输入 step 命令会接着进入 func1() ，当从 func1 返回时，此时两个参数已经计算出来了，这时候会最终进入 func3() 。理解这一点，在遇到这样的代码时，才能根据需要进入我们想要的函数中去调试。\n实际调试时，我们在某个函数中调试一段时间后，不需要再一步步执行到函数返回处，希望直接执行完当前函数并回到上一层调用处，就可以使用 finish 命令。与 finish 命令类似的还有 return 命令，return 命令的作用是结束执行当前函数，还可以指定该函数的返回值。\n这里需要注意一下二者的区别：finish 命令会执行函数到正常退出该函数；而 return 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。我们用一个例子来验证一下：\n1  #include &lt;stdio.h&gt;23  int func()4  {5     int a = 9;6     printf(\"a=%d.\\n\", a);78     int b = 8;9     printf(\"b=%d.\\n\", b);10    return a + b;11 }1213 int main()14 {15    int c = func();16    printf(\"c=%d.\\n\", c);1718    return 0;19 }\n在 main() 函数处加一个断点，然后运行程序，在第 15 行使用 step 命令进入 func() 函数，接着单步到代码第 8 行，直接输入 return 命令，这样 func() 函数剩余的代码就不会继续执行了，因此 printf(“b=%d.\\n”, b); 这一行就没有输出。同时由于我们没有在 return 命令中指定这个函数的返回值，因而最终在 main() 函数中得到的变量 c 的值是一个脏数据。这也就验证了我们上面说的：return 命令在当前位置立即结束当前函数的执行，并返回到上一层调用。\n(gdb) b mainBreakpoint 1 at 0x40057d: file test.c, line 15.(gdb) rStarting program: /root/testreturn/testBreakpoint 1, main () at test.c:1515          int c = func();Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64(gdb) sfunc () at test.c:55           int a = 9;(gdb) n6           printf(\"a=%d.\\n\", a);(gdb) na=9.8           int b = 8;(gdb) returnMake func return now? (y or n) y#0  0x0000000000400587 in main () at test.c:1515          int c = func();(gdb) n16          printf(\"c=%d.\\n\", c);(gdb) nc=-134250496.18          return 0;(gdb)\n再次用 return 命令指定一个值试一下，这样得到变量 c 的值应该就是我们指定的值。\n(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/testreturn/testBreakpoint 1, main () at test.c:1515          int c = func();(gdb) sfunc () at test.c:55           int a = 9;(gdb) n6           printf(\"a=%d.\\n\", a);(gdb) na=9.8           int b = 8;(gdb) return 9999Make func return now? (y or n) y#0  0x0000000000400587 in main () at test.c:1515          int c = func();(gdb) n16          printf(\"c=%d.\\n\", c);(gdb) nc=9999.18          return 0;(gdb) p c$1 = 9999(gdb)\n仔细观察上述代码应该会发现，用 return 命令修改了函数的返回值，当使用 print 命令打印 c 值的时候，c 值也确实被修改成了 9999。\n我们再对比一下使用 finish 命令来结束函数执行的结果。\n(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/testreturn/test Breakpoint 1, main () at test.c:1515          int c = func();(gdb) sfunc () at test.c:55           int a = 9;(gdb) n6           printf(\"a=%d.\\n\", a);(gdb) na=9.8           int b = 8;(gdb) finishRun till exit from #0  func () at test.c:8b=8.0x0000000000400587 in main () at test.c:1515          int c = func();Value returned is $3 = 17(gdb) n16          printf(\"c=%d.\\n\", c);(gdb) nc=17.18          return 0;(gdb)\n结果和我们预期的一样，finish 正常结束函数，剩余的代码也会被正常执行。因此 c 的值是 17。\n实际调试时，还有一个 until 命令（简写为 u）可以指定程序运行到某一行停下来，还是以 redis-server 的代码为例：\n1812    void initServer(void) {1813        int j;18141815        signal(SIGHUP, SIG_IGN);1816        signal(SIGPIPE, SIG_IGN);1817        setupSignalHandlers();18181819        if (server.syslog_enabled) {1820            openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,1821                server.syslog_facility);1822        }18231824        server.pid = getpid();1825        server.current_client = NULL;1826        server.clients = listCreate();1827        server.clients_to_close = listCreate();1828        server.slaves = listCreate();1829        server.monitors = listCreate();1830        server.clients_pending_write = listCreate();1831        server.slaveseldb = -1; /* Force to emit the first SELECT command. */1832        server.unblocked_clients = listCreate();1833        server.ready_keys = listCreate();1834        server.clients_waiting_acks = listCreate();1835        server.get_ack_from_slaves = 0;1836        server.clients_paused = 0;1837        server.system_memory_size = zmalloc_get_memory_size();18381839        createSharedObjects();1840        adjustOpenFilesLimit();1841        server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);1842        if (server.el == NULL) {1843            serverLog(LL_WARNING,1844                \"Failed creating the event loop. Error message: '%s'\",1845                strerror(errno));1846            exit(1);1847        }\n这是 redis-server 代码中 initServer() 函数的一个代码片段，位于文件 server.c 中，当停在第 1813 行，想直接跳到第 1839 行，可以直接输入 u 1839，这样就能快速执行完中间的代码。当然，也可以先在第 1839 行加一个断点，然后使用 continue 命令运行到这一行，但是使用 until 命令会更简便。\n(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-4.0.9/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 3, main (argc=1, argv=0x7fffffffe588) at server.c:37043704    int main(int argc, char **argv) {(gdb) cContinuing.21574:C 14 Sep 06:42:36.978 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo21574:C 14 Sep 06:42:36.978 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=21574, just started21574:C 14 Sep 06:42:36.979 # Warning: no config file specified, using the default config. In order to specify a config file use /root/redis-4.0.9/src/redis-server /path/to/redis.confBreakpoint 4, initServer () at server.c:18121812    void initServer(void) {(gdb) n1815        signal(SIGHUP, SIG_IGN);(gdb) u 1839initServer () at server.c:18391839        createSharedObjects();(gdb)\njump 命令基本用法是：jump &lt;location&gt;\nlocation 可以是程序的行号或者函数的地址，jump 会让程序执行流跳转到指定位置执行，当然其行为也是不可控制的，例如您跳过了某个对象的初始化代码，直接执行操作该对象的代码，那么可能会导致程序崩溃或其他意外行为。jump 命令可以简写成 j，但是不可以简写成 jmp，其使用有一个注意事项，即如果 jump 跳转到的位置后续没有断点，那么 GDB 会执行完跳转处的代码会继续执行。举个例子：\n1 int somefunc()2 {3   //代码A4   //代码B5   //代码C6   //代码D7   //代码E8   //代码F9 }\n假设我们的断点初始位置在行号 3 处（代码 A），这个时候我们使用 jump 6，那么程序会跳过代码 B 和 C 的执行，执行完代码 D（ 跳转点），程序并不会停在代码 6 处，而是继续执行后续代码，因此如果我们想查看执行跳转处的代码后的结果，需要在行号 6、7 或 8 处设置断点。\njump 命令除了跳过一些代码的执行外，还有一个妙用就是可以执行一些我们想要执行的代码，而这些代码在正常的逻辑下可能并不会执行（当然可能也因此会产生一些意外的结果，这需要读者自行斟酌使用）。举个例子，假设现在有如下代码：\n1  #include &lt;stdio.h&gt;2  int main()3  {4    int a = 0;5    if (a != 0)6    {7      printf(\"if condition\\n\");8    }9    else10   {11     printf(\"else condition\\n\");12   }1314   return 0;15 }\n我们在行号 4 、14 处设置一个断点，当触发行号 4 处的断点后，正常情况下程序执行流会走 else 分支，我们可以使用 jump 7 强行让程序执行 if 分支，接着 GDB 会因触发行号 14 处的断点而停下来，此时我们接着执行 jump 11，程序会将 else 分支中的代码重新执行一遍。整个操作过程如下：\n[root@localhost testcore]# gdb testReading symbols from /root/testcore/test...done.(gdb) b mainBreakpoint 1 at 0x400545: file main.cpp, line 4.(gdb) b 14Breakpoint 2 at 0x400568: file main.cpp, line 14.(gdb) rStarting program: /root/testcore/testBreakpoint 1, main () at main.cpp:44       int a = 0;Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64(gdb) jump 7Continuing at 0x400552.if conditionBreakpoint 2, main () at main.cpp:1414       return 0;(gdb) jump 11Continuing at 0x40055e.else conditionBreakpoint 2, main () at main.cpp:1414       return 0;(gdb) cContinuing.[Inferior 1 (process 13349) exited normally](gdb)\nredis-server 在入口函数 main 处调用 initServer() ，我们使用 “b initServer” 、“b 2025”、“b 2027”在这个函数入口处、2025 行、2027 行增加三个断点，然后使用 run 命令重新运行一下程序，触发第一个断点后，继续输入 c 命令继续运行，然后触发 2025 行处的断点，接着输入 jump 2027 ：\n(gdb) b 2025Breakpoint 5 at 0x42c8e7: file server.c, line 2025.(gdb) b 2027Breakpoint 6 at 0x42c8f8: file server.c, line 2027.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) nProgram not restarted.(gdb) b initServerNote: breakpoint 3 also set at pc 0x42c8b0.Breakpoint 7 at 0x42c8b0: file server.c, line 2013.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/redis-5.0.3/src/redis-server[Thread debugging using libthread_db enabled]Using host libthread_db library \"/lib64/libthread_db.so.1\".Breakpoint 1, main (argc=1, argv=0x7fffffffe4e8) at server.c:40034003    int main(int argc, char **argv) {(gdb) cContinuing.13374:C 14 Jan 2019 15:12:16.571 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo13374:C 14 Jan 2019 15:12:16.571 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=13374, just started13374:C 14 Jan 2019 15:12:16.571 # Warning: no config file specified, using the default config. In order to specify a config file use /root/redis-5.0.3/src/redis-server /path/to/redis.confBreakpoint 3, initServer () at server.c:20132013    void initServer(void) {(gdb) cContinuing.Breakpoint 5, initServer () at server.c:20252025        server.hz = server.config_hz;(gdb) jump 2027Continuing at 0x42c8f8.Breakpoint 6, initServer () at server.c:20272027        server.current_client = NULL;(gdb)\n程序将 2026 行的代码跳过了，2026 行处的代码是获取当前进程 id：\n2026 server.pid = getpid();\n由于这一行被跳过了，所以 server.pid 的值应该是一个无效的值，我们可以使用 print 命令将这个值打印出来看一下：\n(gdb) p server.pid$3 = 0\n结果确实是 0 这个我们初始化的无效值。\n\n本质上，jump 命令的作用类似于在 Visual Studio 中调试时，拖鼠标将程序从一个执行处拖到另外一个执行处。\n\n\n小结本节课介绍了 info thread、next、step、until、finish、 return 和 jump 命令，这些也是 GDB 调试过程中非常常用的命令，请读者务必掌握。\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"GDB TUI——在 GDB 中显示程序源码","url":"/2021/10/11/GDB-7/","content":"音乐小港\n    \n\n\nGDB TUI——在 GDB 中显示程序源码很多 Linux 用户或者其他平台用户习惯了有强大的源码显示窗口的调试器，可能对 GDB 用 list 显示源码的方式非常不习惯，主要是因为 GDB 在调试的时候不能很好地展示源码。\nGDB 中可以用 list 命令显示源码，但是 list 命令显示没有代码高亮，也不能一眼定位到正在执行的那行代码在整个代码中的位置。可以毫不夸张地说，这个问题是阻止很多人长期使用 GDB 的最大障碍，如此不便，以至于 GNU 都想办法解决了——使用 GDB 自带的 GDB TUI。\n先来看一张效果图，是我在使用 GDB TUI 调试 redis-server 时的截图，这样看代码比使用 list 命令更方便。\n\n开启 GDB TUI 模式开启 GDB TUI 模式有两个方法。\n方法一：使用 gdbtui 命令或者 gdb-tui 命令开启一个调试。\ngdbtui -q 需要调试的程序名\n方法二：直接使用 GDB 调试代码，在需要的时候使用切换键 Ctrl + X + A 调出 GDB TUI 。\nGDB TUI 模式常用窗口\n默认情况下，GDB TUI 模式会显示 command 窗口和 source 窗口，如上图所示，还有其他窗口，如下列举的四个常用的窗口：\n\n（cmd）command 命令窗口，可以输入调试命令\n（src）source 源代码窗口， 显示当前行、断点等信息\n（asm）assembly 汇编代码窗口\n（reg）register 寄存器窗口可以通过“layout + 窗口类型”命令来选择自己需要的窗口，例如，在 cmd 窗口输入 layout asm 则可以切换到汇编代码窗口。\n\n\nlayout 命令还可以用来修改窗口布局，在 cmd 窗口中输入 help layout，常见的有：\nUsage: layout prev | next | &lt;layout_name&gt; Layout names are:   src   : Displays source and command windows.   asm   : Displays disassembly and command windows.   split : Displays source, disassembly and command windows.   regs  : Displays register window. If existing layout           is source/command or assembly/command, the            register window is displayed. If the           source/assembly/command (split) is displayed,            the register window is displayed with            the window that has current logical focus.\n另外，可以通过 winheight 命令修改各个窗口的大小，如下所示：\n(gdb) help winheightSet the height of a specified window.Usage: winheight &lt;win_name&gt; [+ | -] &lt;#lines&gt;Window names are:src  : the source windowcmd  : the command windowasm  : the disassembly windowregs : the register display##将代码窗口的高度扩大 5 行代码winheight src + 5##将代码窗口的高度减小 4 代码winheight src - 4\n当前 GDB TUI 窗口放大或者缩小以后，窗口中的内容不会自己刷新以适应新的窗口尺寸，我们可以通过 space 键强行刷新 GDB TUI 窗口。\n窗口焦点切换在默认设置下，方向键和 PageUp/PageDown 都是用来控制 GDB TUI 的 src 窗口的，因此，我们常用上下键显示前一条命令和后一条命令的功能就没有了，不过可以通过 Ctrl + N/Ctrl + P 来获取这个功能。\n\n注意：通过方向键调整了GDB TUI 的 src 窗口以后，可以用 update 命令重新把焦点定位到当前执行的代码上。\n\n我们可以通过 focus 命令来调整焦点位置，默认情况下焦点是在 src 窗口，通过 focus next 命令可以把焦点移到 cmd 窗口，这时候就可以像以前一样，通过方向键来切换上一条命令和下一条命令。同理，也可以使用 focus prev 切回到源码窗口，如果焦点不在 src 窗口，我们就不必使用方向键来浏览源码了。\n(gdb) help focus  help focusSet focus to named window or next/prev window.Usage: focus {&lt;win&gt; | next | prev}Valid Window names are:src  : the source windowasm  : the disassembly windowregs : the register displaycmd  : the command window\n小结GDB TUI 提供了一个可视化的代码阅读功能，比使用 list 命令来查看代码要方便不少，有兴趣的读者可以尝试一下。\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"GDB 实用调试技巧（下）","url":"/2021/10/11/GDB-5/","content":"音乐小港\n    \n\n\nGDB 实用调试技巧（下）本节课的核心内容：\n\n多线程下禁止线程切换\n条件断点\n使用 GDB 调试多进程程序\n\n多线程下禁止线程切换假设现在有 5 个线程，除了主线程，工作线程都是下面这样的一个函数：\nvoid* thread_proc(void* arg){    //代码行1    //代码行2    //代码行3    //代码行4    //代码行5    //代码行6    //代码行7    //代码行8    //代码行9    //代码行10    //代码行11    //代码行12    //代码行13    //代码行14    //代码行15}\n为了能说清楚这个问题，我们把四个工作线程分别叫做 A、B、C、D。\n假设 GDB 当前正在处于线程 A 的代码行 3 处，此时输入 next 命令，我们期望的是调试器跳到代码行 4 处；或者使用“u 代码行10”，那么我们期望输入 u 命令后调试器可以跳转到代码行 10 处。\n但是在实际情况下，GDB 可能会跳转到代码行 1 或者代码行 2 处，甚至代码行 13、代码行 14 这样的地方也是有可能的，这不是调试器 bug，这是多线程程序的特点，当我们从代码行 4 处让程序 continue 时，线程 A 虽然会继续往下执行，但是如果此时系统的线程调度将 CPU 时间片切换到线程 B、C 或者 D 呢？那么程序最终停下来的时候，处于代码行 1 或者代码行 2 或者其他地方就不奇怪了，而此时打印相关的变量值，可能就不是我们需要的线程 A 的相关值。\n为了解决调试多线程程序时出现的这种问题，GDB 提供了一个在调试时将程序执行流锁定在当前调试线程的命令：set scheduler-locking on。当然也可以关闭这一选项，使用 set scheduler-locking off。除了 on/off 这两个值选项，还有一个不太常用的值叫 step，这里就不介绍了。\n条件断点在实际调试中，我们一般会用到三种断点：普通断点、条件断点和硬件断点。\n硬件断点又叫数据断点，这样的断点其实就是前面课程中介绍的用 watch 命令添加的部分断点（为什么是部分而不是全部，前面介绍原因了，watch 添加的断点有部分是通过软中断实现的，不属于硬件断点）。硬件断点的触发时机是监视的内存地址或者变量值发生变化。\n普通断点就是除去条件断点和硬件断点以外的断点。\n下面重点来介绍一下条件断点，所谓条件断点，就是满足某个条件才会触发的断点，这里先举一个直观的例子：\nvoid do_something_func(int i){   i ++;   i = 100 * i;}int main(){   for(int i = 0; i &lt; 10000; ++i)   {      do_something_func(i);   }   return 0;}\n在上述代码中，假如我们希望当变量 i=5000 时，进入 do_something_func() 函数追踪一下这个函数的执行细节。此时可以修改代码增加一个 i=5000 的 if 条件，然后重新编译链接调试，这样显然比较麻烦，尤其是对于一些大型项目，每次重新编译链接都需要花一定的时间，而且调试完了还得把程序修改回来。\n有了条件断点就不需要这么麻烦了，添加条件断点的命令是 break [lineNo] if [condition]，其中 lineNo 是程序触发断点后需要停下的位置，condition 是断点触发的条件。这里可以写成 break 11 if i==5000，其中，11 就是调用 do_something_fun() 函数所在的行号。当然这里的行号必须是合理行号，如果行号非法或者行号位置不合理也不会触发这个断点。\n(gdb) break 11 if i==5000       Breakpoint 2 at 0x400514: file test1.c, line 10.(gdb) rThe program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /root/testgdb/test1 Breakpoint 1, main () at test1.c:99          for(int i = 0; i &lt; 10000; ++i)(gdb) cContinuing.Breakpoint 2, main () at test1.c:1111            do_something_func(i);(gdb) p i$1 = 5000\n把 i 打印出来，GDB 确实是在 i=5000 时停下来了。\n添加条件断点还有一个方法就是先添加一个普通断点，然后使用“condition 断点编号断点触发条件”这样的方式来添加。添加一下上述断点：\n(gdb) b 11Breakpoint 1 at 0x400514: file test1.c, line 11.(gdb) info bNum     Type           Disp Enb Address            What1       breakpoint     keep y   0x0000000000400514 in main at test1.c:11(gdb) condition 1 i==5000(gdb) rStarting program: /root/testgdb/test1 yBreakpoint 1, main () at test1.c:1111            do_something_func(i);Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64(gdb) p i$1 = 5000(gdb) \n同样的规则，如果断点编号不存在，也无法添加成功，GDB 会提示断点不存在：\n(gdb) condition 2 i==5000No breakpoint number 2.\n\n使用 GDB 调试多进程程序这里说的多进程程序指的是一个进程使用 Linux 系统调用 fork() 函数产生的子进程，没有相互关联的进程就是普通的 GDB 调试，不必刻意讨论。\n在实际的应用中，如有这样一类程序，如 Nginx，对于客户端的连接是采用多进程模型，当 Nginx 接受客户端连接后，创建一个新的进程来处理这一路连接上的信息来往，新产生的进程与原进程互为父子关系，那么如何用 GDB 调试这样的父子进程呢？一般有两种方法：\n\n用 GDB 先调试父进程，等子进程 fork 出来后，使用 gdb attach 到子进程上去，当然这需要重新开启一个 session 窗口用于调试，gdb attach 的用法在前面已经介绍过了；\nGDB 调试器提供了一个选项叫 follow-fork，可以使用 show follow-fork mode 查看当前值，也可以通过 set follow-fork mode 来设置是当一个进程 fork 出新的子进程时，GDB 是继续调试父进程还是子进程（取值是 child），默认是父进程（ 取值是 parent）。(gdb) show follow-fork mode     Debugger response to a program call of fork or vfork is \"parent\".(gdb) set follow-fork child(gdb) show follow-fork modeDebugger response to a program call of fork or vfork is \"child\".(gdb) \n建议读者自己写个程序，然后调用 fork() 函数去实践一下，若要想阅读和调试 Apache HTTP Server 或者 Nginx 这样的程序，这个技能是必须要掌握的。\n\n\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"高精度除法","url":"/2021/10/08/High-precision-Division/","content":"音乐小港\n    \n\n\n高精度除法题目给定两个非负整数A，B，请你计算 A / B的商和余数。\n输入格式共两行，第一行包含整数A，第二行包含整数B。\n输出格式共两行，第一行输出所求的商，第二行输出所求余数。\n数据范围的长度,一定不为\n输入样例72\n\n输出样例31\n\nAC代码#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(auto &amp;A,int &amp;b,int &amp;r){    vector&lt;int&gt; C;    r=0;    for(int i=A.size()-1;i&gt;=0;i--)    {        r=r*10+A[i];        C.push_back(r/b);        r%=b;    }    reverse(C.begin(),C.end());    while(C.size()&gt;1&amp;&amp;C.back()==0) C.pop_back();    return C;}int main(){    string a;    int b;    vector&lt;int&gt; A;    cin &gt;&gt; a&gt;&gt; b;    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');    int r=0;    auto C=div(A,b,r);    for(int i=C.size()-1;i&gt;=0;i--) cout &lt;&lt; C[i];    puts(\"\");    cout &lt;&lt; r &lt;&lt; endl;    return 0;}\n\n解题思路\n高精度除法\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"GDB 高级扩展工具——CGDB","url":"/2021/10/11/GDB-8/","content":"音乐小港\n    \n\n\nGDB 高级扩展工具——CGDB在使用 GDB 单步调试时，代码每执行一行才显示下一行，很多用惯了图形界面 IDE 调试的读者可能会觉得非常不方便，而 GDB TUI 可能看起来不错，但是存在经常花屏的问题，也让很多读者不胜其烦。那 Linux 下有没有既能在调试时动态显示当前调试处的文件代码，又能不花屏的工具呢？有的，这就是 CGDB。\nCGDB 本质上是对 GDB 做了一层“包裹”，所有在 GDB 中可以使用的命令，在 CGDB 中也可以使用。\nCGDB 的安装CGDB 的官网请点击这里查看，执行以下命令将 CGDB 压缩包下载到本地：\nwget https://cgdb.me/files/cgdb-0.7.0.tar.gz\n然后执行以下步骤解压、编译、安装：\ntar xvfz cgdb-0.7.0.tar.gzcd cgdb-0.7.0./configure makemake install\nCGDB 在编译过程中会依赖一些第三方库，如果这些库系统上不存在就会报错，安装一下就可以了。常见的错误及解决方案如下（这里以 CentOS 系统为例，使用的是 yum 安装方式，其他 Linux 版本都有对应的安装软件命令，请自行查找）。\n（1）出现错误：\nconfigure: error: CGDB requires curses.h or ncurses/curses.h to build.\n解决方案：\nyum install ncurses-devel\n（2）出现错误：\nconfigure: error: Please install makeinfo before installing\n解决方案：\nyum install texinfo\n（3）出现错误：\nconfigure: error: Please install help2man\n解决方案：\nyum install help2man\n（4）出现错误：\nconfigure: error: CGDB requires GNU readline 5.1 or greater to link.If you used --with-readline instead of using the system readline library,make sure to set the correct readline library on the linker search pathvia LD_LIBRARY_PATH or some other facility.\n解决方案：\nyum install readline-devel\n（5）出现错误：\nconfigure: error: Please install flex before installing\n解决方案：\nyum install flex\nCGDB 的使用安装成功以后，就可以使用 CGDB 了，在命令行输入 cgdb 命令启动 CGDB ，启动后界面如下：\n\n界面分为上下两部分：上部为代码窗口，显示调试过程中的代码；下部就是 GDB 原来的命令窗口。默认窗口焦点在下部的命令窗口，如果想将焦点切换到上部的代码窗口，按键盘上的 Esc 键，之后再次按字母 i 键将使焦点回到命令窗口。\n\n注意：这个“焦点窗口”的概念很重要，它决定着你当前可以操作的是上部代码窗口还是命令窗口（ 和GDB TUI 一样）。\n\n我们用 Redis 自带的客户端程序 redis-cli 为例，输入以下命令启动调试：\ncgdb redis-cli\n启动后的界面如下：\n\n然后加两个断点，如下图所示：\n\n如上图所示，我们在程序的 main ( 上图中第 2824 行 ）和第 2832 行分别加了一个断点，添加断点以后，代码窗口的行号将会以红色显示，另外有一个绿色箭头指向当前执行的行（ 这里由于在 main 函数上加了个断点，绿色箭头指向第一个断点位置 ）。单步调试并步入第 2827 行的 sdsnew() 函数调用中，可以看到代码视图中相应的代码也发生了变化，并且绿色箭头始终指向当前执行的行数：\n\n更多 CGDB 的用法可以查阅官网，也可以参考 CGDB 中文手册，点击这里可查看详情。\nCGDB 的不足之处CGDB 虽然已经比原始的 GDB 和 GDB TUI 模式在代码显示方面改进了许多，但实际使用时，CGDB 中调用 GDB 的 print 命令无法显示字符串类型中的中文字符，要么显示乱码，要么不显示，会给程序调试带来很大的困扰，这点需要注意。\n总的来说，CGDB 仍然能满足我们大多数场景下的调试，瑕不掩瑜， CGDB 在 Linux 系统中调试程序还是比 GDB 方便很多。\n\n来源:范蠡《Linux GDB 调试指南》\n","categories":["Linux GDB 调试指南"],"tags":["Linux","C++ 开发","GDB"]},{"title":"高精度加法","url":"/2021/10/08/High-precision-addition/","content":"音乐小港\n    \n\n\n高精度加法题目给定两个正整数，计算它们的和。\n输入格式共两行，每行包含一个整数。\n输出格式共一行，包含所求的和。\n数据范围整数长度\n输入样例1223\n\n输出样例35\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; add(auto &amp;a,auto &amp;b){    if(a.size()&lt;b.size()) return add(b,a);    vector &lt;int&gt; c;    int t=0;    for(int i=0;i&lt;a.size();i++)    {        t+=a[i];        if(i&lt;b.size()) t+=b[i];        c.push_back(t%10);        t/=10;    }    if(t) c.push_back(t);    return c;}int main(){    string m,n;    vector&lt;int&gt; a,b;    cin &gt;&gt; m &gt;&gt; n;    for(int i=m.size()-1;i&gt;=0;i--) a.push_back(m[i]-'0');    for(int i=n.size()-1;i&gt;=0;i--) b.push_back(n[i]-'0');    auto c=add(a,b);    for(int i=c.size()-1;i&gt;=0;i--) cout &lt;&lt; c[i];    return 0;}\n\n解题思路\n高精度加法\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"高精度乘法","url":"/2021/10/08/High-precision-multiplication/","content":"音乐小港\n    \n\n\n高精度乘法题目给定两个正整数A和B，请你计算A * B的值。\n输入格式共两行，第一行包含整数A，第二行包含整数B。\n输出格式共一行，包含A * B的值。\n数据范围的长度,\n输入样例23\n\n输出样例6\n\nAC代码#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; mul(auto &amp;A,int b){    vector&lt;int&gt; C;    for(int i=0,t=0;i&lt;A.size()||t;i++){        if(i&lt;A.size()) t+=A[i]*b;        C.push_back(t%10);        t/=10;    }    while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back();    return C;}int main(){    string a;    int b;    vector&lt;int&gt;A;    cin &gt;&gt; a&gt;&gt; b;    for(int i=a.size()-1;i&gt;=0;i--) A.push_back(a[i]-'0');    auto C=mul(A,b);    for(int i=C.size()-1;i&gt;=0;i--) cout &lt;&lt; C[i];    return 0;}\n\n解题思路\n高精度乘法\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"高精度减法","url":"/2021/10/08/High-precision-subtraction/","content":"音乐小港\n    \n\n\n高精度减法题目给定两个正整数，计算它们的差，计算结果可能为负数。\n输入格式共两行，每行包含一个整数。\n输出格式共一行，包含所求的差。\n数据范围整数长度\n输入样例3211\n\n输出样例21\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;bool cmp(auto &amp;a,auto &amp;b){    if(a.size()!=b.size()) return a.size()&gt;b.size();    else for(int i=a.size()-1;i&gt;=0;i--) if(a[i]!=b[i]) return a[i]&gt;b[i];    return true;}vector&lt;int&gt; sub(auto &amp;a,auto &amp;b){    vector &lt;int&gt; c;    int t=0;    for(int i=0;i&lt;a.size();i++)    {        t=a[i]-t;        if(i&lt;b.size()) t-=b[i];        c.push_back((t+10)%10);        if(t&lt;0) t=1;        else t=0;    }    while(c.size()&gt;1&amp;&amp;c.back()==0) c.pop_back();    return c;}int main(){    string m,n;    vector&lt;int&gt; a,b;    cin &gt;&gt; m &gt;&gt; n;    for(int i=m.size()-1;i&gt;=0;i--) a.push_back(m[i]-'0');    for(int i=n.size()-1;i&gt;=0;i--) b.push_back(n[i]-'0');    if(cmp(a,b))     {        auto c=sub(a,b);        for(int i=c.size()-1;i&gt;=0;i--) cout &lt;&lt; c[i];    }else     {        auto c=sub(b,a);        cout &lt;&lt; '-';        for(int i=c.size()-1;i&gt;=0;i--) cout &lt;&lt; c[i];    }    return 0;}\n\n解题思路\n高精度减法\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"区间合并","url":"/2021/10/13/Interval-merging/","content":"音乐小港\n    \n\n\n区间合并题目给定  个区间 ，要求合并所有有交集的区间。\n注意如果在端点处相交，也算有交集。\n输出合并完成后的区间个数。\n例如：[1,3]和[2,6]可以合并为一个区间[1,6]。\n输入格式第一行包含整数n。\n接下来n行，每行包含两个整数 l 和 r。\n输出格式共一行，包含一个整数，表示合并区间完成后的区间个数。\n数据范围,−\n输入样例51 22 45 67 87 9\n\n输出样例3\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;int n;vector&lt;PII&gt; f;int merge(auto &amp;f){    vector&lt;PII&gt; g;    int l=-2e9,r=-2e9;    for(auto item:f)    {        if(r&lt;item.x)        {            if(l!=-2e9) g.push_back({l,r});            l=item.x,r=item.y;        }        else r=max(r,item.y);    }    g.push_back({l,r});    return g.size();}int main(){    cin &gt;&gt; n;    while(n--)    {        int l,r;        cin &gt;&gt; l &gt;&gt; r;        f.push_back({l,r});    }    sort(f.begin(),f.end());    int res = merge(f);    cout &lt;&lt; res &lt;&lt; endl;    return 0;}\n\n解题思路\n区间合并\n\n\n将所有区间从小到大排序；\n若后一个区间的前项大于当前区间的后项则将当前区间保存；\n若后一个区间的前项小于或等于则当前区间的后项为两者的较后边者；\n最后一个区间无法存储，额外存储一下；\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"判断子序列","url":"/2021/10/13/Judgment-subsequence/","content":"音乐小港\n    \n\n\n判断子序列题目给定一个长度为 n 的整数序列  以及一个长度为 m 的整数序列 。\n请你判断 a 序列是否为 b 序列的子序列。\n子序列指序列的一部分项按原有次序排列而得的序列，例如序列  是序列  的一个子序列。\n输入格式第一行包含两个整数 n,m。\n第二行包含 n 个整数，表示 。\n第三行包含 m 个整数，表示 。\n输出格式如果 a 序列是 b 序列的子序列，输出一行 Yes。\n否则，输出 No。\n数据范围,\n输入样例3 51 3 51 2 3 4 5\n\n输出样例：Yes\n\nAC代码#include &lt;iostream&gt;using namespace std;int n,m;int a[100010],b[100010];bool check(int a[],int b[]){    int i=0,j=0;    while(i&lt;n&amp;&amp;j&lt;m)    {        if(a[i]==b[j]) i++,j++;        else j++;    }    return i==n;}int main(){    cin &gt;&gt; n &gt;&gt;m;    for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];    for(int i=0;i&lt;m;i++) cin &gt;&gt; b[i];    bool res=check(a,b);    if(res) puts(\"Yes\");    else puts(\"No\");    return 0;}\n\n解题思路\n双指针算法\n\n\n用两个指针分别指向两个序列，若两个序列对应相同则都向后移动，不匹配则移动原序列。\n遍历整个原序列后若存在个数等于子序列个数，代表子序列是原序列的子序列。\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"区间和","url":"/2021/10/13/Interval-sum/","content":"音乐小港\n    \n\n\n区间和题目假定有一个无限长的数轴，数轴上每个坐标上的数都是0。\n现在，我们首先进行 n 次操作，每次操作将某一位置x上的数加c。\n接下来，进行 m 次询问，每个询问包含两个整数l和r，你需要求出在区间[l, r]之间的所有数的和。\n输入格式第一行包含两个整数n和m。\n接下来 n 行，每行包含两个整数x和c。\n再接下里 m 行，每行包含两个整数l和r。\n输出格式共m行，每行输出一个询问中所求的区间内数字和。\n数据范围,,\n输入样例3 31 23 67 51 34 67 8\n\n输出样例805\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#define x first#define y secondusing namespace std;typedef pair&lt;int,int&gt; PII;int n,m;int num[300010],s[300010];vector&lt;int&gt; all;vector&lt;PII&gt; query,add;int find(int x){    int l=0,r=all.size()-1;    while(l&lt;r)    {        int mid=(l+r)&gt;&gt;1;        if(all[mid]&lt;x) l=mid+1;        else r=mid;    }    return l+1;}int main(){    cin &gt;&gt; n &gt;&gt; m;    while(n--)    {        int x,c;        cin &gt;&gt; x &gt;&gt; c;        all.push_back(x);        add.push_back({x,c});    }    while(m--)    {        int l,r;        cin &gt;&gt; l &gt;&gt;r;        all.push_back(l);        all.push_back(r);        query.push_back({l,r});    }    sort(all.begin(),all.end());    all.erase(unique(all.begin(),all.end()),all.end());    for(auto item:add)    {        int idx=find(item.x);        num[idx]+=item.y;    }    for(int i=1;i&lt;=all.size();i++) s[i]=s[i-1]+num[i];    for(auto item:query)    {        int l=find(item.x),r=find(item.y);        cout &lt;&lt; s[r]-s[l-1] &lt;&lt; endl;    }    return 0;}\n\n解题思路\n离散化\n\n\n将输入的所有下标进行排序，进行离散化操作，并通过前缀和求出离散化后对应两个下标的数据总和；\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"Linux C++ 开发 第一讲","url":"/2021/10/09/Linux-CPP-1/","content":"音乐小港\n    \n\n\nLinux C++ 开发第一讲什么是Linux系统\nLinux是开源的操作系统\n\n多用户多任务\n单用户：一个用户，在登录计算机（操作系统），只能允许同时登录一个用户；\n单任务：一个任务，允许用户同时进行的操作任务数量；\n多用户：多个用户，在登录计算机（操作系统），允许同时登录多个用户进行操作；\n多任务：多个任务，允许用户同时进行多个操作任务；\n\nWindows属于：单用户、多任务。Linux属于：多用户、多任务。Linux一切皆文件对于文件的操作的都有哪些种类？\n\n 创建文件、编辑文件、保存文件、关闭文件、重命名文件、删除文件、恢复文件。\n\n1.1 目录结构\n目录结构：\nBin：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。\nDev：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似window下的分配盘符）。\nEtc：该目录主要存储一些配置文件。\nHome：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。\nProc：全称process，表示进程，该目录中存储的是Linux运行时候的进程。\nRoot：该目录是root用户自己的家目录。\nSbin：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。\nTmp：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。\nUsr：存放的是用户自己安装的软件。类似于windows下的program files。\nVar：存放的程序/系统的日志文件的目录。\nMnt：当外接设备需要挂载的时候，就需要挂载到mnt目录下。\n\n\n1.2 指令与选项\n指令含义：\nLinux的指令是指在Linux终端（命令行）中输入的内容\n指令格式：\n完整指令的标准格式：命令（空格） [选项]（空格） [操作对象]\n选项和操作对象都可以没有，也可以是多个# 指令示例：以下两条指令等价ls -l -a -h /home ./ls -lah /home ./\n\n\n\n1.3 重要指令讲解 +【实战】命令行演练\npwd - Print current working directory\n\n作用：打印当前终端所在的目录\n用法： pwd# 打印当前目录pwd\n\n\nls - List directory contents\n\n作用：列出当前工作目录下的所有文件/文件夹的名称\n用法1：ls含义：列出当前工作目录下的文件/文件夹的名称ls\n用法2：ls [路径]含义：列出指定路径下的所有文件/文件夹的名称\n绝对路径：相对根目录的路径；\n相对路径：相对当前目录的路径；# ls 相对路径ls ./ #【表示当前目录下】ls ../ #【上一级目录下】# ls 绝对路径ls /home\n\n\n用法3：ls [选项] [路径]含义：在列出指定路径下的文件/文件夹的名称，并以指定的格式进行显示# ls 选项 路径ls -lah /home# 选项解释：  -l：表示list，表示以详细列表的形式进行展示  -a：表示显示所有的文件/文件夹（包含了隐藏文件/文件夹）  -h：表示以可读性较高的形式显示# ls -l 中 “-”表示改行对应的文档类型为文件，“d”表示文档类型为文件 夹。# 在Linux中隐藏文档一般都是以“.”开头\n\n\ncd - change directory\n\n作用：切换当前的工作目录\n用法1：cd ； cd ~# 以下两条命令等价，示直接进入当前用户的家目录下【很常用】cdcd ~\n用法2：cd [相对路径]# 进入到上级目录下cd ..# 进入到上级目录中的local目录下cd ../local\n用法3：cd [绝对路径]# 进入到/usr/local目录下cd /usr/local\n\n\nmkdir - make directories\n\n作用：创建目录\n用法1：mkdir 路径# 在当前路径下创建出目录“myfoldermkdir myfolder\n用法2：mkdir -p 路径含义：一次性创建多层不存在的目录# 创建 ~/a/b/c 目录mkdir -p ~/a/b/c\n用法3：mkdir 路径1 [路径2] [路径3]含义：一次性创建多个目录# 在当前目录分别创建a、b、c三个文件夹mkdir a b c\n\n\ntouch - change file timestamps\n\n作用：创建新文件-----------------------------------------------------------------------------------------------------# 【为什么创建新文件是touch】# 1. touch的作用本来不是创建文件，而是将指定文件的修改时间设置为当前时间。就是假装“碰”（touch）了一下这个文件，假装文件被“修改”了，于是文件的修改时间就是被设置为当前时间。# 2. 这带来了一个副作用，就是当touch一个不存在的文件的时候，它会创建这个文件。然后，由于touch已经可以完成创建文件的功能了，就不再需要一个单独的create了。-----------------------------------------------------------------------------------------------------\n用法1：touch [路径]# 在当前目录下创建linux.txt文件touch linux.txt# 在上级目录下创建linux文件touch ../linux# 在/home/bing/目录下创建myfile文件touch /home/bing/myfile\n用法2：touch [路径1] [路径2]# 在当前目录下创建file file.txt 两个文件touch file file.txt\n\n\nrm - remove files or directories\n\n作用：删除文件/目录\n用法1：rm [选项] 需要移除的文件路径# 删除当前路径下的myfile文件rm myfile# 删除/usr路径下的myfile文件rm /usr/myfile\n用法2：rm [选项] 需要移除的目录# 删除当前路径下的abc文件rm -rf myfolder# 删除/usr路径下的abc文件rm -rf /usr/myfolder\n\n\ncp - copy files and directories\n\n作用：复制文件/文件夹到指定的位置\n用法1：cp [被复制的文件路径] [文件被复制到的路径]# cp命令来复制一个文件cp /home/bing/myfile ./\n用法2：cp -r [被复制的文件夹路径] [文件夹被复制到的路径]含义：-r 表示递归复制，复制文件夹的时候需要加 -r# 复制/home/bing/myfolder文件夹到根目录/下cp -r /home/bing/myfolder /\n\n\nmv - move (rename) files\n\n作用：移动文件到新的位置，或者重命名文件\n用法：mv [需要移动的文件路径] [需要保存的位置路径]# 移动当前目录下myfile文件到根目录/下mv myfile /myfile# 移动当前目录下myfolder文件夹到根目录/下mv myfolder /myfolder# 移动当前目录下myfile到根目录/下，并重命名为myfile007mv myfile myfile007\n\n\nman - an interface to the system reference manuals\n\n作用：包含了Linux中全部命令手册\n用法：man [命令]\n含义：查看命令使用手册，按 q 退出# 查看ls命令的手册man ls# 查看cd命令的手册man cd# 查看man命令的手册man man\n\n\nreboot - reboot the machine\n\n作用：重启linux系统\n用法：reboot# 立即重启reboot\n\n\nshutdown - power-off the machine\n\n作用：关机\n用法：shut -h [时间]# 立即关机shutdown -h now\n\n\n\n1.4 文件编辑\nVim [file]\n所有的 Linux系统都会内建 Vi/Vim编辑器，其他的编辑器则不一定会存在\nVim是所有Unix及Linux系统下标准的编辑器\nVim 具有程序开发的能力，也可以用来对文件进行简单的编辑\n\n\n\nVim具有“编辑器之神”的称号，学会Vim便可在Linux的世界里畅行无阻，尤其是在终端中\n\n👇Vim操作终极图片👇\n\n\n\ngedit [file]\nLinux 下的一个纯文本编辑器  \n可以根据不同的语言高亮显现关键字和标识符。  \n\n\nnano [file]  \nnano 是一个小巧的文本编辑器  \n它比vi/vim要简单得多，比较适合Linux初学者使用。  \n某些Linux发行版的默认编辑器就是nano。\n\n\n\n\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第二讲","url":"/2021/10/10/Linux-CPP-2/","content":"音乐小港\n    \n\n\nLinux C++ 开发第二讲: 开发环境搭建2.1 编译器，调试器安装\n安装GCC，GDBsudo apt update# 通过以下命令安装编译器和调试器sudo apt install build-essential gdb\n安装成功确认# 以下命令确认每个软件是否安装成功# 如果成功，则显示版本号gcc --versiong++ --versiongdb --version\n\n2.2 CMake安装\n安装cmake# 通过以下命令安装编译器和调试器sudo apt install cmake\n安装成功确认# 确认是否安装成功# 如果成功，则显示版本号cmake --version\n\n\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第三讲","url":"/2021/10/10/Linux-CPP-3/","content":"音乐小港\n    \n\n\nLinux C++ 开发第三讲: GCC编译器前言：\nGCC 编译器支持编译 Go、Objective-C，Objective-C ++，Fortran，Ada，D 和 BRIG（HSAIL）等程序；\nLinux 开发C/C++ 一定要熟悉 GCC\nVSCode是通过调用GCC编译器来实现C/C++的编译工作的；\n\n实际使用中：\n使用 gcc 指令编译 C 代码\n使用 g++指令编译 C++ 代码\n\n3.1 编译过程\n预处理-Pre-Processing //.i文件# -E 选项指示编译器仅对输入文件进行预处理g++ -E test.cpp -o test.i //.i文件\n编译-Compiling // .s文件# -S 编译选项告诉 g++ 在为 C++ 代码产生了汇编语言文件后停止编译# g++ 产生的汇编语言文件的缺省扩展名是 .sg++ -S test.i -o test.s\n汇编-Assembling // .o文件# -c 选项告诉 g++ 仅把源代码编译为机器语言的目标代码# 缺省时 g++ 建立的目标代码文件有一个 .o 的扩展名。g++ -c test.s -o test.o\n链接-Linking // bin文件# -o 编译选项来为将产生的可执行文件用指定的文件名g++ test.o -o test\n3.2 g++重要编译参数\n-g 编译带调试信息的可执行文件# -g 选项告诉 GCC 产生能被 GNU 调试器GDB使用的调试信息，以调试程序。# 产生带调试信息的可执行文件testg++ -g test.cpp\n-O[n] 优化源代码## 所谓优化，例如省略掉代码中从未使用过的变量、直接将常量表达式用结果值代替等等，这些操作会缩减目标文件所包含的代码量，提高最终生成的可执行文件的运行效率。# -O 选项告诉 g++ 对源代码进行基本优化。这些优化在大多数情况下都会使程序执行的更快。 -O2选项告诉 g++ 产生尽可能小和尽可能快的代码。 如-O2，-O3，-On（n 常为0–3）# -O 同时减小代码的长度和执行时间，其效果等价于-O1# -O0 表示不做优化# -O1 为默认优化# -O2 除了完成-O1的优化之外，还进行一些额外的调整工作，如指令调整等。# -O3 则包括循环展开和其他一些与处理特性相关的优化工作。# 选项将使编译的速度比使用 -O 时慢， 但通常产生的代码执行速度会更快。# 使用 -O2优化源代码，并输出可执行文件g++ -O2 test.cpp\n-l 和 -L 指定库文件 | 指定库文件路径# -l参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名# 在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接# 链接glog库g++ -lglog test.cpp# 如果库文件没放在上面三个目录里，需要使用-L参数(大写)指定库文件所在目录# -L参数跟着的是库文件所在的目录名# 链接mytest库，libmytest.so在/home/bing/mytestlibfolder目录下g++ -L/home/bing/mytestlibfolder -lmytest test.cpp\n-I 指定头文件搜索目录# -I# /usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上-I/myinclude 参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错误。-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。上面我们提到的–cflags参数就是用来生成-I参数的。g++ -I/myinclude test.cpp\n-Wall 打印警告信息# 打印出gcc提供的警告信息g++ -Wall test.cpp\n-w 关闭警告信息# 关闭所有警告信息g++ -w test.cpp\n-std=c++11 设置编译标准# 使用 c++11 标准编译 test.cppg++ -std=c++11 test.cpp\n-o 指定输出文件名# 指定即将产生的文件名# 指定输出可执行文件名为testg++ test.cpp -o test\n-D 定义宏# 在使用gcc/g++编译的时候定义宏# 常用场景：# -DDEBUG 定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭DEBUG\n示例代码：// -Dname 定义宏name,默认定义内容为字符串“1”#include &lt;stdio.h&gt;int main(){#ifdef DEBUGprintf(\"DEBUG LOG\\n\");#endifprintf(\"in\\n\");}// 1. 在编译的时候，使用gcc -DDEBUG main.cpp// 2. 第七行代码可以被执行\n注：使用 man gcc 命令可以查看gcc英文使用手册，见下图\n\n\n3.3 【实战】g++命令行编译案例：最初目录结构: 2 directories, 3 files\n\n# 最初目录结构.├── include│ └── Swap.h├── main.cpp└── src└── Swap.cpp2 directories, 3 files\n\n3.3.1 直接编译最简单的编译，并运行\n# 将 main.cpp src/Swap.cpp 编译为可执行文件g++ main.cpp src/Swap.cpp -Iinclude# 运行a.out./a.out\n增加参数编译，并运行\n# 将 main.cpp src/Swap.cpp 编译为可执行文件 附带一堆参数g++ main.cpp src/Swap.cpp -Iinclude -std=c++11 -O2 -Wall -o b.out# 运行 b.out./b.out\n\n3.3.2 生成库文件并编译链接静态库生成可执行文件①：\n## 进入src目录下$cd src# 汇编，生成Swap.o文件g++ Swap.cpp -c -I../include# 生成静态库libSwap.aar rs libSwap.a Swap.o## 回到上级目录$cd ..# 链接，生成可执行文件:staticmaing++ main.cpp -Iinclude -Lsrc -lSwap -o staticmain\n链接动态库生成可执行文件②：\n## 进入src目录下$cd src# 生成动态库libSwap.sog++ Swap.cpp -I../include -fPIC -shared -o libSwap.so## 上面命令等价于以下两条命令# gcc Swap.cpp -I../include -c -fPIC# gcc -shared -o libSwap.so Swap.o## 回到上级目录$cd ..# 链接，生成可执行文件:sharemaing++ main.cpp -Iinclude -Lsrc -lSwap -o sharemain\n编译完成后的目录结构最终目录结构：2 directories, 8 files\n\n# 最终目录结构.├── include│ └── Swap.h├── main.cpp├── sharemain├── src│ ├── libSwap.a│ ├── libSwap.so│ ├── Swap.cpp│ └── Swap.o└── staticmain2 directories, 8 files\n\n3.3.3 运行可执行文件运行可执行文件①\n# 运行可执行文件./staticmain\n运行可执行文件②\n# 运行可执行文件LD_LIBRARY_PATH=src ./sharemain\n\n\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第五讲","url":"/2021/10/10/Linux-CPP-5/","content":"音乐小港\n    \n\n\nLinux C++ 开发第五讲：IDE - VSCode5.1 界面介绍\n侧边栏\n菜单栏\n编辑区\n状态栏\n\n\n5.2 插件安装以下三款插件是在Linux下开发C/C++的三款必备插件~\n\nC/C++\nCMake\nCMake Tools\n\n5.3 快捷键\n高频使用快捷键：\n\n\n功能\n快捷键\n功能\n快捷键\n\n\n\n转到文件 / 其他常用操作\nCtrl + P\n关闭当前文件\nCtrl + W\n\n\n打开命令面板\nCtrl + Shift + P\n当前行上移/下移\nAlt + Up/Down\n\n\n打开终端\nCtrl +`\n变量统一重命名\nF2\n\n\n关闭侧边栏\nCtrl + B\n转到定义处\nF12\n\n\n复制文本\nCtrl+C\n粘贴文本\nCtrl+V\n\n\n保存文件\nCtrl+S\n撤销操作\nCtrl+Z\n\n\n在 Ctrl+P 窗口下还可以:\n直接输入文件名，跳转到文件\n? 列出当前可执行的动作\n! 显示 Errors 或 Warnings ，也可以 Ctrl+Shift+M\n: 跳转到行数，也可以 Ctrl+G 直接进入\n@ 跳转到 symbol （搜索变量或者函数），也可以 Ctrl+Shift+O 直接进入\n@ 根据分类跳转 symbol ，查找属性或函数，也可以 Ctrl+Shift+O 后输入:进入\n# 根据名字查找 symbol ，也可以 Ctrl+T\n\n快捷键：编辑器与窗口管理\n打开一个新窗口： Ctrl+Shift+N\n关闭窗口： Ctrl+Shift+W\n同时打开多个编辑器（查看多个文件）\n新建文件 Ctrl+N\n文件之间切换 Ctrl+Tab\n切出一个新的编辑器（最多 3 个） Ctrl+\\ ，也可以按住 Ctrl 鼠标点击 Explorer 里的文件名\n左中右 3 个编辑器的快捷键 Ctrl+1 Ctrl+2 Ctrl+3\n3 个编辑器之间循环切换 Ctrl+\n编辑器换位置， Ctrl+k 然后按 Left 或 Right\n\n↓ 代码编辑相关的快捷键 ↓快捷键：格式调整\n代码行缩进 Ctrl+[ 、 Ctrl+]\nCtrl+C 、 Ctrl+V 复制或剪切当前行/当前选中内容\n代码格式化： Shift+Alt+F ，或 Ctrl+Shift+P 后输入 format code\n上下移动一行： Alt+Up 或 Alt+Down\n向上向下复制一行： Shift+Alt+Up 或 Shift+Alt+Down\n在当前行下边插入一行 Ctrl+Enter\n在当前行上方插入一行 Ctrl+Shift+Enter\n\n快捷键：光标相关\n移动到行首： Home\n移动到行尾： End\n移动到文件结尾： Ctrl+End\n移动到文件开头： Ctrl+Home\n移动到定义处： F12\n定义处缩略图：只看一眼而不跳转过去 Alt+F12\n移动到后半个括号：Ctrl+Shift+]\n选择从光标到行尾： Shift+End\n选择从行首到光标处： Shift+Home\n删除光标右侧的所有字： Ctrl+Delete\n扩展/缩小选取范围： Shift+Alt+Left 和 Shift+Alt+Right\n多行编辑(列编辑)： Alt+Shift+鼠标左键 ， Ctrl+Alt+Down/Up\n同时选中所有匹配： Ctrl+Shift+L\nCtrl+D 下一个匹配的也被选中 (在 sublime 中是删除当前行，后面自定义快键键中，设置与Ctrl+Shift+K 互换了)\n回退上一个光标操作： Ctrl+U\n\n快捷键：重构代码\n找到所有的引用： Shift+F12\n同时修改本文件中所有匹配的： Ctrl+F12\n重命名：比如要修改一个方法名，可以选中后按 F2 ，输入新的名字，回车，会发现所有的文件都修改了\n跳转到下一个 Error 或 Warning ：当有多个错误时可以按 F8 逐个跳转\n查看 diff ： 在 explorer 里选择文件右键 Set file to compare ，然后需要对比的文件上右键选择 Compare with file_name_you_chose\n\n快捷键：查找替换\n查找 Ctrl+F\n查找替换 Ctrl+H\n整个文件夹中查找 Ctrl+Shift+F\n\n快捷键：显示相关\n全屏： F11\nzoomIn/zoomOut： Ctrl +/-\n侧边栏显/隐： Ctrl+B\n显示资源管理器 Ctrl+Shift+E\n显示搜索 Ctrl+Shift+F\n显示 Git Ctrl+Shift+G\n显示 Debug Ctrl+Shift+D\n显示 Output Ctrl+Shift+U\n\n5.4【实战】2个小项目通过手写2个小项目，呈现出基本的C++工程建立的过程，并编译运行这两个小项目\n\n项目1：Hello world\n项目2：Swap with class\n\n5.4.1 高频使用技巧\n左右分屏\n固定打开的文件\n格式化代码\nRename Symbol\n显示minimap\n侧边栏查看OUTLINE\n全屏\n关闭多个打开的文件\n\n5.4.2 代码编写5.4.3 编译并运行\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第六讲","url":"/2021/10/10/Linux-CPP-6/","content":"音乐小港\n    \n\n\nLinux C++ 开发第六讲：CMake前言：\nCMake是一个跨平台的安装编译工具，可以用简单的语句来描述所有平台的安装(编译过程)。\nCMake可以说已经成为大部分C++开源项目标配\n\n6.1 Cross-platform developmentLet’s assume you have some cross-platform project with C++ code shared along differentplatforms/IDEs. Say you use Visual Studio on Windows, Xcode on OSX and Makefile for Linux:\n\nWhat you will do if you want to add new bar.cpp source file? You have to add it to every tool you use:\n\nTo keep the environment consistent you have to do the similar update several times. And the most important thing is that you have to do it manually (arrow marked with a red color on the diagram in this case). Of course such approach is error prone and not flexible.CMake solve this design flaw by adding extra step to development process. You can describe your project in CMakeLists.txt file and use CMake to generate tools you currently interested in using cross-platform CMake code:\n\nSame action - adding new bar.cpp file, will be done in one step now:\n\nNote that the bottom part of the diagram was not changed. I.e. you still can keep using yourfavorite tools like Visual Studio/msbuild , Xcode/xcodebuild and Makefile/make !\n6.2 语法特性介绍\n基本语法格式：指令(参数 1 参数 2…)\n参数使用括弧括起\n参数之间使用空格或分号分开\n\n\n指令是大小写无关的，参数和变量是大小写相关的set(HELLO hello.cpp)add_executable(hello main.cpp hello.cpp)ADD_EXECUTABLE(hello main.cpp ${HELLO})\n变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名\n\n6.3 重要指令和CMake常用变量6.3.1 重要指令\ncmake_minimum_required - 指定CMake的最小版本要求\n语法： cmake_minimum_required(VERSION versionNumber [FATAL_ERROR])# CMake最小版本要求为2.8.3cmake_minimum_required(VERSION 2.8.3)\n\n\nproject - 定义工程名称，并可指定工程支持的语言\n语法： project(projectname [CXX] [C] [Java])# 指定工程名为HELLOWORLDproject(HELLOWORLD)\n\n\nset - 显式的定义变量\n语法：set(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])# 定义SRC变量，其值为sayhello.cpp hello.cppset(SRC sayhello.cpp hello.cpp)\n\n\ninclude_directories - 向工程添加多个特定的头文件搜索路径 —&gt;相当于指定g++编译器的-I参数\n语法： include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 …)# 将/usr/include/myincludefolder 和 ./include 添加到头文件搜索路径include_directories(/usr/include/myincludefolder ./include)\n\n\nlink_directories - 向工程添加多个特定的库文件搜索路径 —&gt;相当于指定g++编译器的-L参数\n语法： link_directories(dir1 dir2 …)# 将/usr/lib/mylibfolder 和 ./lib 添加到库文件搜索路径link_directories(/usr/lib/mylibfolder ./lib)\n\n\nadd_library - 生成库文件\n语法： add_library(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 … sourceN)# 通过变量 SRC 生成 libhello.so 共享库add_library(hello SHARED ${SRC})\n\n\nadd_compile_options - 添加编译参数\n语法： add_compile_options(# 添加编译参数 -Wall -std=c++11 -O2add_compile_options(-Wall -std=c++11 -O2)\n\n\nadd_executable - 生成可执行文件\n语法：add_executable(exename source1 source2 … sourceN)# 编译main.cpp生成可执行文件mainadd_executable(main main.cpp)\n\n\ntarget_link_libraries -  为 target 添加需要链接的共享库 —&gt;相同于指定g++编译器-l参数\n语法：target_link_libraries(target library1&lt;debug | optimized&gt; library2…)# 将hello动态库文件链接到可执行文件maintarget_link_libraries(main hello)\n\n\nadd_subdirectory -  向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置\n语法：add_subdirectory(source_dir [binary_dir] [EXCLUDE_FROM_ALL])# 添加src子目录，src中需有一个CMakeLists.txtadd_subdirectory(src)\n\n\naux_source_directory -  发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表\n语法：aux_source_directory(dir VARIABLE)# 定义SRC变量，其值为当前目录下所有的源代码文件aux_source_directory(. SRC)# 编译SRC变量所代表的源代码文件，生成main可执行文件add_executable(main ${SRC})\n\n\n\n6.3.2 CMake常用变量\nCMAKE_C_FLAGS gcc编译选项\nCMAKE_CXX_FLAGS g++编译选项# 在CMAKE_CXX_FLAGS编译选项后追加-std=c++11set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11\")\nCMAKE_BUILD_TYPE 编译类型(Debug, Release)# 设定编译类型为debug，调试时需要选择debugset(CMAKE_BUILD_TYPE Debug)# 设定编译类型为release，发布时需要选择releaseset(CMAKE_BUILD_TYPE Release)\nCMAKE_BINARY_DIRPROJECT_BINARY_DIRBINARY_DIR\n\n这三个变量指代的内容是一致的。\n如果是 in source build，指的就是工程顶层目录。\n如果是 out-of-source 编译,指的是工程编译发生的目录。\nPROJECT_BINARY_DIR 跟其他指令稍有区别，不过现在，你可以理解为他们是一致的。\n\n\n\nCMAKE_SOURCE_DIRPROJECT_SOURCE_DIR_SOURCE_DIR\n\n这三个变量指代的内容是一致的,不论采用何种编译方式,都是工程顶层目录。\n也就是在 in source build时,他跟 CMAKE_BINARY_DIR 等变量一致。\nPROJECT_SOURCE_DIR 跟其他指令稍有区别,现在,你可以理解为他们是一致的。\n\n\n\nCMAKE_C_COMPILER：指定C编译器\nCMAKE_CXX_COMPILER：指定C++编译器\nEXECUTABLE_OUTPUT_PATH：可执行文件输出的存放路径\nLIBRARY_OUTPUT_PATH：库文件输出的存放路径\n\n6.4 CMake编译工程CMake目录结构：项目主目录存在一个CMakeLists.txt文件\n两种方式设置编译规则：\n\n包含源文件的子文件夹包含CMakeLists.txt文件，主目录的CMakeLists.txt通过add_subdirectory添加子目录即可；\n包含源文件的子文件夹未包含CMakeLists.txt文件，子目录编译规则体现在主目录的CMakeLists.txt中；\n\n6.4.1 编译流程在 linux 平台下使用 CMake 构建C/C++工程的流程如下:\n\n手动编写 CMakeLists.txt。\n执行命令 cmake PATH 生成 Makefile ( PATH 是顶层CMakeLists.txt 所在的目录 )。\n执行命令 make 进行编译。# important tips. # 表示当前目录./ # 表示当前目录.. # 表示上级目录../ # 表示上级目录\n\n6.4.2 两种构建方式\n**内部构建(in-source build)**：不推荐使用内部构建会在同级目录下产生一大堆中间文件，这些中间文件并不是我们最终所需要的，和工程源文件放在一起会显得杂乱无章。## 内部构建# 在当前目录下，编译本目录的CMakeLists.txt，生成Makefile和其他文件cmake .# 执行make命令，生成targetmake\n**外部构建(out-of-source build)**：推荐使用将编译输出文件与源文件放到不同目录中## 外部构建# 1. 在当前目录下，创建build文件夹mkdir build# 2. 进入到build文件夹cd build# 3. 编译上级目录的CMakeLists.txt，生成Makefile和其他文件cmake ..# 4. 执行make命令，生成targetmake\n\n6.5 【实战】CMake代码实践针对第五章写的两个小项目来写对应的CMakeLists.txt\n6.5.1 最小CMake工程# Set the minimum version of CMake that can be usedcmake_minimum_required(VERSION 3.0)# Set the project nameproject (HELLO)# Add an executableadd_executable(hello_cmake main.cpp)\n\n6.5.2 多目录工程 - 直接编译# Set the minimum version of CMake that can be usedcmake_minimum_required(VERSION 3.0)#project nameproject(SWAP)#head file patinclude_directories( include )#source directory files to varadd_subdirectory( src DIR_SRCS )#add executable fileadd_executable(swap_02 ${TEST_MATH})#add link librarytarget_link_libraries(${FS_BUILD_BINARY_PREFIX}sqrt ${LIBRARIES})\n6.5.3 多目录工程 - 生成库编译# Set the minimum version of CMake that can be usedcmake_minimum_required(VERSION 3.0)#project nameproject(SWAP_LIBRARY)#add compile optionsadd_compile_options(\"-Wall -std=c++11\")#set CMAKE_BUILD_TYPEset( CMAKE_BUILD_TYPE Debug )# set output binary pathset(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin)############################################################# Create a library#############################################################Generate the static library from the library sourcesadd_library( swap_library STATIC src/Swap.cpp )target_include_directories( swap_lib PUBLIC ${PROJECT_SOURCE_DIR}/include )############################################################# Create an executable############################################################# Add an executable with the above sourcesadd_executable( swap_01 main.cpp )# link the new swap_01 target with the swap_lib targettarget_link_libraries( swap_01 swap_liby )\n\n\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第七讲","url":"/2021/10/10/Linux-CPP-7/","content":"音乐小港\n    \n\n\nLinux C++ 开发第七讲：【实战】使用VSCode进行完整项目开发案例：士兵突击需求：\n士兵 许三多 有一把枪，叫做 AK47\n士兵 可以 开火\n**士兵 **可以 给枪装填子弹\n枪 能够 发射 子弹\n枪 能够 装填子弹 —— 增加子弹数量\n\n开发：\n开发枪类\n开发士兵类\n\n\n7.1 合理设置项目目录7.2 编写项目源文件7.3 编写CMakeLists.txt构建项目编译规则7.4 使用外部构建，手动编译CMake项目7.5 配置VSCode的json文件并调试项目\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n\n全套项目代码:\n\ngitee : git@gitee.com:baiyujinmo/VSCode_CMake_CPP.git\ngithub : git@github.com:1258360186/VsCode-CMake-CPP.git\n\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"Linux C++ 开发 第四讲","url":"/2021/10/10/Linux-CPP-4/","content":"音乐小港\n    \n\n\nLinux C++ 开发第四讲: GDB调试器前言：\nGDB(GNU Debugger)是一个用来调试C/C++程序的功能强大的调试器，是Linux系统开发C/C++最常用的调试器\n程序员可以使用GDB来跟踪程序中的错误，从而减少程序员的工作量。\nLinux 开发C/C++ 一定要熟悉 GDB\nVSCode是通过调用GDB调试器来实现C/C++的调试工作的；\nWindows 系统中，常见的集成开发环境（IDE），如 VS、VC等，它们内部已经嵌套了相应的调试器\n\n\n\nGDB主要功能：\n设置断点(断点可以是条件表达式)\n使程序在指定的代码行上暂停执行，便于观察\n单步执行程序，便于调试\n查看程序中变量值的变化\n动态改变程序的执行环境\n分析崩溃程序产生的core文件\n\n4.1 常用调试命令参数调试开始：执行gdb [exefilename] ，进入gdb调试程序，其中exefilename为要调试的可执行文件名\n## 以下命令后括号内为命令的简化使用，比如xiaobing run（r），直接输入命令 r 就代表命令run$(gdb)help(h) # 查看命令帮助，具体命令查询在gdb中输入help + 命令$(gdb)run(r) # 重新开始运行文件（run-text：加载文本文件，run-bin：加载件）$(gdb)start # 单步执行，运行程序，停在第一行执行语句$(gdb)list(l) # 查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查数）$(gdb)set # 设置变量的值$(gdb)next(n) # 单步调试（逐过程，函数直接执行）$(gdb)step(s) # 单步调试（逐语句：跳入自定义函数内部执行）$(gdb)backtrace(bt) # 查看函数的调用的栈帧和层级关系$(gdb)frame(f) # 切换函数的栈帧$(gdb)info(i) # 查看函数内部局部变量的数值$(gdb)finish # 结束当前函数，返回到函数调用点$(gdb)continue(c) # 继续运行$(gdb)print(p) # 打印值及地址$(gdb)quit(q) # 退出gdb$(gdb)break+num(b) # 在第num行设置断点$(gdb)info breakpoints # 查看当前设置的所有断点$(gdb)delete breakpoints num(d) # 删除第num个断点$(gdb)display # 追踪查看具体变量值$(gdb)undisplay # 取消追踪观察变量$(gdb)watch # 被设置观察点的变量发生修改时，打印显示$(gdb)i watch # 显示观察点$(gdb)enable breakpoints # 启用断点$(gdb)disable breakpoints # 禁用断点$(gdb)x # 查看内存x/20xw 显示20个单元，16进制，4字节每单元$(gdb)run argv[1] argv[2] # 调试时命令行传参$(gdb)set follow-fork-mode child#Makefile项目管理：选择跟踪父子进程（fork()）\n\nTips:\n\n编译程序时需要加上-g，之后才能用gdb进行调试：gcc -g main.c -o main\n回车键：重复上一命令\n\n\n4.2 【实战】命令行调试给出一段简单代码，准备调试。\n#include &lt;iostream&gt;using namespace std;int main(int argc,char **argv){int N = 100;int sum = 0;int i = 1;// calculate sum from 1 to 100while (i &lt;= N){sum = sum + i;i = i + 1;}cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl;cout &lt;&lt; \"The program is over.\" &lt;&lt; endl;return 0;}\n\n\n课程来源:基于VSCode和CMake实现C/C++开发 | Linux篇\n","categories":["基于VSCode和CMake实现C/C++开发 | Linux篇"],"tags":["Linux","C++ 开发"]},{"title":"最长连续不重复子序列","url":"/2021/10/13/Longest-continuous-unrepeated-subsequence/","content":"音乐小港\n    \n\n\n最长连续不重复子序列题目给定一个长度为n的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。\n输入格式第一行包含整数n。\n第二行包含n个整数（均在0~100000范围内），表示整数序列。\n输出格式共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。\n数据范围\n输入样例51 2 2 3 5\n\n输出样例3\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int q[100010],st[100010];int main(){    cin &gt;&gt; n;    for(int i=0;i&lt;n;i++) cin &gt;&gt; q[i];    int res=0;    for(int i=0,j=0;i&lt;n;i++)    {        st[q[i]]++;        while(j&lt;i&amp;&amp;st[q[i]]&gt;1) st[q[j++]]--;        res=max(res,i-j+1);    }    cout &lt;&lt; res &lt;&lt; endl;    return 0;}\n\n解题思路\n双指针算法\n\n\n 数组用来存储指针范围内各元素出现次数；\n为前指针，为后指针；\n若后指针移动后，出现重复的数，即将变为同时清空之前已存储的各元素个数；\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"管道、环境变量与常用命令","url":"/2021/10/13/Pipes-environment-variables-and-common-commands/","content":"音乐小港\n    \n\n\n管道、环境变量与常用命令\n管道\n环境变量\n常用命令\n\n管道概念管道类似于文件重定向，可以将前一个命令的stdout重定向到下一个命令的stdin。\n要点\n管道命令仅处理stdout，会忽略stderr。\n管道右边的命令必须能接受stdin。\n多个管道命令可以串联。与文件重定向的区别文件重定向左边为命令，右边为文件。管道左右两边均为命令，左边有stdout，右边有stdin。举例统计当前目录下所有python文件的总行数，其中find、xargs、wc等命令可以参考常用命令这一节内容。find . -name '*.py' | xargs cat | wc -l\n\n环境变量概念Linux系统中会用很多环境变量来记录配置信息。\n环境变量类似于全局变量，可以被各个进程访问到。我们可以通过修改环境变量来方便地修改系统配置。\n查看列出当前环境下的所有环境变量：\nenv  # 显示当前用户的变量set  # 显示当前shell的变量，包括当前用户的变量;export  # 显示当前导出成用户变量的shell变量\n输出某个环境变量的值：\necho $PATH\n修改环境变量的定义、修改、删除操作可以参考shell语法——变量这一节的内容。\n为了将对环境变量的修改应用到未来所有环境下，可以将修改命令放到~/.bashrc文件中。\n修改完~/.bashrc文件后，记得执行source ~/.bashrc，来将修改应用到当前的bash环境下。\n为何将修改命令放到~/.bashrc，就可以确保修改会影响未来所有的环境呢？\n\n每次启动bash，都会先执行~/.bashrc。\n每次ssh登陆远程服务器，都会启动一个bash命令行给我们。\n每次tmux新开一个pane，都会启动一个bash命令行给我们。\n所以未来所有新开的环境都会加载我们修改的内容。常见环境变量\n\n\nHOME：用户的家目录。\nPATH：可执行文件（命令）的存储路径。路径与路径之间用:分隔。当某个可执行文件同时出现在多个路径中时，会选择从左到右数第一个路径中的执行。下列所有存储路径的环境变量，均采用从左到右的优先顺序。\nLD_LIBRARY_PATH：用于指定动态链接库(.so文件)的路径，其内容是以冒号分隔的路径列表。\nC_INCLUDE_PATH：C语言的头文件路径，内容是以冒号分隔的路径列表。\nCPLUS_INCLUDE_PATH：CPP的头文件路径，内容是以冒号分隔的路径列表。\nPYTHONPATH：Python导入包的路径，内容是以冒号分隔的路径列表。\nJAVA_HOME：jdk的安装目录。\nCLASSPATH：存放Java导入类的路径，内容是以冒号分隔的路径列表。\n\n常用命令简介Linux命令非常多，本节讲解几个常用命令。其他命令依赖于大家根据实际操作环境，边用边查。\n系统状况\ntop：查看所有进程的信息（Linux的任务管理器）\n打开后，输入M：按使用内存排序\n打开后，输入P：按使用CPU排序\n打开后，输入q：退出\n\n\ndf -h：查看硬盘使用情况\nfree -h：查看内存使用情况\ndu -sh：查看当前目录占用的硬盘空间\nps aux：查看所有进程\nkill -9 pid：杀死编号为pid的进程\n传递某个具体的信号：kill -s SIGTERM pid\n\n\nnetstat -nt：查看所有网络连接\nw：列出当前登陆的用户\nping www.baidu.com：检查是否连网文件权限\nchmod：修改文件权限\nchmod +x xxx：给xxx添加可执行权限\nchmod -x xxx：去掉xxx的可执行权限\nchmod 777 xxx：将xxx的权限改成777。文件检索\n\n\nfind /path/to/directory/ -name '*.py'：搜索某个文件路径下的所有*.py文件\n grep xxx：从stdin中读入若干行数据，如果某行中包含xxx，则输出该行；否则忽略该行。\nwc：统计行数、单词数、字节数\n既可以从stdin中直接读入内容；也可以在命令行参数中传入文件名列表；\nwc -l：统计行数\nwc -w：统计单词数\nwc -c：统计字节数\n\n\ntree：展示当前目录的文件结构\ntree /path/to/directory/：展示某个目录的文件结构\ntree -a：展示隐藏文件\n\n\nag xxx：搜索当前目录下的所有文件，检索xxx字符串\ncut：分割一行内容\n从stdin中读入多行数据\necho $PATH | cut -d ':' -f 3,5：输出PATH用:分割后第3、5列数据\necho $PATH | cut -d ':' -f 3-5：输出PATH用:分割后第3-5列数据\necho $PATH | cut -c 3,5：输出PATH的第3、5个字符\necho $PATH | cut -c 3-5：输出PATH的第3-5个字符\n\n\nsort：将每行内容按字典序排序\n可以从stdin中读取多行数据\n可以从命令行参数中读取文件名列表\n\n\nxargs：将stdin中的数据用空格或回车分割成命令行参数\nfind . -name '*.py' | xargs cat | wc -l：统计当前目录下所有python文件的总行数查看文件内容\n\n\nmore：浏览文件内容\n回车：下一行\n空格：下一页\nb：上一页\nq：退出\n\n\nless：与more类似，功能更全\n回车：下一行\ny：上一行\nPage Down：下一页\nPage Up：上一页\nq：退出\n\n\nhead -3 xxx：展示xxx的前3行内容\n同时支持从stdin读入内容\n\n\ntail -3 xxx：展示xxx末尾3行内容\n同时支持从stdin读入内容用户相关\n\n\nhistory：展示当前用户的历史操作。内容存放在~/.bash_history中工具\nmd5sum：计算md5哈希值\n可以从stdin读入内容\n也可以在命令行参数中传入文件名列表；\n\n\ntime command：统计command命令的执行时间\nipython3：交互式python3环境。可以当做计算器，或者批量管理文件。\n! echo \"Hello World\"：!表示执行shell脚本\n\n\nwatch -n 0.1 command：每0.1秒执行一次command命令\ntar：压缩文件\ntar -zcvf xxx.tar.gz /path/to/file/*：压缩\ntar -zxvf xxx.tar.gz：解压缩\n\n\ndiff xxx yyy：查找文件xxx与yyy的不同点安装软件\nsudo command：以root身份执行command命令\napt-get install xxx：安装软件\npip install xxx --user --upgrade：安装python包\n\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","常用命令"]},{"title":"二进制中1的个数","url":"/2021/10/13/Number-of-1-in-binary/","content":"音乐小港\n    \n\n\n二进制中1的个数题目给定一个长度为n的数列，请你求出数列中每个数的二进制表示中1的个数。\n输入格式第一行包含整数n。\n第二行包含n个整数，表示整个数列。\n输出格式共一行，包含n个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中1的个数。\n数据范围,数列中元素的值\n输入样例51 2 3 4 5\n\n输出样例1 1 2 1 2\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int main(){    cin &gt;&gt; n;    while(n--)    {        int res=0;        int num=0;        cin &gt;&gt; num;        while(num) res++,num-=num&amp;-num;        //(num&amp;-num)lowbit操作返回最后一位1后的所有位        cout &lt;&lt; res &lt;&lt; ' ';    }    return 0;}\n\n解题思路\n位运算\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"数组元素的目标和","url":"/2021/10/13/Target-and-of-array-elements/","content":"音乐小港\n    \n\n\n数组元素的目标和题目给定两个升序排序的有序数组A和B，以及一个目标值x。数组下标从0开始。请你求出满足A[i] + B[j] = x的数对(i, j)。\n数据保证有唯一解。\n输入格式第一行包含三个整数n，m，x，分别表示A的长度，B的长度以及目标值x。\n第二行包含n个整数，表示数组A。\n第三行包含m个整数，表示数组B。\n输出格式共一行，包含两个整数 i 和 j。\n数据范围数组长度不超过100000。同一数组内元素各不相同。数组元素\n输入样例4 5 61 2 4 73 4 6 8 9\n\n输出样例1 1\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,m,x;int A[100010],B[100010];int main(){    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;    for(int i=0;i&lt;n;i++) cin &gt;&gt; A[i];    for(int i=0;i&lt;m;i++) cin &gt;&gt; B[i];    for(int i=0,j=m-1;i&lt;n;i++)    {        int temp=x-A[i];        while(j&gt;=0&amp;&amp;B[j]&gt;temp) j--;        if(B[j]==temp)        {            cout &lt;&lt; i &lt;&lt;' '&lt;&lt; j &lt;&lt; endl;            break;        }    }    return 0;}\n\n解题思路\n双指针算法\n\n\n因为两个序列都是升序序列，故若某一序列从大到小遍历，为满足题意，从另一个序列取的值比如会越来越小；\n序列不存在重复元素，下个元素对应的数必然在另一个序列的更前面；\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"数的范围","url":"/2021/10/08/Range-of-numbers/","content":"音乐小港\n    \n\n\n数的范围题目给定一个按照升序排列的长度为n的整数数组，以及 q 个查询。\n对于每个查询，返回一个元素k的起始位置和终止位置（位置从0开始计数）。\n如果数组中不存在该元素，则返回“-1 -1”。\n输入格式第一行包含整数n和q，表示数组长度和询问个数。\n第二行包含n个整数（均在1~10000范围内），表示完整数组。\n接下来q行，每行包含一个整数k，表示一个询问元素。\n输出格式共q行，每行包含两个整数，表示所求元素的起始位置和终止位置。\n如果数组中不存在该元素，则返回“-1 -1”。\n数据范围\n输入样例6 31 2 2 3 3 4345\n\n输出样例3 45 5-1 -1\n\nAC代码#include &lt;cstdio&gt;using namespace std;const int N=1e5+10;int a[N];int main(){    int n,q,k;    scanf(\"%d%d\",&amp;n,&amp;q);    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]);    while(q--)    {        scanf(\"%d\",&amp;k);        int l=0,r=n-1;        while(l&lt;r)        {            int mid=(l+r)&gt;&gt;1;            if(a[mid]&lt;k) l=mid+1;            else r=mid;        }        if(a[l]!=k)        {            printf(\"-1 -1\\n\");        }        else        {            printf(\"%d \",l);            int l = 0, r = n - 1;            while(l&lt;r)            {                int mid=(l+r+1)&gt;&gt;1;                if(a[mid] &gt; k) r=mid-1;                else l=mid;            }            printf(\"%d \\n\",r);        }    }    return 0;}\n\n解题思路\n整数二分\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"数的三次方根","url":"/2021/10/08/The-cubic-root-of-a-number/","content":"音乐小港\n    \n\n\n数的三次方根题目给定一个浮点数n，求它的三次方根。\n输入格式共一行，包含一个浮点数n。\n输出格式共一行，包含一个浮点数n。\n数据范围\n输入样例1000.00\n\n输出样例10.000000\n\nAC代码#include &lt;cstdio&gt;using namespace std;int main(){    double n;    scanf(\"%lf\",&amp;n);    double l=-100,r=100;    while(r-l&gt;1e-8)    {        double mid=(l+r)/2;        if(mid*mid*mid&lt;n) l=mid;        else r=mid;    }    printf(\"%.6lf\",l);    return 0;}\n\n解题思路\n实数二分\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"第K个数","url":"/2021/10/01/The-first-number-k/","content":"音乐小港\n    \n\n\n第k个数题目给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列从小到大排序后的第k个数。\n输入格式第一行包含两个整数 n 和 k。\n第二行包含 n 个整数（所有整数均在 ~ 范围内），表示整数数列。\n输出格式输出一个整数，表示数列的第k小数。\n数据范围,\n输入样例5 32 4 1 5 3\n\n输出样例3\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,k;int q[100010];int q_sort(int q[],int x,int y,int k){    if(x&gt;=y) return q[x];    int l=x-1,r=y+1,m=q[x+y&gt;&gt;1];    while(l&lt;r)    {        do l++;while(q[l]&lt;m);        do r--;while(q[r]&gt;m);        if(l&lt;r) swap(q[l],q[r]);    }    if(r-x+1&gt;=k) q_sort(q,x,r,k);    else q_sort(q,r+1,y,k-(r-x+1));}int main(){    cin &gt;&gt; n &gt;&gt; k;    for(int i=0;i&lt;n;i++) cin &gt;&gt; q[i];    cout &lt;&lt; q_sort(q,0,n-1,k) &lt;&lt; endl;    return 0;}\n\n解题思路\n快排模板变形\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"逆序对的数量","url":"/2021/10/02/The-number-of-inversions/","content":"音乐小港\n    \n\n\n逆序对的数量题目给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。\n逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对；否则不是。\n输入格式第一行包含整数n，表示数列的长度。\n第二行包含 n 个整数，表示整个数列。\n输出格式输出一个整数，表示逆序对的个数。\n数据范围\n输入样例62 3 4 5 6 1\n\n输出样例5\n\nAC代码#include &lt;iostream&gt;using namespace std;using LL = long long;int n;int q[100010],tmp[100010];LL res;LL m_sort(int q[],int l,int r){    LL res=0;    if(l&gt;=r) return res;    int mid=l+r&gt;&gt;1;    res=m_sort(q,l,mid)+m_sort(q,mid+1,r);    int i=l,j=mid+1,k=0;    while(i&lt;=mid&amp;&amp;j&lt;=r)    {        if(q[i]&lt;=q[j]) tmp[k++]=q[i++];        else tmp[k++]=q[j++],res+=mid-i+1;    }    while(i&lt;=mid) tmp[k++]=q[i++];    while(j&lt;=r) tmp[k++]=q[j++];    for(int i=l,k=0;i&lt;=r;i++) q[i]=tmp[k++];    return res;}int main(){    scanf(\"%d\",&amp;n);    for(int i=0;i&lt;n;i++) scanf(\"%d\",&amp;q[i]);    printf(\"%lld\",m_sort(q,0,n-1));    return 0;}\n\n解题思路\n归并排序模板变形\n所求的逆序对恰好是逆序数量；\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"Ubuntu 安装 Thrift 以及常见问题","url":"/2021/10/11/Thrift-install/","content":"音乐小港\n    \n\n\nUbuntu 安装 Thrift 以及常见问题本文演示ubuntu20.04下安装Thrift 0.15.0并配置CPP和Python3的使用环境AC Terminal 中的 thrift为 0.16.0\n官方教程链接:Ubuntu/Debian install,Building From Source\n先安装好 g++ 和 python3sudo apt updatesudo apt install g++sudo apt install python3\n安装 Thrift安装相关依赖包sudo apt-get install automake bison flex g++ git libboost-all-dev libevent-dev libssl-dev libtool make pkg-config\n安装python packagessudo apt install python-all python-all-dev python-all-dbg\n下载 Thrift 并解压wget https://dlcdn.apache.org/thrift/0.15.0/thrift-0.15.0.tar.gztar -xf thrift-0.15.0.tar.gz\n执行命令cd thrift-0.15.0/./configure\n执行完后最后的输出内容如下，yes即代表将支持的语言\n\n执行命令sudo make //此步骤花费时间稍长sudo make installthrift -version //若正常输出Thrift的版本则证明安装完成\n常见问题找不到动态链接库\n报错类似 ./main: error while loading shared libraries: libthrift-0.15.0.so: cannot open shared object file: No such file or directory\n配置 /etc/ld.so.conf 文件，否则可能会报找不到动态链接库等错误\n执行命令vim /etc/ld.so.conf\n添加内容 /usr/local/lib，添加后文件内容如下include /etc/ld.so.conf.d/*.conf /user/local/lib\n执行命令使添加的内容生效sudo /sbin/ldconfig\npython找不到thrift模块\n报错内容类似：ModuleNotFoundError: No module named ‘thrift’\n\n可通过pip安装thrift解决，若未安装pip，先执行安装pip的命令  sudo apt install python3-pip\n然后执行  sudo pip install thrift\n即可解决找不到thrift模块的问题\n\n\n来源链接：congee\n","categories":["Linux 基础"],"tags":["Linux","thrift"]},{"title":"钞票","url":"/2021/10/17/bank-note/","content":"音乐小港\n    \n\n\n钞票题目在这个问题中，你需要读取一个整数值并将其分解为多张钞票的和，每种面值的钞票可以使用多张，并要求所用的钞票数量尽可能少。\n请你输出读取值和钞票清单。\n钞票的可能面值有 。\n输入格式输入一个整数 。\n输出格式参照输出样例，输出读取数值以及每种面值的钞票的需求数量。\n数据范围\n输入样例576\n\n输出样例5765 nota(s) de R$ 100,001 nota(s) de R$ 50,001 nota(s) de R$ 20,000 nota(s) de R$ 10,001 nota(s) de R$ 5,000 nota(s) de R$ 2,001 nota(s) de R$ 1,00\n\nAC代码#include&lt;cstdio&gt;int main(){    int men;    scanf(\"%d\",&amp;men);    printf(\"%d\\n\",men);    printf(\"%d nota(s) de R$ 100,00\\n\",men/100);    men-=men/100*100;    printf(\"%d nota(s) de R$ 50,00\\n\",men/50);    men-=men/50*50;    printf(\"%d nota(s) de R$ 20,00\\n\",men/20);    men-=men/20*20;    printf(\"%d nota(s) de R$ 10,00\\n\",men/10);    men-=men/10*10;    printf(\"%d nota(s) de R$ 5,00\\n\",men/5);    men-=men/5*5;    printf(\"%d nota(s) de R$ 2,00\\n\",men/2);    men-=men/2*2;    printf(\"%d nota(s) de R$ 1,00\",men);    return 0;}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"差","url":"/2021/10/17/difference/","content":"音乐小港\n    \n\n\n差题目读取四个整数 ，并计算  的值。\n输入格式输入共四行，第一行包含整数 ，第二行包含整数 ，第三行包含整数 ，第四行包含整数 。\n输出格式输出格式为 DIFERENCA = X，其中  为  的结果。\n数据范围\n输入样例5678\n\n输出样例DIFERENCA = -26\n\nAC代码#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main(){    int a,b,c,d;    scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d);    printf(\"DIFERENCA = %d\",a*b-c*d);    return 0;}\n\n解题思路\n\n\n","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"时间转换","url":"/2021/10/17/Time-conversion/","content":"音乐小港\n    \n\n\n时间转换题目读取一个整数值，它是工厂中某个事件的持续时间（以秒为单位），请你将其转换为小时：分钟：秒来表示。\n输入格式输入一个整数 。\n输出格式输出转换后的时间表示，格式为 hours:minutes:seconds。\n数据范围\n输入样例556\n\n输出样例0：9：16\n\nAC代码#include&lt;cstdio&gt;int main(){    int tim;    scanf(\"%d\",&amp;tim);    printf(\"%d:%d:%d\",tim/3600,tim%3600/60,tim%3600%60);    return 0;}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"租云服务器及配docker环境","url":"/2021/10/17/docker/","content":"音乐小港\n    \n\n\n租云服务器及配docker环境概述平台的作用:\n\n存放我们的docker容器，让计算跑在云端。\n获得公网IP地址，让每个人可以访问到我们的服务。\n\n任选一个云平台即可，推荐配置：\n\n1核 2GB（后期可以动态扩容，前期配置低一些没关系）\n网络带宽采用按量付费，最大带宽拉满即可（费用取决于用量，与最大带宽无关）\n系统版本：ubuntu 20.04 LTS（推荐用统一版本，避免后期出现配置不兼容的问题）\n\n租云服务器及安装docker（以阿里云为例）阿里云阿里云地址：点我去\n\n创建工作用户acs并赋予sudo权限 （名字可自定义）\n\n登录到新服务器。打开 Terminal，然后：\nssh root@xxx.xxx.xxx.xxx  # xxx.xxx.xxx.xxx替换成新服务器的公网IP\n创建acs用户：\nadduser acs  # 创建用户acsusermod -aG sudo acs  # 给用户acs分配sudo权限\n\n配置免密登录方式\n\n退回 Terminal，然后配置acs用户的别名和免密登录，可以参考 [ssh节的ssh登录]。\n\n配置新服务器的工作环境\n\n将 Terminal的配置传到新服务器上：\nscp .bashrc .vimrc .tmux.conf server_name:  # server_name需要换成自己配置的别名\n\n安装tmux和docker\n\n登录自己的服务器，然后安装tmux：\nsudo apt-get updatesudo apt-get install tmux\n打开tmux。（养成好习惯，所有工作都在tmux里进行，防止意外关闭终端后，工作进度丢失）\n然后在tmux中根据 docker安装教程 安装docker即可。\n\n主要命令\nsudo apt-get updatesudo apt-get install \\   apt-transport-https \\   ca-certificates \\   curl \\   gnupg \\   lsb-releasecurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpgecho \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io\n查看docker\ndocker --version\n\ndocker教程将当前用户添加到docker用户组为了避免每次使用docker命令都需要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组(可以参考官方文档)：\nsudo usermod -aG docker $USER\n\n镜像（images）\ndocker pull ubuntu:20.04：拉取一个镜像\ndocker images：列出本地所有镜像\ndocker image rm ubuntu:20.04 或 docker rmi ubuntu:20.04：删除镜像ubuntu:20.04\ndocker [container] commit CONTAINER IMAGE_NAME:TAG：创建某个container的镜像\ndocker save -o ubuntu:20.04.tar ubuntu:20.04：将镜像ubuntu:20.04导出到本地文件ubuntu:20.04.tar中\ndocker load -i ubuntu:20.04.tar：将镜像ubuntu:20.04从本地文件ubuntu:20.04.tar中加载出来\n\n容器(container)\ndocker [container] create -it ubuntu:20.04：利用镜像ubuntu:20.04创建一个容器。\ndocker ps -a：查看本地的所有容器\ndocker [container] start CONTAINER：启动容器\ndocker [container] stop CONTAINER：停止容器\ndocker [container] restart CONTAINER：重启容器\ndocker [contaienr] run -itd ubuntu:20.04：创建并启动一个容器\ndocker [container] attach CONTAINER：进入容器\n 先按Ctrl+p，再按Ctrl+q可以挂起容器  \n\n\ndocker [container] exec CONTAINER COMMAND：在容器中执行命令\ndocker [container] rm CONTAINER：删除容器\ndocker container prune：删除所有已停止的容器\ndocker export -o xxx.tar CONTAINER：将容器CONTAINER导出到本地文件xxx.tar中\ndocker import xxx.tar image_name:tag：将本地文件xxx.tar导入成镜像，并将镜像命名为image_name:tag\ndocker export/import与docker save/load的区别：\n export/import会丢弃历史记录和元数据信息，仅保存容器当时的快照状态\n save/load会保存完整记录，体积更大\n\n\ndocker top CONTAINER：查看某个容器内的所有进程\ndocker stats：查看所有容器的统计信息，包括CPU、内存、存储、网络等信息\ndocker cp xxx CONTAINER:xxx 或 docker cp CONTAINER:xxx xxx：在本地和容器间复制文件\ndocker rename CONTAINER1 CONTAINER2：重命名容器\ndocker update CONTAINER --memory 500MB：修改容器限制\n\n实战进入AC Terminal，然后：\nscp /var/lib/acwing/docker/images/docker_lesson_1_0.tar server_name:  # 将镜像上传到自己租的云端服务器ssh server_name  # 登录自己的云端服务器docker load -i docker_lesson_1_0.tar  # 将镜像加载到本地docker run -p 20000:22 --name my_docker_server -itd docker_lesson:1.0  # 创建并运行docker_lesson:1.0镜像#将容器的22端口映射为本机的20000端口 重命名为my_docker_server docker attach my_docker_server  # 进入创建的docker容器passwd  # 设置root密码\n去云平台控制台中修改安全组配置，放行端口·。\n返回Terminal，即可通过ssh登录自己的docker容器：\nssh root@xxx.xxx.xxx.xxx -p 20000  # 将xxx.xxx.xxx.xxx替换成自己租的服务器的IP地址\n然后，可以仿照上节课内容，创建工作用户acs。\n最后，可以参考[ssh节的ssh登录]配置docker容器的别名和免密登录。\n小Tips如果apt-get下载软件速度较慢，可以参考清华大学开源软件镜像站中的内容，修改软件源。\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","常用命令","docker"]},{"title":"归并排序","url":"/2021/10/02/merge-sort/","content":"音乐小港\n    \n\n\n归并排序题目给定你一个长度为n的整数数列。\n请你使用归并排序对这个数列按照从小到大进行排序。\n并将排好序的数列按顺序输出。\n输入格式输入共两行，第一行包含整数 n。\n第二行包含 n 个整数（所有整数均在范围内），表示整个数列。\n输出格式输出共一行，包含 n 个整数，表示排好序的数列。\n数据范围\n输入样例53 1 2 4 5\n\n输出样例1 2 3 4 5\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int a[100010],b[100010];void m_sort(int a[],int x,int y){    if(x&gt;=y) return;    int mid = (x+y)&gt;&gt;1;    m_sort(a,x,mid);    m_sort(a,mid+1,y);    int l=x,r=mid+1,k=0;    while(l&lt;=mid&amp;&amp;r&lt;=y)    {        if(a[l]&lt;a[r]) b[k++]=a[l++];        else b[k++]=a[r++];    }    while(l&lt;=mid) b[k++]=a[l++];    while(r&lt;=y) b[k++]=a[r++];    for(int i=x,j=0;i&lt;=y;i++,j++) a[i]=b[j];}int main(){    cin &gt;&gt; n;    for(int i=0;i&lt;n;i++) cin &gt;&gt; a[i];    m_sort(a,0,n-1);    for(int i=0;i&lt;n;i++) cout &lt;&lt; a[i] &lt;&lt; ' ';    return 0;}\n\n解题思路\n归并排序模板\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"git教程","url":"/2021/10/13/git/","content":"音乐小港\n    \n\n\ngit教程代码托管平台：\ngitee.com\ngithub\ngit.acwing.com\n\ngit基本概念\n工作区：仓库的目录。工作区是独立于各个分支的。\n暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区。暂存区是独立于各个分支的。\n版本库：存放所有已经提交到本地仓库的代码版本\n版本结构：树结构，树中每个节点代表一个代码版本。\n\ngit常用命令\ngit config --global user.name xxx：设置全局用户名，信息记录在~/.gitconfig文件中\ngit config --global user.email xxx@xxx.com：设置全局邮箱地址，信息记录在~/.gitconfig文件中\ngit init：将当前目录配置成git仓库，信息记录在隐藏的.git文件夹中\ngit add XX：将XX文件添加到暂存区\n git add .：将所有待加入暂存区的文件加入暂存区\n\n\ngit rm --cached XX：将文件从仓库索引目录中删掉\ngit commit -m “给自己看的备注信息”：将暂存区的内容提交到当前分支\ngit status：查看仓库状态\ngit diff XX：查看XX文件相对于暂存区修改了哪些内容\ngit log：查看当前分支的所有版本\ngit reflog：查看HEAD指针的移动历史（包括被回滚的版本）\ngit reset --hard HEAD^ 或 git reset --hard HEAD~：将代码库回滚到上一个版本\ngit reset --hard HEAD^^：往上回滚两次，以此类推\ngit reset --hard HEAD~100：往上回滚100个版本\ngit reset --hard 版本号：回滚到某一特定版本\ngit checkout — XX或git restore XX：将XX文件尚未加入暂存区的修改全部撤销\ngit remote add origin git@git.acwing.com:xxx/XXX.git：将本地仓库关联到远程仓库\ngit push -u (第一次需要-u以后不需要)：将当前分支推送到远程仓库\n git push origin branch_name：将本地的某个分支推送到远程仓库\n\n\ngit clone git@git.acwing.com:xxx/XXX.git：将远程仓库XXX下载到当前目录下\ngit checkout -b branch_name：创建并切换到branch_name这个分支\ngit branch：查看所有分支和当前所处分支\ngit checkout branch_name：切换到branch_name这个分支\ngit merge branch_name：将分支branch_name合并到当前分支上\ngit branch -d branch_name：删除本地仓库的branch_name分支\ngit branch branch_name：创建新分支\ngit push --set-upstream origin branch_name：设置本地的branch_name分支对应远程仓库的      branch_name分支\ngit push -d origin branch_name：删除远程仓库的branch_name分支\ngit pull：将远程仓库的当前分支与本地仓库的当前分支合并\ngit pull origin branch_name：将远程仓库的branch_name分支与本地仓库的当前分支合并\ngit branch --set-upstream-to=origin/branch_name1 branch_name2：将远程的branch_name1分支与本地的branch_name2分支对应\ngit checkout -t origin/branch_name 将远程的branch_name分支拉取到本地\ngit stash：将工作区和暂存区中尚未提交的修改存入栈中\ngit stash apply：将栈顶存储的修改恢复到当前分支，但不删除栈顶元素\ngit stash drop：删除栈顶存储的修改\ngit stash pop：将栈顶存储的修改恢复到当前分支，同时删除栈顶元素\ngit stash list：查看栈中所有元素\n\n\ngit restore –staged XX 表示将某文件从暂存区中拿出，但还是会对其进行管理，当其内容相对于上个版本发生改变时，git status后能看到其显示为红色git rm –cached XX 表示不对XX文件进行管理（即使其内容发生改变，在git status后，我们也可以发现其显示的是绿色）git log –pretty=oneline 将历史版本在一行显示git diff XX会先用工作区中的XX与缓存区中的XX进行比较，若缓存区中没有XX，再用工作区中的XX与当前head指向的版本中的XX进行比较。\n\n点我去一个git可视化的学习网站（趣味性挺强的，像闯关游戏)\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","常用命令","git"]},{"title":"快速排序","url":"/2021/10/01/quick_sort/","content":"音乐小港\n    \n\n\n快速排序题目给定你一个长度为n的整数数列。\n请你使用快速排序对这个数列按照从小到大进行排序。\n并将排好序的数列按顺序输出。\n输入格式输入共两行，第一行包含整数 n。\n第二行包含 n 个整数（所有整数均在 ~ 范围内），表示整个数列。\n输出格式输出共一行，包含 n 个整数，表示排好序的数列。\n数据范围\n输入样例53 1 2 4 5\n\n输出样例1 2 3 4 5\n\nAC代码#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n;int q[100010];void q_sort(int q[],int x,int y){    if(x&gt;=y) return;    int l=x-1,r=y+1,k=q[x+y&gt;&gt;1];    while(l&lt;r)    {        do l++;while(q[l]&lt;k);        do r--;while(q[r]&gt;k);        if(l&lt;r) swap(q[l],q[r]);    }    q_sort(q,x,r);    q_sort(q,r+1,y);}int main(){    cin &gt;&gt; n;    for(int i=0;i&lt;n;i++) cin &gt;&gt; q[i];    q_sort(q,0,n-1);    for(int i=0;i&lt;n;i++) cout &lt;&lt; q[i] &lt;&lt; ' ';    puts(\"\");    return 0;}\n\n解题思路\n快排模板\n\n","categories":["算法基础"],"tags":["C++","基础算法"]},{"title":"油耗","url":"/2021/10/17/oil-consumption/","content":"音乐小港\n    \n\n\n油耗题目给定一个汽车行驶的总路程（）和消耗的油量（），请你求出汽车每消耗  升汽油可行驶多少公里路程。\n输入格式输入共两行，第一行包含整数 ，表示行驶总路程。\n第二行包含保留一位小数的浮点数 ，表示消耗的油量。\n输出格式输出格式为 M km/l，其中 MM 为计算结果，保留三位小数。\n数据范围\n输入样例50035.0\n\n输出样例14.286 km/l\n\nAC代码#include&lt;cstdio&gt;int main(){    int km;    float l;    scanf(\"%d%f\",&amp;km,&amp;l);    printf(\"%.3f km/l\",km/l);    return 0;}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]},{"title":"shell语法","url":"/2021/10/13/shell/","content":"音乐小港\n    \n\n\nshell语法\n概论\n注释\n变量\n默认变量\n数组\nexpr命令\nread命令\necho命令\nprintf命令\ntest命令与判断符号[]\n判断语句\n循环语句\n函数\nexit命令\n文件重定向\n引入外部脚本\n\n概论shell是我们通过命令行与操作系统沟通的语言。\nshell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用。\nTerminal中的命令行可以看成是一个“shell脚本在逐行执行”。\nLinux中常见的shell脚本有很多种，常见的有：\n\nBourne Shell(/usr/bin/sh或/bin/sh)\nBourne Again Shell(/bin/bash)\nC Shell(/usr/bin/csh)\nK Shell(/usr/bin/ksh)\nzsh\n…\n\nLinux系统中一般默认使用bash，所以接下来讲解bash中的语法。\n文件开头需要写#! /bin/bash，指明bash为脚本解释器。\n学习技巧不要死记硬背，遇到含糊不清的地方，可以在Terminal里实际运行一遍。\n脚本示例新建一个test.sh文件，内容如下：\n#! /bin/bashecho \"Hello World!\"\n\n运行方式作为可执行文件acs@9e0ebfcd82d7:~$ chmod +x test.sh  # 使脚本具有可执行权限acs@9e0ebfcd82d7:~$ ./test.sh  # 当前路径下执行Hello World!  # 脚本输出acs@9e0ebfcd82d7:~$ /home/acs/test.sh  # 绝对路径下执行Hello World!  # 脚本输出acs@9e0ebfcd82d7:~$ ~/test.sh  # 家目录路径下执行Hello World!  # 脚本输出\n用解释器执行acs@9e0ebfcd82d7:~$ bash test.shHello World!  # 脚本输出\n\n注释单行注释每行中#之后的内容均是注释。\n# 这是一行注释echo 'Hello World'  #  这也是注释\n\n多行注释格式：\n:&lt;&lt;EOF第一行注释第二行注释第三行注释EOF\n其中EOF可以换成其它任意字符串。例如：\n:&lt;&lt;abc第一行注释第二行注释第三行注释abc:&lt;&lt;!第一行注释第二行注释第三行注释!\n\n变量定义变量定义变量，不需要加$符号，例如：\nname1='yxc'  # 单引号定义字符串name2=\"yxc\"  # 双引号定义字符串name3=yxc    # 也可以不加引号，同样表示字符串\n使用变量使用变量，需要加上$符号，或者${}符号。花括号是可选的，主要为了帮助解释器识别变量边界。\nname=yxcecho $name  # 输出yxcecho ${name}  # 输出yxcecho ${name}acwing  # 输出yxcacwing\n只读变量使用readonly或者declare可以将变量变为只读。\nname=yxcreadonly namedeclare -r name  # 两种写法均可name=abc  # 会报错，因为此时name只读\n删除变量unset可以删除变量。\nname=yxcunset nameecho $name  # 输出空行\n变量类型\n自定义变量（局部变量）子进程不能访问的变量\n环境变量（全局变量）子进程可以访问的变量\n\n自定义变量改成环境变量：\nacs@9e0ebfcd82d7:~$ name=yxc  # 定义变量acs@9e0ebfcd82d7:~$ export name  # 第一种方法acs@9e0ebfcd82d7:~$ declare -x name  # 第二种方法\n环境变量改为自定义变量：\nacs@9e0ebfcd82d7:~$ export name=yxc  # 定义环境变量acs@9e0ebfcd82d7:~$ declare +x name  # 改为自定义变量\n字符串字符串可以用单引号，也可以用双引号，也可以不用引号。\n单引号与双引号的区别：\n\n单引号中的内容会原样输出，不会执行、不会取变量；\n双引号中的内容可以执行、可以取变量；name=yxc  # 不用引号echo 'hello, $name \\\"hh\\\"'  # 单引号字符串，输出 hello, $name \\\"hh\\\"echo \"hello, $name \\\"hh\\\"\"  # 双引号字符串，输出 hello, yxc \"hh\"\n获取字符串长度name=\"yxc\"echo ${#name}  # 输出3\n提取子串name=\"hello, yxc\"echo ${name:0:5}  # 提取从0开始的5个字符\n\n默认变量文件参数变量在执行shell脚本时，可以向脚本传递参数。$1是第一个参数，$2是第二个参数，以此类推。特殊的，$0是文件名（包含路径）。例如：\n创建文件 test.sh ：\n#! /bin/bashecho \"文件名：\"$0echo \"第一个参数：\"$1echo \"第二个参数：\"$2echo \"第三个参数：\"$3echo \"第四个参数：\"$4\n然后执行该脚本：\nacs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh 1 2 3 4文件名：./test.sh第一个参数：1第二个参数：2第三个参数：3第四个参数：4\n\n其它参数相关变量\n\n\n参数\n说明\n\n\n\n$#\n代表文件传入的参数个数，如上例中值为4\n\n\n$*\n由所有参数构成的用空格隔开的字符串，如上例中值为\"$1 $2 $3 $4\"\n\n\n$@\n每个参数分别用双引号括起来的字符串，如上例中值为\"$1\" \"$2\" \"$3\" \"$4\"\n\n\n$$\n脚本当前运行的进程ID\n\n\n$?\n上一条命令的退出状态（注意不是stdout，而是exit code）。0\n\n\n$(command)\n返回command这条命令的stdout（可嵌套）\n\n\n`command`\n返回command这条命令的stdout（不可嵌套）\n\n\n数组数组中可以存放多个不同类型的值，只支持一维数组，初始化时不需要指明数组大小。数组下标从0开始。\n定义数组用小括号表示，元素之间用空格隔开。例如：\narray=(1 abc \"def\" yxc)\n也可以直接定义数组中某个元素的值：\narray[0]=1array[1]=abcarray[2]=\"def\"array[3]=yxc\n读取数组中某个元素的值格式：\n${array[index]}\n例如：\narray=(1 abc \"def\" yxc)echo ${array[0]}echo ${array[1]}echo ${array[2]}echo ${array[3]}\n读取整个数组格式：\n${array[@]}  # 第一种写法${array[*]}  # 第二种写法\n例如：\narray=(1 abc \"def\" yxc)echo ${array[@]}  # 第一种写法echo ${array[*]}  # 第二种写法\n数组长度类似于字符串\n${#array[@]}  # 第一种写法${#array[*]}  # 第二种写法\n例如：\narray=(1 abc \"def\" yxc)echo ${#array[@]}  # 第一种写法echo ${#array[*]}  # 第二种写法\n\nexpr命令简介expr命令用户求表达式的值，格式为：\nexpr 表达式\n表达式说明：\n\n用空格隔开每一项\n用反斜杠放在shell特定的字符前面（发现表达式运行错误时，可以试试转义）\n对包含空格和其他特殊字符的字符串要用引号括起来\nexpr会在stdout中输出结果。如果为逻辑关系表达式，则结果为真，stdout为1，否则为0。\nexpr的exit code：如果为逻辑关系表达式，则结果为真，exit code为0，否则为1。\n\n字符串表达式\nlength STRING返回STRING的长度\nindex STRING CHARSETCHARSET中任意单个字符在STRING中最前面的字符位置，下标从1开始。如果在STRING中完全不存在CHARSET中的字符，则返回0。\nsubstr STRING POSITION LENGTH返回STRING字符串中从POSITION开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串。\n\n示例：\nstr=\"Hello World!\"echo `expr length \"$str\"`  # ``不是单引号，表示执行该命令，输出12echo `expr index \"$str\" aWd`  # 输出7，下标从1开始echo `expr substr \"$str\" 2 3`  # 输出 ell\n\n整数表达式expr支持普通的算术操作，算术表达式优先级低于字符串表达式，高于逻辑关系表达式。\n\n+ -加减运算。两端参数会转换为整数，如果转换失败则报错。\n\n* / %乘，除，取模运算。两端参数会转换为整数，如果转换失败则报错。\n\n() 可以该表优先级，但需要用反斜杠转义\n\n\n示例：\na=3b=4echo `expr $a + $b`  # 输出7echo `expr $a - $b`  # 输出-1echo `expr $a \\* $b`  # 输出12，*需要转义echo `expr $a / $b`  # 输出0，整除echo `expr $a % $b` # 输出3echo `expr \\( $a + 1 \\) \\* \\( $b + 1 \\)`  # 输出20，值为(a + 1) * (b + 1)\n\n逻辑关系表达式\n|如果第一个参数非空且非0，则返回第一个参数的值，否则返回第二个参数的值，但要求第二个参数的值也是非空或非0，否则返回0。如果第一个参数是非空或非0时，不会计算第二个参数。\n&amp;如果两个参数都非空且非0，则返回第一个参数，否则返回0。如果第一个参为0或为空，则不会计算第二个参数。\n&lt; &lt;= = == != &gt;= &gt;比较两端的参数，如果为true，则返回1，否则返回0。”==”是”=”的同义词。”expr”首先尝试将两端参数转换为整数，并做算术比较，如果转换失败，则按字符集排序规则做字符比较。\n() 可以该表优先级，但需要用反斜杠转义\n\n示例：\na=3b=4echo `expr $a \\&gt; $b`  # 输出0，&gt;需要转义echo `expr $a '&lt;' $b`  # 输出1，也可以将特殊字符用引号引起来echo `expr $a '&gt;=' $b`  # 输出0echo `expr $a \\&lt;\\= $b`  # 输出1c=0d=5echo `expr $c \\&amp; $d`  # 输出0echo `expr $a \\&amp; $b`  # 输出3echo `expr $c \\| $d`  # 输出5echo `expr $a \\| $b`  # 输出3\n\nread命令简介read命令用于从标准输入中读取单行数据。当读到文件结束符时，exit code为1，否则为0。\n参数说明\n\n-p: 后面可以接提示信息\n-t：后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令\n\n实例：\nacs@9e0ebfcd82d7:~$ read name  # 读入name的值acwing yxc  # 标准输入acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值acwing yxc  #标准输出acs@9e0ebfcd82d7:~$ read -p \"Please input your name: \" -t 30 name  # 读入name的值，等待时间30秒Please input your name: acwing yxc  # 标准输入acs@9e0ebfcd82d7:~$ echo $name  # 输出name的值acwing yxc  # 标准输出\n\necho命令简介echo用于输出字符串。命令格式：\necho STRING\n显示普通字符串echo \"Hello AC Terminal\"echo Hello AC Terminal  # 引号可以省略\n显示转义字符echo \"\\\"Hello AC Terminal\\\"\"  # 注意只能使用双引号，如果使用单引号，则不转义echo \\\"Hello AC Terminal\\\"  # 也可以省略双引号\n显示变量name=yxcecho \"My name is $name\"  # 输出 My name is yxc\n显示换行echo -e \"Hi\\n\"  # -e 开启转义echo \"acwing\"\n输出结果：\nHiacwing\n显示不换行echo -e \"Hi \\c\" # -e 开启转义 \\c 不换行echo \"acwing\"\n输出结果：\nHi acwing\n显示结果定向至文件echo \"Hello World\" &gt; output.txt  # 将内容以覆盖的方式输出到output.txt中\n原样输出字符串，不进行转义或取变量(用单引号)name=acwingecho '$name\\\"'\n输出结果\n$name\\\"\n显示命令的执行结果echo `date`\n输出结果：\nWed Sep 1 11:45:33 CST 2021\n\nprintf命令简介printf命令用于格式化输出，类似于C/C++中的printf函数。\n默认不会在字符串末尾添加换行符。\n命令格式：\nprintf format-string [arguments...]\n用法示例脚本内容：\nprintf \"%10d.\\n\" 123  # 占10位，右对齐printf \"%-10.2f.\\n\" 123.123321  # 占10位，保留2位小数，左对齐printf \"My name is %s\\n\" \"yxc\"  # 格式化输出字符串printf \"%d * %d = %d\\n\"  2 3 `expr 2 \\* 3` # 表达式的值作为参数\n输出结果：\n       123.123.12    .My name is yxc2 * 3 = 6\n\ntest命令与判断符号[]逻辑运算符&amp;&amp;和||\n&amp;&amp; 表示与，|| 表示或\n二者具有短路原则：expr1 &amp;&amp; expr2：当expr1为假时，直接忽略expr2expr1 || expr2：当expr1为真时，直接忽略expr2\n表达式的exit code为0，表示真；为非零，表示假。（与C/C++中的定义相反）\n\ntest命令在命令行中输入man test，可以查看test命令的用法。\ntest命令用于判断文件类型，以及对变量做比较。\ntest命令用exit code返回结果，而不是使用stdout。0表示真，非0表示假。\n例如：\ntest 2 -lt 3  # 为真，返回值为0echo $?  # 输出上个命令的返回值，输出0\nacs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件homework  output.txt  test.sh  tmpacs@9e0ebfcd82d7:~$ test -e test.sh &amp;&amp; echo \"exist\" || echo \"Not exist\"exist  # test.sh 文件存在acs@9e0ebfcd82d7:~$ test -e test2.sh &amp;&amp; echo \"exist\" || echo \"Not exist\"Not exist  # testh2.sh 文件不存在\n文件类型判断命令格式：\ntest -e filename  # 判断文件是否存在\n\n\n\n测试参数\n代表意义\n\n\n\n-e\n文件是否存在\n\n\n-f\n是否为文件\n\n\n-d\n是否为目录\n\n\n文件权限判断命令格式：\ntest -r filename  # 判断文件是否可读\n\n\n\n测试参数\n代表意义\n\n\n\n-r\n文件是否可读\n\n\n-w\n文件是否可写\n\n\n-x\n文件是否可执行\n\n\n-s\n是否为非空文件\n\n\n整数间的比较命令格式：\ntest $a -eq $b  # a是否等于b\n\n\n\n测试参数\n代表意义\n\n\n\n-eq\na是否等于b\n\n\n-ne\na是否不等于b\n\n\n-gt\na是否大于b\n\n\n-lt\na是否小于b\n\n\n-ge\na是否大于等于b\n\n\n-le\na是否小于等于b\n\n\n字符串比较\n\n\n测试参数\n代表意义\n\n\n\ntest -z STRING\n判断STRING是否为空，如果为空，则返回true\n\n\ntest -n STRING\n判断STRING是否非空，如果非空，则返回true（-n\n\n\ntest str1 == str2\n判断str1是否等于str2\n\n\ntest str1 != str2\n判断str1是否不等于str2\n\n\n多重条件判定命令格式：\ntest -r filename -a -x filename\n\n\n\n测试参数\n代表意义\n\n\n\n-a    \n两条件是否同时成立\n\n\n-o    \n两条件是否至少一个成立\n\n\n!    \n取反。如 test ! -x file，当file不可执行时，返回true\n\n\n判断符号[][]与test用法几乎一模一样，更常用于if语句中。另外[[]]是[]的加强版，支持的特性更多。\n例如：\n[ 2 -lt 3 ]  # 为真，返回值为0echo $?  # 输出上个命令的返回值，输出0\nacs@9e0ebfcd82d7:~$ ls  # 列出当前目录下的所有文件homework  output.txt  test.sh  tmpacs@9e0ebfcd82d7:~$ [ -e test.sh ] &amp;&amp; echo \"exist\" || echo \"Not exist\"exist  # test.sh 文件存在acs@9e0ebfcd82d7:~$ [ -e test2.sh ] &amp;&amp; echo \"exist\" || echo \"Not exist\"Not exist  # testh2.sh 文件不存在\n注意：\n\n[]内的每一项都要用空格隔开\n中括号内的变量，最好用双引号括起来\n中括号内的常数，最好用单或双引号括起来\n\n例如：\nname=\"acwing yxc\"[ $name == \"acwing yxc\" ]  # 错误，等价于 [ acwing yxc == \"acwing yxc\" ]，参数太多[ \"$name\" == \"acwing yxc\" ]  # 正确\n\n判断语句if…then形式类似于C/C++中的if-else语句。\n单层if命令格式：\nif conditionthen    语句1    语句2    ...fi\n示例：\na=3b=4if [ \"$a\" -lt \"$b\" ] &amp;&amp; [ \"$a\" -gt 2 ]then    echo ${a}在范围内fi\n输出结果：\n3在范围内\n单层if-else命令格式\nif conditionthen    语句1    语句2    ...else    语句1    语句2    ...fi\n示例：\na=3b=4if ! [ \"$a\" -lt \"$b\" ]then    echo ${a}不小于${b}else    echo ${a}小于${b}fi\n输出结果：\n3小于4\n多层if-elif-elif-else命令格式\nif conditionthen    语句1    语句2    ...elif conditionthen    语句1    语句2    ...elif conditionthen    语句1    语句2else    语句1    语句2    ...fi\n示例：\na=4if [ $a -eq 1 ]then    echo ${a}等于1elif [ $a -eq 2 ]then    echo ${a}等于2elif [ $a -eq 3 ]then    echo ${a}等于3else    echo 其他fi\n输出结果：\n其他\ncase…esac形式类似于C/C++中的switch语句。\n命令格式\ncase $变量名称 in    值1)        语句1        语句2        ...        ;;  # 类似于C/C++中的break    值2)        语句1        语句2        ...        ;;    *)  # 类似于C/C++中的default        语句1        语句2        ...        ;;esac\n示例：\na=4case $a in    1)        echo ${a}等于1        ;;      2)        echo ${a}等于2        ;;      3)                                                        echo ${a}等于3        ;;      *)        echo 其他        ;;  esac\n输出结果：\n其他\n\n循环语句for…in…do…done命令格式：\nfor var in val1 val2 val3do    语句1    语句2    ...done\n示例1，输出a 2 cc，每个元素一行：\nfor i in a 2 ccdo    echo $idone\n示例2，输出当前路径下的所有文件名，每个文件名一行：\nfor file in `ls`do    echo $filedone\n示例3，输出1-10\nfor i in $(seq 1 10)do    echo $idone\n示例4，使用{1..10} 或者 {a..z}\nfor i in {a..z}do    echo $idone\nfor ((…;…;…)) do…done命令格式：\nfor ((expression; condition; expression))do    语句1    语句2done\n示例，输出1-10，每个数占一行：\nfor ((i=1; i&lt;=10; i++))do    echo $idone\nwhile…do…done循环命令格式：\nwhile conditiondo    语句1    语句2    ...done\n示例，文件结束符为Ctrl+d，输入文件结束符后read指令返回false。\nwhile read namedo    echo $namedone\nuntil…do…done循环当条件为真时结束。\n命令格式：\nuntil conditiondo    语句1    语句2    ...done\n示例，当用户输入yes或者YES时结束，否则一直等待读入。\nuntil [ \"${word}\" == \"yes\" ] || [ \"${word}\" == \"YES\" ]do    read -p \"Please input yes/YES to stop this program: \" worddone\nbreak命令跳出当前一层循环，注意与C/C++不同的是：break不能跳出case语句。\n示例\nwhile read namedo    for ((i=1;i&lt;=10;i++))    do        case $i in            8)                break                ;;            *)                echo $i                ;;        esac    donedone\n该示例每读入非EOF的字符串，会输出一遍1-7。该程序可以输入Ctrl+d文件结束符来结束，也可以直接用Ctrl+c杀掉该进程。\ncontinue命令跳出当前循环。\n示例：\nfor ((i=1;i&lt;=10;i++))do    if [ `expr $i % 2` -eq 0 ]    then        continue    fi    echo $idone\n该程序输出1-10中的所有奇数。\n死循环的处理方式如果Terminal可以打开该程序，则输入Ctrl+c即可。\n否则可以直接关闭进程：\n\n使用top命令找到进程的PID\n输入kill -9 PID即可关掉此进程\n\n函数简介bash中的函数类似于C/C++中的函数，但return的返回值与C/C++不同，返回的是exit code，取值为0-255，0表示正常结束。\n如果想获取函数的输出结果，可以通过echo输出到stdout中，然后通过$(function_name)来获取stdout中的结果。\n函数的return值可以通过$?来获取。\n命令格式：\n[function] func_name() {  # function关键字可以省略    语句1    语句2    ...}\n不获取 return值和stdout值示例\nfunc() {    name=yxc    echo \"Hello $name\"}func\n输出结果：\nHello yxc\n获取 return值和stdout值不写return时，默认return 0。\n示例\nfunc() {    name=yxc    echo \"Hello $name\"    return 123}output=$(func)ret=$?echo \"output = $output\"echo \"return = $ret\"\n输出结果：\noutput = Hello yxcreturn = 123\n函数的输入参数在函数内，$1表示第一个输入参数，$2表示第二个输入参数，依此类推。\n注意：函数内的$0仍然是文件名，而不是函数名。\n示例：\nfunc() {  # 递归计算 $1 + ($1 - 1) + ($1 - 2) + ... + 0    word=\"\"    while [ \"${word}\" != 'y' ] &amp;&amp; [ \"${word}\" != 'n' ]    do        read -p \"要进入func($1)函数吗？请输入y/n：\" word    done    if [ \"$word\" == 'n' ]    then        echo 0        return 0    fi      if [ $1 -le 0 ]     then        echo 0        return 0    fi      sum=$(func $(expr $1 - 1))    echo $(expr $sum + $1)}echo $(func 10)\n输出结果：\n55\n函数内的局部变量可以在函数内定义局部变量，作用范围仅在当前函数内。\n可以在递归函数中定义局部变量。\n命令格式：\nlocal 变量名=变量值\n例如：\n#! /bin/bashfunc() {    local name=yxc    echo $name}funcecho $name\n输出结果：\nyxc\n第一行为函数内的name变量，第二行为函数外调用name变量，会发现此时该变量不存在。\nexit命令简介exit命令用来退出当前shell进程，并返回一个退出状态；使用$?可以接收这个退出状态。\nexit命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。\nexit退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。\n示例：\n创建脚本test.sh，内容如下：\n#! /bin/bashif [ $# -ne 1 ]  # 如果传入参数个数等于1，则正常退出；否则非正常退出。then    echo \"arguments not valid\"    exit 1else    echo \"arguments valid\"    exit 0fi\n执行该脚本：\nacs@9e0ebfcd82d7:~$ chmod +x test.sh acs@9e0ebfcd82d7:~$ ./test.sh acwingarguments validacs@9e0ebfcd82d7:~$ echo $?  # 传入一个参数，则正常退出，exit code为00acs@9e0ebfcd82d7:~$ ./test.sh arguments not validacs@9e0ebfcd82d7:~$ echo $?  # 传入参数个数不是1，则非正常退出，exit code为11\n\n文件重定向简介每个进程默认打开3个文件描述符：\n\nstdin标准输入，从命令行读取数据，文件描述符为0\nstdout标准输出，向命令行输出数据，文件描述符为1\nstderr标准错误输出，向命令行输出数据，文件描述符为2可以用文件重定向将这三个文件重定向到其他文件中。\n\n重定向命令列表\n\n\n命令\n说明\n\n\n\ncommand &gt; file\n将stdout重定向到file中\n\n\ncommand &lt; file\n将stdin重定向到file中\n\n\ncommand &gt;&gt; file\n将stdout以追加方式重定向到file中\n\n\ncommand n&gt; file\n将文件描述符n重定向到file中\n\n\ncommand n&gt;&gt; file    \n将文件描述符n以追加方式重定向到file中\n\n\n输入和输出重定向echo -e \"Hello \\c\" &gt; output.txt  # 将stdout重定向到output.txt中echo \"World\" &gt;&gt; output.txt  # 将字符串追加到output.txt中read str &lt; output.txt  # 从output.txt中读取字符串echo $str  # 输出结果：Hello World\n同时重定向stdin和stdout创建bash脚本：\n#! /bin/bashread aread becho $(expr \"$a\" + \"$b\")\n创建input.txt，里面的内容为：\n34\n执行命令：\nacs@9e0ebfcd82d7:~$ chmod +x test.sh  # 添加可执行权限acs@9e0ebfcd82d7:~$ ./test.sh &lt; input.txt &gt; output.txt  # 从input.txt中读取内容，将输出写入output.txt中acs@9e0ebfcd82d7:~$ cat output.txt  # 查看output.txt中的内容7\n\n引入外部脚本简介类似于C/C++中的include操作，bash也可以引入其他文件中的代码。\n语法格式：\n. filename  # 注意点和文件名之间有一个空格或source filename\n示例\n创建test1.sh，内容为：\n#! /bin/bashname=yxc  # 定义变量name\n然后创建test2.sh，内容为：\n#! /bin/bashsource test1.sh # 或 . test1.shecho My name is: $name  # 可以使用test1.sh中的变量\n执行命令：\nacs@9e0ebfcd82d7:~$ chmod +x test2.sh acs@9e0ebfcd82d7:~$ ./test2.sh My name is: yxc\n\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","shell"]},{"title":"ssh","url":"/2021/10/13/ssh/","content":"音乐小港\n    \n\n\nsshssh登录基本用法远程登录服务器：\nssh user@hostname\n\nuser: 用户名\nhostname: IP地址或域名第一次登录时会提示：The authenticity of host '123.57.47.211 (123.57.47.211)' can't be established.ECDSA key fingerprint is SHA256:iy237yysfCe013/l+kpDGfEG9xxHxm0dnxnAbJTPpG8.Are you sure you want to continue connecting (yes/no/[fingerprint])?\n输入yes，然后回车即可。\n\n这样会将该服务器的信息记录在~/.ssh/known_hosts文件中。\n然后输入密码即可登录到远程服务器中。\n默认登录端口号为22。如果想登录某一特定端口：\nssh user@hostname -p 22\n配置文件创建文件 ~/.ssh/config。\n然后在文件中输入：\nHost myserver1    HostName IP地址或域名    User 用户名Host myserver2    HostName IP地址或域名    User 用户名\n之后再使用服务器时，可以直接使用别名myserver1、myserver2。\n密钥登录创建密钥：\nssh-keygen\n然后一直回车即可。\n执行结束后，~/.ssh/目录下会多两个文件：\n\nid_rsa：私钥\nid_rsa.pub：公钥\n\n之后想免密码登录哪个服务器，就将公钥传给哪个服务器即可。\n例如，想免密登录myserver服务器。则将公钥中的内容，复制到myserver中的~/.ssh/authorized_keys文件里即可。\n也可以使用如下命令一键添加公钥：\nssh-copy-id myserver\n执行命令命令格式：\nssh user@hostname command\n例如：\nssh user@hostname ls -a\n或者\n# 单引号中的$i可以求值ssh myserver 'for ((i = 0; i &lt; 10; i ++ )) do echo $i; done'\n或者\n双引号中的$i不可以求值ssh myserver \"for ((i = 0; i &lt; 10; i ++ )) do echo $i; done\"\n\n\n讲解:\na=1ssh myserver  \"echo $a\"ssh myserver  'echo $a'\n双引号是在本地服务器进行转义了，所以传过去命令不是echo ，而是单引号传过去的是a\n\nscp传文件基本用法命令格式：\nscp source destination\n将source路径下的文件复制到destination中\n一次复制多个文件：\nscp source1 source2 destination\n复制文件夹：\nscp -r ~/tmp myserver:/home/acs/\n将本地家目录中的tmp文件夹复制到myserver服务器中的/home/acs/目录下。\nscp -r ~/tmp myserver:homework/\n将本地家目录中的tmp文件夹复制到myserver服务器中的~/homework/目录下。\nscp -r myserver:homework .\n将myserver服务器中的~/homework/文件夹复制到本地的当前路径下。\n指定服务器的端口号：\nscp -P 22 source1 source2 destination\n注意： scp的-r -P等参数尽量加在source和destination之前。\n使用scp配置其他服务器的vim和tmuxscp ~/.vimrc ~/.tmux.conf myserver:\n\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","常用命令","ssh"]},{"title":"thrift","url":"/2021/10/13/thrift/","content":"音乐小港\n    \n\n\nThrift简介Thrift是一个轻量级、跨语言的远程服务调用框架，最初由Facebook开发，后面进入Apache开源项目。它通过自身的IDL中间语言, 并借助代码生成引擎生成各种主流语言的RPC服务端/客户端模板代码。\nThrift支持多种不同的编程语言，包括C++、Java、Python、PHP、Ruby等\n点我去Thrift官网\n特点(一) 开发速度快\n通过编写RPC接口Thrift IDL文件，利用编译生成器自动生成服务端骨架(Skeletons)和客户端桩(Stubs)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。\n\n服务端：只需要按照服务骨架即接口，编写好具体的业务处理程序(Handler)即实现类即可。\n客户端：只需要拷贝IDL定义好的客户端桩和服务对象，然后就像调用本地对象的方法一样调用远端服务。\n\n(二) 接口维护简单\n通过维护Thrift格式的IDL（接口描述语言）文件（注意写好注释），即可作为给Client使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且Thrift协议可灵活支持接口的可扩展性。\n(三) 学习成本低\n因为其来自Google Protobuf开发团队，所以其IDL文件风格类似Google Protobuf，且更加易读易懂；特别是RPC服务接口的风格就像写一个面向对象的Class一样简单。\n初学者只需参照：thrift.apache.org/，一个多小时就可以理解Thrift IDL文件的语法使用。\n(四) 多语言/跨语言支持\nThrift支持C++、 Java、Python、PHP、Ruby、Erlang、Perl、Haskell、C#、Cocoa、JavaScript、Node.js、Smalltalk等多种语言，即可生成上述语言的服务器端和客户端程序。\n对于我们经常使用的Java、PHP、Python、C++支持良好，虽然对iOS环境的Objective-C(Cocoa)支持稍逊，但也完全满足我们的使用要求。\n(五) 稳定/广泛使用\nThrift在很多开源项目中已经被验证是稳定和高效的，例如Cassandra、Hadoop、HBase等；国外在Facebook中有广泛使用，国内包括百度、美团小米、和饿了么等公司。\n使用\n编写Thrift接口文件\n使用thrift编译\n实现业务代码\n\n编写thrift文件使用Thrift开发程序，首先要做的事情就是对接口进行描述， 然后再使用Thrift将接口的描述文件编译成对应语言的版本\n命名空间thrift文件命名一般都是以.thrift作为后缀：XXX.thrift，可以在该文件的开头为该文件加上命名空间限制，格式为：\nnamespace 语言名称 名称\n例如对c++来说，有：\nnamespace cpp match_service\n\n数据类型大小写敏感，它共支持以下几种基本的数据类型：\n\nstring， 字符串类型，注意是全部小写形式;\ni16, 16位整形类型;\ni32，32位整形类型，对应C/C++/java中的int类型;\ni64，64位整形，对应C/C++/java中的long类型;\nbyte，8位的字符类型，对应C/C++中的char，java中的byte类型;\nbool, 布尔类型，对应C/C++中的bool，java中的boolean类型;\ndouble，双精度浮点类型，对应C/C++/java中的double类型;\nvoid，空类型，对应C/C++/java中的void类型；该类型主要用作函数的返回值;\n\n除上述基本类型外，IDL还支持以下类型：\n\nmap，map类型\n\n\n例如，定义一个map对象：map[HTML_REMOVED] newmap;\n\n\nset，集合类型\n\n\n例如，定义set[HTML_REMOVED]对象：set[HTML_REMOVED] aSet;\n\n\nlist，链表类型\n\n\n例如，定义一个list[HTML_REMOVED]对象：list[HTML_REMOVED] aList;\n\nstruct，自定义结构体类型，在IDL中可以自己定义结构体，对应C中的struct，c++中的struct和class，java中的class。例如：\nstruct User{      1: i32 id,      2: string name,      3: i32 score}\n注意，在struct定义结构体时需要对每个结构体成员用序号标识：“序号: ”。\n函数接口文件中对所有接口函数的描述都放在service中，service的名字可以自己指定，该名字也将被用作生成的特定语言接口文件的名字。\n接口函数需要对参数使用序号标号，除最后一个接口函数外，要以,结束对函数的描述。\n如：\nnamespace cpp match_servicestruct User {    1: i32 id,    2: string name,    3: i32 score}service Match {    i32 add_user(1: User user, 2: string info),    i32 remove_user(1: User user, 2: string info),}\n\n实战准备工作\n创建项目文件夹thrift_project\n\n业务逻辑图\n\n\n\n\n游戏节点，创建game文件夹；\n\n匹配系统节点，创建match_system文件夹；\n\nthrift相关文件,创建thrift文件夹\n\n\n服务端的建立对于匹配系统的thrift相关配置，我们在thrift文件夹下，创建match.thrift文件\n打开thrift官网，在上方选择Tutorial项，查看thrift官方教程\n点击下方的tutorial.thrift进入一个示例文件\n变写thrift配置文件，只需要在文件中写明接口和对象.然后执行命令\nthrift -r --gen &lt;语言名&gt; &lt;.thrift文件的路径&gt;\n就会生成各种配置和连接文件，还有代码框架，只需要在框架中实现自己的业务即可\n步骤1.在thrift文件夹下，编辑match.thrift文件，用来生成匹配系统服务端的一系列文件\nmatch.thrift 文件内容如下：\n##c++命名空间namespace cpp match_servicestruct User {    1: i32 id,    2: string name,    3: i32 score}service Match {    /**     * user: 添加的用户信息     * info: 附加信息     * 在匹配池中添加一个名用户     */    i32 add_user(1: User user, 2: string info),    /**     * user: 删除的用户信息     * info: 附加信息     * 从匹配池中删除一名用户     */    i32 remove_user(1: User user, 2: string info),}\n\n2.进入到match_system文件夹，创建src文件夹。在src下执行语句：\nthrift -r --gen cpp ../../thrift/match.thrift\n这样，thrift服务端的一系列文件就会生成在src文件夹中的gen-cpp文件夹下，为了划分业务模块将gen-cpp重命名为match_server\nmv gen-cpp match_server\n文件结构如下：\n.`-- match_server    |-- Match.cpp    |-- Match.h    |-- Match_server.skeleton.cpp    |-- match_types.cpp    `-- match_types.h\n其中Match_server.skeleton.cpp: 服务端的代码框架，具体业务就是在这个文件夹下编写实现\n将Match_server.skeleton.cpp移动到match_system/src下并重命名为main.cpp，match_system的整个业务逻辑就是在这个文件中实现\n3.初始main.cpp的改动\n\n之前main.cpp在match_server下，现在在match_system/src下，所以main.cpp中对Match.h头文件的引入需要修改路径\n文件中的两个函数int32_t add_user和int32_t remove_user需要有返回值，原来没有，会报警告，需要手动加上\n\nmain.cpp初始文件内容如下：\n// This autogenerated skeleton file illustrates how to build a server.// You should copy it to another filename to avoid overwriting it.#include \"match_server/Match.h\"#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using namespace  ::match_service;class MatchHandler : virtual public MatchIf { public:  MatchHandler() {    // Your initialization goes here  }  int32_t add_user(const User&amp; user, const std::string&amp; info) {    // Your implementation goes here    printf(\"add_user\\n\");    return 0;  }  int32_t remove_user(const User&amp; user, const std::string&amp; info) {    // Your implementation goes here    printf(\"remove_user\\n\");    return 0;  }};int main(int argc, char **argv) {  int port = 9090;  ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());  ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));  ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));  ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());  ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);  server.serve();  return 0;}\n\nc++文件的编译、链接和运行C++的编译过程(注意大小写)假设我有一个main.cpp文件\n\n-E：只对文件进行预处理，不进行编译和汇编。g++ -E main.cpp——&gt;在dos命令行查看某文件的预处理过程，如果你想查看详细的预处理，可以重定向到一个文件中，如：g++ -E main.cpp -o main.i\n\n-s：编译到汇编语言，不进行汇编和链接,即只激活预处理和编译，生成汇编语言,如果你想查看详细的编译，可以重定向到一个文件中，如：g++ -S main.cpp -o main.s\n\n-c:编译到目标代码,g++ -c main.s -o 文件名.o\n\n-o:生成链接文件: 如果该文件是独立的，与其他自己编写的文件无依赖关系。直接g++ main.o -o 生成的可执行文件的文件名，\n\n\n假设该文件依赖其他源文件（不需要加入头文件）temp.cpp,在对temp.cpp文件进行预处理-&gt;编译-&gt;汇编后，使用指令g++ temp.o main.o -o main\n\n.\\:执行文件，输出结果。如: .\\main，当然你可以直接g++ main.cpp temp.cpp -o main 生成目标文件让编译器自动为你处理其他流程。步骤\n编译src文件夹下的所有.cpp文件g++ -c *.cpp\n将所有生成的.o文件链接成一个可执行文件，要用到thrift动态链接库g++ *.o -o main -lthrift\n执行生成的可执行文件main./main\n为了判断文件是否正确执行，可以在main.cpp中写一些输出语句，验证效果\n\n4.将项目版本提交git，提交时，一般会删除中间生成的文件和可执行文件\ngit add .git restore --stage *.ogit restore --stage match_system/src/maingit commit -m \"first can run\"\n\n客户端的实现python文件的执行python 文件路径\n步骤\n在game下创建src,在src下执行：thrift -r --gen py ../../thrift/match.thrift\n这样，thrift服务端的一系列文件就会生成在src文件夹中的gen-py文件夹下，为了划分业务模块将gen-py重命名为match_client\n\n文件结构如下：\n.|-- __init__.py`-- match    |-- Match-remote    |-- Match.py    |-- __init__.py    |-- constants.py    `-- ttypes.py\n因为我们只需要实现客户端，不需要服务端，所以可以把Match-remote删除\n\n在src下创建文件client.py，将 Apache Thrift - Python ，页面中，client中的代码复制到该文件中，并将代码进行适当的改动和删除，client.py中的初始代码如下：from match_client.match import Matchfrom match_client.match.ttypes import Userfrom thrift import Thriftfrom thrift.transport import TSocketfrom thrift.transport import TTransportfrom thrift.protocol import TBinaryProtocoldef main():    # Make socket    transport = TSocket.TSocket('127.0.0.1', 9090)    # Buffering is critical. Raw sockets are very slow    transport = TTransport.TBufferedTransport(transport)    # Wrap in a protocol    protocol = TBinaryProtocol.TBinaryProtocol(transport)    # Create a client to use the protocol encoder    client = Match.Client(protocol)    # Connect!    transport.open()    user = User(1,\"lyt\",50000)    client.add_user(user,\"\")    # Close!    transport.close()if __name__ == \"__main__\":    main()\n运行查错\n先在thrift_project/match_system/src下，执行:./main,使服务端运行\n再在thrift_project/game/src下，执行：python3 client.py,使客户端运行 \n观察服务端运行处有无相应输出，若有，说明成功运行\n\n我们可以将此版本代码提交git\n\n第一个简单输入输出版的clientfrom match_client.match import Matchfrom match_client.match.ttypes import Userfrom thrift import Thriftfrom thrift.transport import TSocketfrom thrift.transport import TTransportfrom thrift.protocol import TBinaryProtocolfrom sys import stdindef operate(op: str, user_id: int, username: str, score: int):    # Make socket    transport = TSocket.TSocket('localhost', 9090)    # Buffering is critical. Raw sockets are very slow    transport = TTransport.TBufferedTransport(transport)    # Wrap in a protocol    protocol = TBinaryProtocol.TBinaryProtocol(transport)    # Create a client to use the protocol encoder    client = Match.Client(protocol)    # Connect!    transport.open()    user = User(user_id, username, score)    if op == \"add\":        client.add_user(user, \"\")    elif op == \"remove\":        client.remove_user(user, \"\")    # Close!    transport.close()def main():    for line in stdin:        op, user_id, username, score = line.split(\" \")        operate(op, int(user_id), username, int(score))if __name__ == \"__main__\":    main()\n进行运行查错步骤并做正确输入，如果服务端处有相应输出，说明函数调用成功，运行成功\n\n我们可以将此版本代码提交git\n服务端具体匹配业务的实现多线程编程学习各种语言多线程，需要关注的要点：\n\n用哪些头文件\n如何创建一个线程(创建线程要用哪些函数)\n如何使用锁(相关的函数)\n如何使用条件变量\n\nc++多线程\n参考博客：\nC++多线程编程 - kaleidopink - 博客园 (cnblogs.com)\nC多线程编程_Nine days-CSDN博客_c多线程\n步骤\n继续编写thrift_project/match_system/src下的main.cpp先添加头文件：#include \"mutex\"  //锁的头文件#include \"thread\"  //线程的头文件#include \"condition_variable\"  //条件变量的头文件#include \"queue\"\n傻瓜式匹配版main.cpp:// 这个自动生成的框架文件演示了如何构建服务器。// 你应该把它复制到另一个文件名以避免覆盖它。#include \"match_server/Match.h\"#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;#include &lt;iostream&gt;#include \"mutex\"  //锁的头文件#include \"thread\"  //线程的头文件#include \"condition_variable\"  //条件变量的头文件#include \"queue\"#include \"vector\"using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using namespace std;using namespace ::match_service;struct Task {    User user;    string type;};struct MessageQueue {    //队列是互斥的，同时只能有一个线程访问队列    queue&lt;Task&gt; q;    mutex m;    condition_variable cv;} message_queue;class Poll {public:    void add(User user) {        users.push_back(user);    }    void remove(User user) {        for (uint32_t i = 0; i &lt; users.size(); i++) {            if (users[i].id == user.id) {                users.erase(users.begin() + i);                break;            }        }    }    void match() {        while (users.size() &gt; 1) {//            printf(\"队列长度为: %ld\\n\", users.size());            auto player1 = users[0];            auto player2 = users[1];            users.erase(users.begin());            users.erase(users.begin());            save_result(player1.id, player2.id);        }    }    void save_result(int a, int b) {        printf(\" %d 和 %d 匹配成功\\n\", a, b);    }private:    vector&lt;User&gt; users;} pool;class MatchHandler : virtual public MatchIf {public:    MatchHandler() {        // 在这里初始化    }    int32_t add_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"add_user\\n\");        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁        message_queue.q.push({user, \"add\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }    int32_t remove_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"remove_user\\n\");        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁        message_queue.q.push({user, \"remove\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }};//线程操作的函数void consume_task() {    while (true) {        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁        if (message_queue.q.empty()) {            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里            //continue            message_queue.cv.wait(lock1);        } else {            auto task = message_queue.q.front();            message_queue.q.pop();            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁            lock1.unlock();            //具体任务            if (task.type == \"add\") {                pool.add(task.user);//                printf(\"执行了1次add\");            } else if (task.type == \"remove\") {                pool.remove(task.user);            }            pool.match();        }    }}int main(int argc, char **argv) {    int port = 9090;    ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());    ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));    ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));    ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());    ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);    printf(\"Match server start\\n\");    thread matching_thread(consume_task);    server.serve();    return 0;}\n编译链接main.cpp先编译main.cpp,在链接时，要用到thrift动态链接库和线程相关的动态链接库，所以链接时应该执行：g++ *.o -o main -lthrift -pthread\n数据存储客户端的实现获取一个字符串的MD5加密串执行命令：md5sum\n回车后输入原字符串。在回车后按ctrl+d,就会生成MD5加密串\n\n步骤：\n在thrift文件夹下，编辑save.thrift，用来生成数据存储客户端的一系列文件这里的thrift接口由y总给出，可以在上课代码的git上找到，save.thrift中的代码如下：namespace cpp save_serviceservice Save {    /**     * username: myserver的名称     * password: myserver的密码的md5sum的前8位     * 用户名密码验证成功会返回0，验证失败会返回1     * 验证成功后，结果会被保存到myserver:homework/lesson_6/result.txt中     */    i32 save_data(1: string username, 2: string password, 3: i32 player1_id, 4: i32 player2_id)}\n在match_system/src下执行：thrift -r --gen cpp ../../thrift/save.thrift\n这样，thrift服务端的一系列文件就会生成在src文件夹中的gen-cpp文件夹下，为了划分业务模块将gen-cpp重命名为save_client\n\n注意：\n由于c++整个项目只能有一个main函数，而整个服务端的逻辑都在thrift_project/match_system/src下的main.cpp实现。所以一定要删除thrift_project/match_system/src/save_client下的Save_server.skeleton.cpp。而python没有这个问题，所以在用python实现客户端时，主框架文件可删可不删。\n\n改动main.cpp将数据存储端的业务写进去改动点：\n引入头文件，即save_client/Save.h\n补全命名空间，即添加using namespace ::save_service;\n在class Pool中的save_resut函数中，添加官网 C++样例的client中的main函数中的所有代码\n由于数据存储是实现在myserver上，所以在连接时要更改ip地址。myserver的ip地址可以执行homework 4 getinfo查看\n将CalculatorClient改为SaveClient\n将transport-&gt;open()和transport-&gt;close();之间的教程代码删除，在此之间实现自己的业务这里给出save_result函数：void save_result(int a, int b) {    printf(\" %d 和 %d 匹配成功\\n\", a, b);    std::shared_ptr&lt;TTransport&gt; socket(new TSocket(\"123.57.47.211\", 9090));    std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));    std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));    CalculatorClient client(protocol);    try {        transport-&gt;open();        //----------在此之间实现自己的业务------------            //第二个参数是myserver密码的MD5值的前8位        client.save_data(\"acs_1642\",\"6a46581f\",a,b);        //-----------------------------------------        transport-&gt;close();    } catch (TException &amp;tx) {        cout &lt;&lt; \"ERROR: \" &lt;&lt; tx.what() &lt;&lt; endl;    }}\n编译运行，并验证结果\n编译链接：g++ -c save_client/*.cppg++ -c main.cppg++ *.o -o main -lthrift -pthread\n登录到myserver服务器上查看存储的结果：ssh myservercd homework/lesson_6 cat result.txt\n可以把此版本提交git\n\n匹配系统2.0(按照分差匹配用户)c++lamda表达式C++之Lambda表达式 - 季末的天堂 - 博客园 (cnblogs.com)\n改动main.cpp:\n// 这个自动生成的框架文件演示了如何构建服务器。// 你应该把它复制到另一个文件名以避免覆盖它。#include \"match_server/Match.h\"#include \"save_client/Save.h\"#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TTransportUtils.h&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;  //锁的头文件#include &lt;thread&gt;  //线程的头文件#include &lt;condition_variable&gt;  //条件变量的头文件#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;unistd.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using namespace ::match_service;using namespace ::save_service;using namespace std;struct Task {    User user;    string type;};struct MessageQueue {    //队列是互斥的，同时只能有一个线程访问队列    queue &lt;Task&gt; q;    mutex m;    condition_variable cv;} message_queue;class Poll {public:    void add(User user) {        users.push_back(user);    }    void remove(User user) {        for (uint32_t i = 0; i &lt; users.size(); i++) {            if (users[i].id == user.id) {                users.erase(users.begin() + i);                break;            }        }    }    void match() {        while (users.size() &gt; 1) {//            printf(\"队列长度为: %ld\\n\", users.size());            sort(users.begin(),users.end(),[&amp;](User &amp;a,User b){                return a.score&lt;b.score;            });            bool flag = true;            for(uint32_t i = 1 ; i &lt;users.size(); i++) {              auto a = users[i-1],b = users[i];                if (b.score-a.score&lt;=50){                    users.erase(users.begin()+i,users.begin()+i+1);                    save_result(a.id,b.id);                    flag = false;                    break;                }            }            if (flag){                break;            }        }    }    void save_result(int a, int b) {        printf(\" %d 和 %d 匹配成功\\n\", a, b);        std::shared_ptr&lt;TTransport&gt; socket(new TSocket(\"123.57.47.211\", 9090));        std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));        std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));        SaveClient client(protocol);        try {            transport-&gt;open();            //----------在此之间实现自己的业务------------                //第二个参数是myserver密码的MD5值的前8位            client.save_data(\"acs_1642\",\"6a46581f\",a,b);            //-----------------------------------------            transport-&gt;close();        } catch (TException &amp;tx) {            cout &lt;&lt; \"ERROR: \" &lt;&lt; tx.what() &lt;&lt; endl;        }    }private:    vector &lt;User&gt; users;} pool;class MatchHandler : virtual public MatchIf {public:    MatchHandler() {        // 在这里初始化    }    int32_t add_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"add_user\\n\");        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁        message_queue.q.push({user, \"add\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }    int32_t remove_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"remove_user\\n\");        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁        message_queue.q.push({user, \"remove\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }};//线程操作的函数void consume_task() {    while (true) {        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁        if (message_queue.q.empty()) {            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里            //continue//            message_queue.cv.wait(lock1);            lock1.unlock();            pool.match();            sleep(1);            //当队列为空时。当前线程放弃持有锁，由其他线程持有锁，在进行匹配。这个过程1s后，再进行后面的判断        } else {            auto task = message_queue.q.front();            message_queue.q.pop();            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁            lock1.unlock();            //具体任务            if (task.type == \"add\") {                pool.add(task.user);//                printf(\"执行了1次add\");            } else if (task.type == \"remove\") {                pool.remove(task.user);            }            pool.match();        }    }}int main(int argc, char **argv) {    int port = 9090;    ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());    ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));    ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));    ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());    ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);    printf(\"Match server start\\n\");    thread matching_thread(consume_task);    server.serve();    return 0;}\n\n匹配系统3.0(升级为多线程服务器)之前的版本都是用一个线程来add和remove user，想要提高效率和并发量，可以将服务端升级为多线程版本\n步骤引入官网 C++样例的Server中,main.cpp没有的头文件。\n将main函数中的TSimpleServer即相关函数，替换成官网 C++样例的Server中的main函数中的TThreadedServer相关内容\n将官网 C++样例的Server中的class CalculatorCloneFactory相关内容加进来\n将文件中的所有Calculator替换为Match,在vim中的具体操作为：\n:1,$s/Calculator/Match/g\n\n将\nvoid releaseHandler(::shared::SharedServiceIf *handler) override { delete handler; }\n替换为：\nvoid releaseHandler(MatchIf *handler) override { delete handler; }\n编译运行检查错误\n匹配系统4.0(随时间扩大匹配阈值)// 这个自动生成的框架文件演示了如何构建服务器。// 你应该把它复制到另一个文件名以避免覆盖它。#include \"match_server/Match.h\"#include \"save_client/Save.h\"#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/server/TThreadPoolServer.h&gt;#include &lt;thrift/server/TThreadedServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TTransportUtils.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;#include &lt;thrift/transport/TTransportUtils.h&gt;#include &lt;thrift/concurrency/ThreadManager.h&gt;#include &lt;thrift/concurrency/ThreadFactory.h&gt;#include &lt;thrift/TToString.h&gt;#include &lt;iostream&gt;#include &lt;mutex&gt;  //锁的头文件#include &lt;thread&gt;  //线程的头文件#include &lt;condition_variable&gt;  //条件变量的头文件#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;unistd.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using namespace ::match_service;using namespace ::save_service;using namespace std;struct Task {    User user;    string type;};struct MessageQueue {    //队列是互斥的，同时只能有一个线程访问队列    queue&lt;Task&gt; q;    mutex m;    condition_variable cv;} message_queue;class Poll {public:    void add(User user) {        users.push_back(user);        wt.push_back(0);    }    void remove(User user) {        for (uint32_t i = 0; i &lt; users.size(); i++) {            if (users[i].id == user.id) {                users.erase(users.begin() + i);                break;            }        }     }    bool check_match(uint32_t i, uint32_t j) {        auto a = users[i], b = users[j];        int dt = abs(a.score - b.score);        int a_max_dif = wt[i] * 50;        int b_max_dif = wt[j] * 50;        return dt &lt;= a_max_dif &amp;&amp; dt &lt;= b_max_dif;    }    void match() {        for (uint32_t i = 0; i &lt; wt.size(); i++)            wt[i]++;   // 等待秒数 + 1//            sort(users.begin(), users.end(), [&amp;](User &amp;a, User b) {//                return a.score &lt; b.score;//            });        while (users.size() &gt; 1) {            bool flag = true;            for (uint32_t i = 0; i &lt; users.size(); i++) {                for (uint32_t j = i + 1; j &lt; users.size(); j++) {                    if (check_match(i, j)) {                        auto a = users[i], b = users[j];                        users.erase(users.begin() + j);                        users.erase(users.begin() + i);                        wt.erase(wt.begin() + j);                        wt.erase(wt.begin() + i);                        save_result(a.id, b.id);                        flag = false;                        break;                    }                }                if (!flag) break;            }            if (flag) break;        }    }    void save_result(int a, int b) {        printf(\" %d 和 %d 匹配成功\\n\", a, b);        std::shared_ptr&lt;TTransport&gt; socket(new TSocket(\"123.57.47.211\", 9090));        std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));        std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));        SaveClient client(protocol);        try {            transport-&gt;open();            //----------在此之间实现自己的业务------------            //第二个参数是myserver密码的MD5值的前8位            client.save_data(\"acs_1642\", \"6a46581f\", a, b);            //-----------------------------------------            transport-&gt;close();        } catch (TException &amp;tx) {            cout &lt;&lt; \"ERROR: \" &lt;&lt; tx.what() &lt;&lt; endl;        }    }private:    vector&lt;User&gt; users;    vector&lt;int&gt; wt;} pool;class MatchHandler : virtual public MatchIf {public:    MatchHandler() {        // 在这里初始化    }    int32_t add_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"add_user\\n\");        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁        message_queue.q.push({user, \"add\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }    int32_t remove_user(const User &amp;user, const std::string &amp;info) {        // 在这里实现接口        printf(\"remove_user\\n\");        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁        message_queue.q.push({user, \"remove\"});        //当有操作时，应该唤醒线程        message_queue.cv.notify_all();        return 0;    }};class MatchCloneFactory : virtual public MatchIfFactory {public:    ~MatchCloneFactory() override = default;    MatchIf *getHandler(const ::apache::thrift::TConnectionInfo &amp;connInfo) override {        std::shared_ptr&lt;TSocket&gt; sock = std::dynamic_pointer_cast&lt;TSocket&gt;(connInfo.transport);//        cout &lt;&lt; \"Incoming connection\\n\";//        cout &lt;&lt; \"\\tSocketInfo: \"  &lt;&lt; sock-&gt;getSocketInfo() &lt;&lt; \"\\n\";//        cout &lt;&lt; \"\\tPeerHost: \"    &lt;&lt; sock-&gt;getPeerHost() &lt;&lt; \"\\n\";//        cout &lt;&lt; \"\\tPeerAddress: \" &lt;&lt; sock-&gt;getPeerAddress() &lt;&lt; \"\\n\";//        cout &lt;&lt; \"\\tPeerPort: \"    &lt;&lt; sock-&gt;getPeerPort() &lt;&lt; \"\\n\";        return new MatchHandler;    }    void releaseHandler(MatchIf *handler) override {        delete handler;    }};//线程操作的函数void consume_task() {    while (true) {        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁        if (message_queue.q.empty()) {            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里            //continue//            message_queue.cv.wait(lock1);            lock1.unlock();            pool.match();            sleep(1);            //当队列为空时。当前线程放弃持有锁，由其他线程持有锁，在进行匹配。这个过程1s后，再进行后面的判断        } else {            auto task = message_queue.q.front();            message_queue.q.pop();            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁            lock1.unlock();            //具体任务            if (task.type == \"add\") {                pool.add(task.user);//                printf(\"执行了1次add\");            } else if (task.type == \"remove\") {                pool.remove(task.user);            }//            pool.match();        }    }}int main(int argc, char **argv) {    TThreadedServer server(            std::make_shared&lt;MatchProcessorFactory&gt;(std::make_shared&lt;MatchCloneFactory&gt;()),            std::make_shared&lt;TServerSocket&gt;(9090), //port            std::make_shared&lt;TBufferedTransportFactory&gt;(),            std::make_shared&lt;TBinaryProtocolFactory&gt;()    );    printf(\"Match server start\\n\");    thread matching_thread(consume_task);    server.serve();    return 0;}\n\n案例代码：参考来源链接：10631179\n","categories":["Linux 基础"],"tags":["Linux","thrift"]},{"title":"vim教程","url":"/2021/10/02/vim/","content":"音乐小港\n    \n\n\nVim教程介绍Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。\n简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。\n连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。\n功能：\n命令行模式下的文本编辑器。\n根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。\n使用方式：vim filename\n如果已有该文件，则打开它。\n如果没有该文件，则打开个一个新的文件，并命名为filename\n\n\n\n模式：\n一般命令模式 默认模式。命令输入方式：类似于打游戏放技能，按不符，即可进行不同操作。可以复制、粘贴、删除文本等。\n编辑模式 在一般命令模式里按下i，会进入编辑模式。 按下ESC会退出编辑模式，返回到一般命令模式。\n命令行模式 在一般命令模式里按下:/?三个字母中的任意一个，会进令行模式。命令行在最下面。 可以查找、替换、保存、退出、配置编辑器等。\n\n操作：\n\ni：进入编辑模式\nESC：进入一般命令模式\nh 或 左箭头键：光标向左移动一个字符\nj 或 向下箭头：光标向下移动一个字符\nk 或 向上箭头：光标向上移动一个字符\nl 或 向右箭头：光标向右移动一个字符\nn&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右这一行的n个字符\n0 或 功能键[Home]：光标移动到本行开头\n$ 或 功能键[End]：光标移动到本行末尾\nG：光标移动到最后一行\n:n 或 nG：n为数字，光标移动到第n行\ngg：光标移动到第一行，相当于1G\nn&lt;Enter&gt;：n为数字，光标向下移动n行\n/word：向光标之下寻找第一个值为word的字符串。\n?word：向光标之上寻找第一个值为word的字符串。\nn：重复前一个查找操作\nN：反向重复前一个查找操作\n:n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2间寻找word1这个字符串，并将该字符串替换为word2\n:1,$s/word1/word2/g：将全文的word1替换为word2\n:1,$s/word1/word2/gc：将全文的word1替换为word2，替换前要求用户确认。\nv：选中文本\nd：删除选中的文本\ndd: 删除当前行\ny：复制选中的文本\nyy: 复制当前行\np: 将复制的数据在光标的下一行/下一个位置粘贴\nu：撤销\nCtrl + r：取消撤销\n大于号 &gt;：将选中的文本整体向右缩进一次\n小于号 &lt;：将选中的文本整体向左缩进一次\n:w 保存\n:w! 强制保存\n:q 退出\n:q! 强制退出\n:wq 保存并退出\n:set paste 设置成粘贴模式，取消代码自动缩进\n:set nopaste 取消粘贴模式，开启代码自动缩进\n:set nu 显示行号\n:set nonu 隐藏行号\ngg=G：将全文代码格式化\n:noh 关闭查找关键词高亮\nCtrl + q：当vim卡死时，可以取消当前正在执行的命令\n\n异常处理：\n每次用 vim 编辑文件时，会自动创建一个 .filename.swp 的临时文件。\n如果打开某个文件时，该文件的swp文件已存在，则会报错。此决办法有两种：\n\n找到正在打开该文件的程序，并退出\n直接删掉该swp文件即可\n\n\n\n经自定义设置的vim的置内容在下方给出\n\ntmux配置.vimrc\n\" An example for a vimrc file.\"\" To use it, copy it to\"     for Unix and OS/2:  ~/.vimrc\"\t      for Amiga:  s:.vimrc\"  for MS-DOS and Win32:  $VIM\\_vimrc\"\t    for OpenVMS:  sys$login:.vimrc\" When started as \"evim\", evim.vim will already have done these settings.if v:progname =~? \"evim\"  finishendif\" Use Vim settings, rather then Vi settings (much better!).\" This must be first, because it changes other options as a side effect.set nocompatible\" allow backspacing over everything in insert modeset backspace=indent,eol,startif has(\"vms\")  set nobackup\t\t\" do not keep a backup file, use versions insteadelse  set backup\t\t\" keep a backup fileendifset history=50\t\t\" keep 50 lines of command line historyset ruler\t\t\" show the cursor position all the timeset showcmd\t\t\" display incomplete commandsset incsearch\t\t\" do incremental searching\"==========================================================================\"My Setting-sunshanlu\"==========================================================================vmap &lt;leader&gt;y :w! /tmp/vitmp&lt;CR&gt;nmap &lt;leader&gt;p :r! cat /tmp/vitmp&lt;CR&gt;\"语法高亮syntax enablesyntax on\"显示行号set nu\"修改默认注释颜色\"hi Comment ctermfg=DarkCyan\"允许退格键删除\"set backspace=2\"启用鼠标set mouse=aset selection=exclusiveset selectmode=mouse,key\"按C语言格式缩进set cindentset autoindentset smartindentset shiftwidth=4\" 允许在有未保存的修改时切换缓冲区\"set hidden\" 设置无备份文件set writebackupset nobackup\"显示括号匹配set showmatch\"括号匹配显示时间为1(单位是十分之一秒)set matchtime=5\"显示当前的行号列号：set ruler\"在状态栏显示正在输入的命令set showcmdset foldmethod=syntax\"默认情况下不折叠set foldlevel=100\" 开启状态栏信息set laststatus=2\" 命令行的高度，默认为1，这里设为2set cmdheight=2\" 显示Tab符，使用一高亮竖线代替set list\"set listchars=tab:\\|\\ ,set listchars=tab:&gt;-,trail:-\"侦测文件类型filetype on\"载入文件类型插件filetype plugin on\"为特定文件类型载入相关缩进文件filetype indent on\" 启用自动补全filetype plugin indent on \"设置编码自动识别, 中文引号显示filetype on \"打开文件类型检测\"set fileencodings=euc-cn,ucs-bom,utf-8,cp936,gb2312,gb18030,gbk,big5,euc-jp,euc-kr,latin1set fileencodings=utf-8,gb2312,gbk,gb18030\"这个用能很给劲，不管encoding是什么编码，都能将文本显示汉字\"set termencoding=gb2312set termencoding=utf-8\"新建文件使用的编码set fileencoding=utf-8\"set fileencoding=gb2312\"用于显示的编码，仅仅是显示set encoding=utf-8\"set encoding=utf-8\"set encoding=euc-cn\"set encoding=gbk\"set encoding=gb2312\"set ambiwidth=doubleset fileformat=unix\"设置高亮搜索set hlsearch\"在搜索时，输入的词句的逐字符高亮set incsearch\" 着色模式set t_Co=256\"colorscheme wombat256mod\"colorscheme gardener\"colorscheme elflordcolorscheme desert\"colorscheme evening\"colorscheme darkblue\"colorscheme torte\"colorscheme default\" 字体 &amp;&amp; 字号set guifont=Monaco:h10\"set guifont=Consolas:h10\" :LoadTemplate       根据文件后缀自动加载模板\"let g:template_path='/home/ruchee/.vim/template/'\" :AuthorInfoDetect   自动添加作者、时间等信息，本质是NERD_commenter &amp;&amp; authorinfo的结合\"\"let g:vimrc_author='sunshanlu'\"\"let g:vimrc_email='sunshanlu@baidu.com'\"\"let g:vimrc_homepage='http://www.sunshanlu.com'\"\"\" Ctrl + E            一步加载语法模板和作者、时间信息\"\"map &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi\"\"imap &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi\"\"vmap &lt;c-e&gt; &lt;ESC&gt;:AuthorInfoDetect&lt;CR&gt;&lt;ESC&gt;Gi\" ======= 引号 &amp;&amp; 括号自动匹配 ======= \"\"\":inoremap ( ()&lt;ESC&gt;i\":inoremap ) &lt;c-r&gt;=ClosePair(')')&lt;CR&gt;\"\":inoremap { {}&lt;ESC&gt;i\"\":inoremap } &lt;c-r&gt;=ClosePair('}')&lt;CR&gt;\"\":inoremap [ []&lt;ESC&gt;i\"\":inoremap ] &lt;c-r&gt;=ClosePair(']')&lt;CR&gt;\"\":inoremap &lt; &lt;&gt;&lt;ESC&gt;i\"\":inoremap &gt; &lt;c-r&gt;=ClosePair('&gt;')&lt;CR&gt;\"\"\":inoremap \" \"\"&lt;ESC&gt;i\"\":inoremap ' ''&lt;ESC&gt;i\"\":inoremap ` ``&lt;ESC&gt;i\"\":inoremap * **&lt;ESC&gt;i\" 每行超过80个的字符用下划线标示\"\"au BufRead,BufNewFile *.s,*.asm,*.h,*.c,*.cpp,*.java,*.cs,*.lisp,*.el,*.erl,*.tex,*.sh,*.lua,*.pl,*.php,*.tpl,*.py,*.rb,*.erb,*.vim,*.js,*.jade,*.coffee,*.css,*.xml,*.html,*.shtml,*.xhtml Underlined /.\\%81v/\"\"\" For Win32 GUI: remove 't' flag from 'guioptions': no tearoff menu entries\" let &amp;guioptions = substitute(&amp;guioptions, \"t\", \"\", \"g\")\" Don't use Ex mode, use Q for formattingmap Q gq\" This is an alternative that also works in block mode, but the deleted\" text is lost and it only works for putting the current register.\"vnoremap p \"_dp\" Switch syntax highlighting on, when the terminal has colors\" Also switch on highlighting the last used search pattern.if &amp;t_Co &gt; 2 || has(\"gui_running\")  syntax on  set hlsearchendif\" Only do this part when compiled with support for autocommands.if has(\"autocmd\")  \" Enable file type detection.  \" Use the default filetype settings, so that mail gets 'tw' set to 72,  \" 'cindent' is on in C files, etc.  \" Also load indent files, to automatically do language-dependent indenting.  filetype plugin indent on  \" Put these in an autocmd group, so that we can delete them easily.  augroup vimrcEx  au!  \" For all text files set 'textwidth' to 80 characters.  autocmd FileType text setlocal textwidth=80  \" When editing a file, always jump to the last known cursor position.  \" Don't do it when the position is invalid or when inside an event handler  \" (happens when dropping a file on gvim).  autocmd BufReadPost *    \\ if line(\"'\\\"\") &gt; 0 &amp;&amp; line(\"'\\\"\") &lt;= line(\"$\") |    \\   exe \"normal g`\\\"\" |    \\ endif  augroup ENDelse  set autoindent\t\t\" always set autoindenting onendif \" has(\"autocmd\")\" 增加鼠标行高亮set cursorlinehi CursorLine  cterm=NONE   ctermbg=darkred ctermfg=white\" 设置tab是四个空格set ts=4set expandtab\" 主要给Tlist使用let Tlist_Exit_OnlyWindow = 1let Tlist_Auto_Open = 1\n\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","Vim"]},{"title":"tmux教程","url":"/2021/10/02/tmux/","content":"音乐小港\n    \n\n\nTmux教程介绍Tmux 是一个终端复用器（terminal multiplexer），非常有用，属于常用的开发工具。\n功能\n（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。\n（2） 它可以让新窗口”接入”已经存在的会话。\n（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。\n（4）它还支持窗口任意的垂直和水平拆分。\n（5） 允许断开Terminal连接后，继续运行进程。\n\n结构一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。\n实例：        tmux:            session 0:                window 0:                    pane 0                    pane 1                    pane 2                    ...                window 1                window 2                ...            session 1            session 2            ...\n\n安装# Ubuntu 或 Debian$ sudo apt-get install tmux# CentOS 或 Fedora$ sudo yum install tmux# Mac$ brew install tmux\n\n操作\ntmux：新建一个session，其中包含一个window，windo包含一个pane，pane里打开了一个shell对话框。\n按下ctrl + a后手指松开，然后按%：将当前pane左右平两个pane。\n按下ctrl + a后手指松开，然后按”（注意是双引号”）当前pane上下平分成两个pane。\nctrl + d：关闭当前pane；如果当前window的所有pane关闭，则自动关闭window；如果当前session的所有window均闭，则自动关闭session。\n鼠标点击可以选pane。\n按下ctrl + a后手指松开，然后按方向键：选择相pane。\n鼠标拖动pane之间的分割线，可以调整分割线的位置。\n按住ctrl + a的同时按方向键，可以调整pane之间分割位置。\n按下ctrl + a后手指松开，然后按z：将当前pane全屏/全屏。\n按下ctrl + a后手指松开，然后按d：挂起当前session。\ntmux a：打开之前挂起的session。\n按下ctrl + a后手指松开，然后按s：选择其它session。方向键 —— 上：选择上一项 session/window/pane方向键 —— 下：选择下一项 session/window/pane方向键 —— 右：展开当前项 session/window方向键 —— 左：闭合当前项 session/window\n按下ctrl + a后手指松开，然后按c：在当前session中一个新的window。\n按下ctrl + a后手指松开，然后按w：选择其他window作方法与1.完全相同。\n按下ctrl + a后手指松开，然后按PageUp：翻阅当前pan的内容。\n鼠标滚轮：翻阅当前pane内的内容。\n在tmux中选中文本时，需要按住shift键。（仅支持Windo和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）\ntmux中复制/粘贴文本的通用方式：\n按下ctrl + a后松开手指，然后按[\n用鼠标选中文本，被选中的文本会被自动复制到tmux 贴板\n按下ctrl + a后松开手指，然后按]，会将剪贴板 容粘贴到光标处\n\n\n\n\ne.g 原始tmux的前缀键盘是ctrl + b\n经修改的tmux的配置内容在下方给出\n\ntmux配置.tmux.conf\nset-option -g status-keys visetw -g mode-keys visetw -g monitor-activity on# setw -g c0-change-trigger 10# setw -g c0-change-interval 100# setw -g c0-change-interval 50# setw -g c0-change-trigger  75set-window-option -g automatic-rename onset-option -g set-titles onset -g history-limit 100000#set-window-option -g utf8 on# set command prefixset-option -g prefix C-aunbind-key C-bbind-key C-a send-prefixbind h select-pane -Lbind j select-pane -Dbind k select-pane -Ubind l select-pane -Rbind -n M-Left select-pane -Lbind -n M-Right select-pane -Rbind -n M-Up select-pane -Ubind -n M-Down select-pane -Dbind &lt; resize-pane -L 7bind &gt; resize-pane -R 7bind - resize-pane -D 7bind + resize-pane -U 7bind-key -n M-l next-windowbind-key -n M-h previous-windowset -g status-interval 1# status barset -g status-bg blackset -g status-fg blue#set -g status-utf8 onset -g status-justify centreset -g status-bg defaultset -g status-left \" #[fg=green]#S@#H #[default]\"set -g status-left-length 20# mouse support# for tmux 2.1# set -g mouse-utf8 onset -g mouse on## for previous version#set -g mode-mouse on#set -g mouse-resize-pane on#set -g mouse-select-pane on#set -g mouse-select-window on#set -g status-right-length 25set -g status-right \"#[fg=green]%H:%M:%S #[fg=magenta]%a %m-%d #[default]\"# fix for tmux 1.9bind '\"' split-window -vc \"#{pane_current_path}\"bind '%' split-window -hc \"#{pane_current_path}\"bind 'c' new-window -c \"#{pane_current_path}\"# run-shell \"powerline-daemon -q\"# vim: ft=conf\n\n\n来源链接：yxc\n","categories":["Linux 基础"],"tags":["Linux","tmux"]},{"title":"工资","url":"/2021/10/17/wages/","content":"音乐小港\n    \n\n\n工资题目请编写一个程序，可以读取一名员工的员工编号，本月工作总时长（小时）以及时薪，并输出他的工资条，工资条中包括员工编号和员工月收入。\n输入格式输入包含两个整数和一个浮点数，分别代表员工编号，工作时长以及时薪。\n每个数占一行。\n输出格式输出共两行，第一行格式为 NUMBER = X，其中  为员工编号。\n第二行格式为 SALARY = U$ Y，其中  为该员工月收入，保留两位小数。\n数据范围员工编号,总工作时长,时薪\n输入样例251005.50\n\n输出样例NUMBER = 25SALARY = U$ 550.00\n\nAC代码#include&lt;cstdio&gt;int main(){    int num,tim;    float men;    scanf(\"%d%d%f\",&amp;num,&amp;tim,&amp;men);    printf(\"NUMBER = %d\\nSALARY = U$ %.2f\",num,tim*men);    return 0;}\n\n解题思路","categories":["语法基础"],"tags":["C++","基础语法"]}]