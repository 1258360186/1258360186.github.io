<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>baiyu</title>
  
  <subtitle>白羽</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-01T13:40:22.716Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>baiyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协程技术与总结</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-19/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-19/</id>
    <published>2021-10-18T07:03:27.000Z</published>
    <updated>2022-05-01T13:40:22.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-yogqaTHH" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1406049989" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="协程技术与总结"><a href="#协程技术与总结" class="headerlink" title="协程技术与总结"></a>协程技术与总结</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>我们知道，线程是操作系统的内核对象，多线程编程时，如果线程数过多，就会导致频繁的上下文切换，这些对性能是一种额外的损耗。例如，在一些高并发的网络服务器编程中，使用一个线程服务一个 socket 连接是很不明智的，因此现在的主流做法是利用操作系统提供了基于事件模式的异步编程模型，用少量的线程来服务大量的网络连接和 IO。但是采用异步和基于事件的编程模型，让程序代码变得复杂，非常容易出错，也提高排查错误的难度。</p><p>协程，是在应用层模拟的线程，它避免了上下文切换的额外损耗，同时又兼顾了多线程的优点，简化了高并发程序的复杂度。还是以上面高并发的网络服务器为例，可以为每一个 socket 连接使用一个协程来处理，在兼顾性能的情况下，代码也清晰。</p><p>协程是在1963 年由 Melvin E. Conway USAF, Bedford, MA 等人提出的一个概念，且协程的概念是早于线程提出的。但是由于协程是非抢占式的调度，无法实现公平的任务调用，也无法直接利用多核 CPU 的优势，因此，我们不能武断地说协程是比线程更高级的技术。尽管协程的概念早于线程提出，但是目前主流的操作系统原生 API 并不支持协程技术，新兴的一些高级编程语言如 Golang 都是在语言的运行时环境中自己利用线程技术模拟了一套协程。</p><p>这些语言协程的内部实现上都是是基于线程的，思路是维护了一组数据结构和 n 个线程，真正的执行还是线程，协程执行的代码被扔进一个待执行队列中，由这 n 个线程从队列中拉出来执行。这就解决了协程的执行问题。那么协程是怎么切换的呢？</p><p>以 Golang 为例，Golang 对操作系统的各种 IO 函数（如 Linux 的 epoll、select，Windows 的 IOCP 等）进行了封装，这些封装的函数提供给应用程序使用，而其内部调用了操作系统的异步 IO 函数，当这些异步函数返回 busy 或 blocking 时，Golang 利用这个时机将现有的执行序列压栈，让线程去拉另外一个协程的代码来执行。</p><p>由于 Golang 是从编译器和语言基础库多个层面对协程做了实现，因而，Golang 的协程是目前各类存在协程概念的语言中实现的最完整和成熟的，十万个协程同时运行也毫无压力。带来的优势就是，程序员可以在编写 Golang 代码的时候，可以更多的关注业务逻辑的实现，更少的在这些关键的基础构件上耗费太多精力。</p><p>现今之所以协程技术这么流行是因为大多数设计喜欢使用异步编程以追求程序的性能，这就强行的将线性的程序逻辑打乱，程序逻辑变得非常的混乱与复杂。对程序状态的管理也变得异常困难，例如 NodeJS 那恶心的层层 Callback。在我们疯狂被 NodeJS 的层层回调恶心到的时候，Golang 作为名门之后开始进入广大开发者的视野，并且迅速的在 Web 后端攻城略地。例如，以 Docker 以及围绕 Docker 展开的整个容器生态圈为代表，其最大的卖点就是协程技术，至此协程技术开始真正的流行与被讨论起来。</p><p><a class="link" href="https://github.com/Tencent/libco">腾讯公司开源了一套 C/C++ 版本的协程库 libco<i class="fas fa-external-link-alt"></i></a>，有兴趣的读者可以研究一下其实现原理。</p><p>因此，协程技术从来不是什么新东西，只是人们为了从重复复杂的底层技术中解脱出来，能够快速专注业务开发而带来的产物。万变不离其宗，只要我们掌握了多线程编程的技术的核心原理，我们也能快速的学习协程技术。</p><h2 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h2><p>至此，本课程也就全部结束了。在整个课程中介绍了目前主流的 C/C++ 开发环境下的两个操作系统 Windows 和 Linux 系统层面上的线程原理和多线程资源同步技术的方方面面，同时基于这些基础知识延伸出了更高级的线程池技术和队列系统，也介绍了目前前沿的协程技术。</p><p>无论某种编程语言和其运行时环境（如 Java、Python）对操作系统的线程功能增加了多少中间层、封装了多少功能的，操作线程提供的线程相关 API 和同步接口是最基础的，且由于这些接口是操作系统提供的，它们在相当长的时间内都会基本保持不变，一旦你理解并熟练使用它们，你不仅可以灵活地学习和开发出强大的多线程程序来，同时也能快速地理解其他语言中的各种线程同步概念和技术。</p><p>多线程编程技术是怎么强调也不过份基本功，希望读者能够非常熟练地掌握它们，这种熟练掌握不仅是理解其原理，一定是熟悉到具体的 API 层面来上。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程池与队列系统的设计</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-18/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-18/</id>
    <published>2021-10-18T06:57:50.000Z</published>
    <updated>2022-05-01T13:40:22.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-wWpZCnxk" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1817977673" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程池与队列系统的设计"><a href="#线程池与队列系统的设计" class="headerlink" title="线程池与队列系统的设计"></a>线程池与队列系统的设计</h1><p>在很多新手的认知中，线程池和队列系统 是一项非常高深的技术，其实也不然，当你熟练掌握了多线程编程技术后，这一切将会变的很容易，你需要克服的是内心的恐惧而已。</p><h2 id="线程池的设计原理"><a href="#线程池的设计原理" class="headerlink" title="线程池的设计原理"></a>线程池的设计原理</h2><p>所谓线程池不过是一组线程而已，一般情况下，我们需要异步执行一些任务，这些任务的产生和执行是存在于我们程序的整个生命周期的，与其让操作系统频繁地为我们创建和销毁线程，通常需要创建一组在程序生命周期内不会退出的线程，为了不浪费系统资源，我们的基本要求是当有任务需要执行时，这些线程可以自动拿到任务去执行，没有任务时这些线程处于阻塞或者睡眠状态。这里就涉及到这些处理任务的工作线程的唤醒与睡眠，如果理解了上文中介绍的各种线程同步技术，相信现在对如何唤醒和睡眠线程已经很熟悉了。</p><p>既然在程序生命周期内会产生很多任务，那么这些任务必须有一个存放的地方，而这个地方就是队列，因此不要一提到队列就认为是一个具体的 list，它可以是一个全局变量、链表等。而线程池中的线程从队列中如何取任务，则也可以设计得非常灵活，如从尾部放入任务，从头部取出，或者从头部放入，从尾部取出等。而队列也可以根据实际应用设计得“丰富多彩”，如可以根据任务得优先级，设计多个队列（如分为高中低三个级别、分为关键和普通两个级别）。</p><p>这本质上就是生产者消费者模式，产生任务的线程是生产者，线程池中的线程是消费者。当然，这不是绝对的，线程池中的线程处理一个任务以后可能会产生一个新的关联任务，那么此时这个工作线程又是生产者的角色。</p><p>既然会有多个线程同时操作这个队列，根据多线程程序的原则，这个队列我们一般需要对其加锁，以避免多线程竞争产生非预期的结果。</p><p>当然，技术上除了要解决线程池的创建、往队列中投递任务、从队列中取任务处理，我们还需要做一些善后工作，如线程池的清理，即如何退出线程池中的工作线程和清理任务队列。</p><p>这就是线程池和任务队列的核心原理，希望读者能认真体会。</p><p>说了这么多，结合前文介绍的，具体的实现也变得很容易，我们来看一个具体的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line"> * 任务池模型，TaskPool.h</span><br><span class="line"> * zhangyl 2019.02.14</span><br><span class="line"> */</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    virtual void doIt()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; "handle a task..." &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    virtual ~Task()</span><br><span class="line">    {</span><br><span class="line">        //为了看到一个 task 的销毁，这里刻意补上其析构函数</span><br><span class="line">        std::cout &lt;&lt; "a task destructed..." &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class TaskPool final</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    TaskPool();</span><br><span class="line">    ~TaskPool();</span><br><span class="line">    TaskPool(const TaskPool&amp; rhs) = delete;</span><br><span class="line">    TaskPool&amp; operator=(const TaskPool&amp; rhs) = delete;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    void init(int threadNum = 5);</span><br><span class="line">    void stop();</span><br><span class="line"></span><br><span class="line">    void addTask(Task* task);</span><br><span class="line">    void removeAllTasks();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void threadFunc();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::list&lt;std::shared_ptr&lt;Task&gt;&gt;            m_taskList;</span><br><span class="line">    std::mutex                                  m_mutexList;</span><br><span class="line">    std::condition_variable                     m_cv;</span><br><span class="line">    bool                                        m_bRunning;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;std::thread&gt;&gt;   m_threads;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 任务池模型，TaskPool.cpp</span><br><span class="line"> * zhangyl 2019.02.14</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include "TaskPool.h"</span><br><span class="line"></span><br><span class="line">TaskPool::TaskPool() : m_bRunning(false)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">TaskPool::~TaskPool()</span><br><span class="line">{</span><br><span class="line">    removeAllTasks();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void TaskPool::init(int threadNum/* = 5*/)</span><br><span class="line">{</span><br><span class="line">    if (threadNum &lt;= 0)</span><br><span class="line">        threadNum = 5;</span><br><span class="line"></span><br><span class="line">    m_bRunning = true;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; threadNum; ++i)</span><br><span class="line">    {</span><br><span class="line">        std::shared_ptr&lt;std::thread&gt; spThread;</span><br><span class="line">        spThread.reset(new std::thread(std::bind(&amp;TaskPool::threadFunc, this)));</span><br><span class="line">        m_threads.push_back(spThread);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void TaskPool::threadFunc()</span><br><span class="line">{</span><br><span class="line">    std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; guard(m_mutexList);</span><br><span class="line">        while (m_taskList.empty())</span><br><span class="line">        {                 </span><br><span class="line">            if (!m_bRunning)</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            //如果获得了互斥锁，但是条件不满足的话，m_cv.wait() 调用会释放锁，且挂起当前</span><br><span class="line">            //线程，因此不往下执行</span><br><span class="line">            //当发生变化后，条件满足，m_cv.wait() 将唤醒挂起的线程，且获得锁</span><br><span class="line">            m_cv.wait(guard);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (!m_bRunning)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        spTask = m_taskList.front();</span><br><span class="line">        m_taskList.pop_front();</span><br><span class="line"></span><br><span class="line">        if (spTask == NULL)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        spTask-&gt;doIt();</span><br><span class="line">        spTask.reset();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; "exit thread, threadID: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void TaskPool::stop()</span><br><span class="line">{</span><br><span class="line">    m_bRunning = false;</span><br><span class="line">    m_cv.notify_all();</span><br><span class="line"></span><br><span class="line">    //等待所有线程退出</span><br><span class="line">    for (auto&amp; iter : m_threads)</span><br><span class="line">    {</span><br><span class="line">        if (iter-&gt;joinable())</span><br><span class="line">            iter-&gt;join();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void TaskPool::addTask(Task* task)</span><br><span class="line">{</span><br><span class="line">    std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">    spTask.reset(task);</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);             </span><br><span class="line">        m_taskList.push_back(spTask);</span><br><span class="line">        std::cout &lt;&lt; "add a Task." &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    m_cv.notify_one();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void TaskPool::removeAllTasks()</span><br><span class="line">{</span><br><span class="line">    {</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);</span><br><span class="line">        for (auto&amp; iter : m_taskList)</span><br><span class="line">        {</span><br><span class="line">            iter.reset();</span><br><span class="line">        }</span><br><span class="line">        m_taskList.clear();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码封装了一个简单的任务队列模型，我们可以这么使用这个 <code>TaskPool</code> 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include "TaskPool.h"</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    TaskPool threadPool;</span><br><span class="line">    threadPool.init();</span><br><span class="line"></span><br><span class="line">    Task* task = NULL;</span><br><span class="line">    for (int i = 0; i &lt; 10; ++i)</span><br><span class="line">    {</span><br><span class="line">        task = new Task();</span><br><span class="line">        threadPool.addTask(task);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    std::this_thread::sleep_for(std::chrono::seconds(5));</span><br><span class="line"></span><br><span class="line">    threadPool.stop();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded21.5gp1z81oh9c0.jpg" alt="multithreaded21"></p><p>由于退出线程的输出提示不是原子的，多个线程并行执行，因此上图中这部分的输出出现了“错乱”。</p><p>上述代码演示了一个基本的多线程队列模型，虽然简单，但是具有典型性，可以应付实际生产中的一部分需求，你可以基于这个基础模型进行扩展，不管怎么扩展其基本原理都是一样的。</p><p>例如，如果生产者和消费者（即产生任务者和处理任务者）的速度差不多，可以将队列改成环形队列，以节省内存空间。另外，很多应用为了追求效率，利用一些技巧将队列无锁化。这些都是仁者见仁智者见智的扩展了，本文不再介绍。不管如何，希望读者一定要理解线程池和任务队列的基本设计原理，只有这样你才能做更多高级的扩展和设计。</p><h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>基于生产者消费者理论模型的队列系统在实际开发中实在是太常用了，以至于在一组服务中可能每个进程都需要一个这样的队列系统。既然如此，出于复用和解耦的目的，业界产生了许多独立的队列系统，这些队列系统或以一个独立的进程运行或以支持分布式的一组服务运行。我们把这种独立的队列系统称之为消息中间件。这些消息中间件在功能上做了丰富的扩展，如消费的方式、主备切换、容灾容错，数据自动备份和过期数据自动清理等等，比较典型的有 <code>Kafka</code>、<code>ActiveMQ</code>、<code>RabbitMQ</code>、````` 等。下图是 <code>Kafka</code> 官网提供的一张介绍 <code>Kafka</code> 作用的图片：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded20.3z4jei6vqle0.jpg" alt="multithreaded20"></p><p>下图是笔者开发过的一个金融交易系统后台服务拓扑图，其大量使用消息中间件 <code>Kafka</code>：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded.2olgw93bycw0.jpg" alt="multithreaded"></p><p>整个交易的流程如下：</p><ul><li>前端通过 HTTP 请求向<strong>下单服务</strong>请求下单，<strong>下单服务</strong>在校验完数据后，会向<strong>消息中间件 A1</strong> 投递一条下单请求；</li><li><strong>成交服务</strong>订阅了<strong>消息中间件 A1</strong> 的消息，取出下单请求，结合自己的成交规则，如果可以成交，向消息中间件 A2 投递一条成交后的消息；</li><li><strong>结算服务</strong>订阅了<strong>消息中间件A2</strong>，从其中拿到成交消息后，对用户资金账户进行结算，结算完成后，用户的下单就算正式完成了，然后产生一条行情消息投递给<strong>消息中间件 A3</strong>；</li><li>行情推送服务器从<strong>消息中间件 A3</strong> 中拿到行情消息后推送给所有已经连接的客户端。<br>上述过程中，每个消息中间件（Kafka）都有一个生产者和消费者，虚线箭头表示短连接，实线箭头表示长连接。当然，实际的金融交易系统要比这里的模型复杂许多，这里为了演示方便做了大量简化。</li></ul><p>有了这种专门的队列系统，生产者和消费者将最大化解耦，利用消息中间件提供的对外消息接口，生产者只需要负责生产消息，它不必关心谁是消费者，消费者也不用关心生产者是谁、何时有数据，而队列系统本身也不关心自己有多少生产者和消费者。当然，这种消息中间件还有其他一些非常优秀的功能，如对数据的备份、负载和容灾容错措施。建议学有余力的读者适当地去了解一两种开源的队列系统的使用方法，如果掌握其设计思路那就善莫大焉了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节基于生产者和消费者模型介绍了线程池和衍生出来的消息中间件，线程池是开发中常用的技术手段之一，希望读者务必掌握其原理和编写方法，而消息中间件广泛地用于多服务系统之间，建议了解一两种开源的消息中间件的使用方法。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C 库的非线程安全函数</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-17/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-17/</id>
    <published>2021-10-18T06:54:37.000Z</published>
    <updated>2022-05-01T13:40:22.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-FHxSvTHR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="520274067" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="C-库的非线程安全函数"><a href="#C-库的非线程安全函数" class="headerlink" title="C 库的非线程安全函数"></a>C 库的非线程安全函数</h1><p>我们先来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    time_t tNow = time(NULL);</span><br><span class="line">    time_t tEnd = tNow + 1800;</span><br><span class="line">    //注意下面两行的区别</span><br><span class="line">    struct tm* ptm = localtime(&amp;tNow);</span><br><span class="line">    struct tm* ptmEnd = localtime(&amp;tEnd);</span><br><span class="line"></span><br><span class="line">    char szTmp[50] = { 0 };</span><br><span class="line">    strftime(szTmp, 50, "%H:%M:%S", ptm);</span><br><span class="line"></span><br><span class="line">    //struct tm* ptmEnd = localtime(&amp;tEnd);</span><br><span class="line">    char szEnd[50] = { 0 };</span><br><span class="line">    strftime(szEnd, 50, "%H:%M:%S", ptmEnd);</span><br><span class="line">    printf("%s \n", szTmp);</span><br><span class="line">    printf("%s \n", szEnd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序执行结果如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20:53:48</span><br><span class="line">20:53:48</span><br></pre></td></tr></table></figure><p>很奇怪是不是？<code>tNow</code> 和 <code>tEnd</code> 明明相差 1800 秒。我们调整一下代码第 9 行的位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    time_t tNow = time(NULL);</span><br><span class="line">    time_t tEnd = tNow + 1800;</span><br><span class="line">    //注意下面两行的区别</span><br><span class="line">    struct tm* ptm = localtime(&amp;tNow);    </span><br><span class="line"></span><br><span class="line">    char szTmp[50] = { 0 };</span><br><span class="line">    strftime(szTmp, 50, "%H:%M:%S", ptm);</span><br><span class="line"></span><br><span class="line">    struct tm* ptmEnd = localtime(&amp;tEnd);</span><br><span class="line">    char szEnd[50] = { 0 };</span><br><span class="line">    strftime(szEnd, 50, "%H:%M:%S", ptmEnd);</span><br><span class="line">    printf("%s \n", szTmp);</span><br><span class="line">    printf("%s \n", szEnd);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这次输出结果正确了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20:25:44</span><br><span class="line">20:55:44</span><br></pre></td></tr></table></figure><p>为什么会出现这种情况呢？我们来看下 <code>localtime</code> 函数的签名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct tm* localtime(const time_t* timep);</span><br></pre></td></tr></table></figure><p>这个函数返回值一个 <code>tm</code> 结构体指针类型，而我们外部并不需要释放这个指针指向的内存，因此断定这个函数内部一定使用了一个全局变量或函数内部的静态变量。这样的话，当再次调用这个函数时有可能前一次调用结果就被后一个结果覆盖了。我们简化一下这种模型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int* func(int k)</span><br><span class="line">{</span><br><span class="line">    static int result;</span><br><span class="line">    result = k;</span><br><span class="line">    return &amp;result;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当多个线程甚至单个线程调用这个函数时，如两个线程分别调用上述函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//线程1调用</span><br><span class="line">int* p1 = func(1);</span><br><span class="line">//线程2调用</span><br><span class="line">int* p2 = func(2);</span><br></pre></td></tr></table></figure><p>那么 * p1 和 * p2 的结果会是什么呢？结论是可能是 1 也可能是 2，甚至既不是 1 也不是 2。原因我们在前面《为什么整形变量赋值操作不是原子》的小节已经介绍过了。</p><p>像 <code>localtime </code>这类 <code>CRT</code> 提供的具有上述行为的函数，我们称为非线程安全函数。因此在实际开发中应避免在多线程程序中使用这类函数，这类函数还有如 strtok，甚至连操作系统提供的 socket 函数 gethostbyname 也不是线程安全的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strtok(char* str, const char* delim);</span><br><span class="line"></span><br><span class="line">struct hostent* gethostbyname(const char* name);</span><br></pre></td></tr></table></figure><p>为什么会出现这类函数呢？是因为最初编写很多 <code>CRT</code> 函数时，还没有多线程技术，所以很多函数内部实现都使用了函数内部的静态变量和全局变量。随着多线程技术的出现，很多函数出现了对应的多线程安全版本，如 <code>localtime_r</code>、<code>strtok_r</code>。在这些函数内部很多改用了线程局部存储 技术来替代原来使用静态变量或者全局变量的做法。</p><p><strong>因此，在实际开发中如果一个 CRT 函数可能被多个线程调用，要注意其是否是多线程安全函数，如果不是多线程安全的，要改用其线程安全的版本。</strong></p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程局部存储</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-16/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-16/</id>
    <published>2021-10-18T06:44:10.000Z</published>
    <updated>2022-05-01T13:40:22.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-qBtdaCjX" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1429355183" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程局部存储"><a href="#线程局部存储" class="headerlink" title="线程局部存储"></a>线程局部存储</h1><p>对于一个存在多个线程的进程来说，有时候我们需要有一份数据是每个线程都拥有的，也就是说每个线程自己操作自己的这份数据，这有点类似 C++ 类的实例属性，每个实例对象操作的都是自己的属性。我们把这样的数据称之为<strong>线程局部存储</strong>（<code>Thread Local Storage，TLS</code>），对应的存储区域叫做<strong>线程局部存储区</strong>。</p><h2 id="Windows-的线程局部存储"><a href="#Windows-的线程局部存储" class="headerlink" title="Windows 的线程局部存储"></a>Windows 的线程局部存储</h2><p>Windows 系统将线程局部存储区分成 <code>TLS_MINIMUM_AVAILABLE</code> 个块，每一块通过一个索引值对外提供访问。</p><blockquote><p>TLS_MINIMUM_AVAILABLE 的默认是 64。在 winnt.h 中定义：</p><p># define TLS_MINIMUM_AVAILABLE 64</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded15.56n03n8p70c0.jpg" alt="multithreaded15"></p><p>Windows 中使用函数 <code>TlsAlloc</code> 获得一个线程局部存储块的索引：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD TlsAlloc();</span><br></pre></td></tr></table></figure><p>如果这个函数调用失败，则返回值是 <code>TLS_OUT_OF_INDEXES</code>（0xFFFFFFFF）；如果函数调用成功，得到一个索引，接下来就可以利用这个索引去往这个内存块中存储数据或者从这个内存块中得到数据，分别使用如下两个 API 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPVOID TlsGetValue(DWORD dwTlsIndex);</span><br><span class="line">BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);</span><br></pre></td></tr></table></figure><p>当你不再需要这个存储区域时，你应该释放它，释放调用函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL TlsFree(DWORD dwTlsIndex);</span><br></pre></td></tr></table></figure><p>当然，使用线程局部存储除了使用上面介绍的 API 函数外，Microsoft VC++ 编译器还提供了如下方法定义一个线程局部变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(thread) int g_mydata = 1;</span><br></pre></td></tr></table></figure><p>我们看一个具体例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">__declspec(thread) int g_mydata = 1;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc1(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        ++g_mydata;</span><br><span class="line">        //std::cout &lt;&lt; "g_mydata = " &lt;&lt; g_mydata &lt;&lt; ", ThreadID = " &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc2(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {       </span><br><span class="line">        std::cout &lt;&lt; "g_mydata = " &lt;&lt; g_mydata &lt;&lt; ", ThreadID = " &lt;&lt; GetCurrentThreadId() &lt;&lt; std::endl;</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    }</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    HANDLE hWorkerThreads[2];</span><br><span class="line">    hWorkerThreads[0] = CreateThread(NULL, 0, WorkerThreadProc1, NULL, 0, NULL);</span><br><span class="line">    hWorkerThreads[1] = CreateThread(NULL, 0, WorkerThreadProc2, NULL, 0, NULL);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hWorkerThreads[0]);</span><br><span class="line">    CloseHandle(hWorkerThreads[1]);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中全局变量 <code>g_mydata</code> 是一个线程局部变量，因此该进程中每一个线程都会拥有这样一个变量副本，由于是不同的副本，<code>WorkerThreadProc1</code> 中将这个变量不断递增，对 <code>WorkerThreadProc2</code> 的 <code>g_mydata</code> 不会造成任何影响，因此其值始终是 1。程序执行结果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded16.1ihf33kj61mo.jpg" alt="multithreaded16"></p><blockquote><p>需要说明的是，在 Windows 系统中被声明成线程局部变量的对象，在编译器生成可执行文件时，会在最终的 PE 文件中专门生成一个叫 tls 的节，这个节用于存放这些线程局部变量。</p></blockquote><h2 id="Linux-的线程局部存储"><a href="#Linux-的线程局部存储" class="headerlink" title="Linux 的线程局部存储"></a>Linux 的线程局部存储</h2><p>Linux 系统上的 NTPL 提供了一套函数接口来实现线程局部存储的功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int pthread_key_create(pthread_key_t* key, void (*destructor)(void*));</span><br><span class="line">int pthread_key_delete(pthread_key_t key);</span><br><span class="line"></span><br><span class="line">int pthread_setspecific(pthread_key_t key, const void* value);</span><br><span class="line">void* pthread_getspecific(pthread_key_t key);</span><br></pre></td></tr></table></figure><p><code>pthread_key_create</code> 函数调用成功会返回 0 值，调用失败返回非 0 值，函数调用成功会为线程局部存储创建一个新键，用户通过参数 <code>key</code> 去设置（调用 <code>pthread_setspecific</code>）和获取（<code>pthread_getspecific</code>）数据，因为进程中的所有线程都可以使用返回的键，所以参数 <code>key</code> 应该指向一个全局变量。</p><p>参数 <code>destructor</code> 是一个自定义函数指针，其签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void* destructor(void* value)</span><br><span class="line">{</span><br><span class="line">    /*多是为了释放 value 指针指向的资源*/</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>线程终止时，如果 <code>key</code> 关联的值不是 <code>NULL</code>，那么 <code>NTPL</code> 会自动执行定义的 <code>destructor</code> 函数；如果无须解构，可以将 <code>destructor</code> 设置为 <code>NULL</code>。</p><p>我们来看一个具体例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">//线程局部存储 key</span><br><span class="line">pthread_key_t thread_log_key;</span><br><span class="line"></span><br><span class="line">void write_to_thread_log(const char* message)</span><br><span class="line">{</span><br><span class="line">    if (message == NULL)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    FILE* logfile = (FILE*)pthread_getspecific(thread_log_key);</span><br><span class="line">    fprintf(logfile, "%s\n", message);</span><br><span class="line">    fflush(logfile);</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">void close_thread_log(void* logfile)</span><br><span class="line">{</span><br><span class="line">    char logfilename[128];</span><br><span class="line">    sprintf(logfilename, "close logfile: thread%ld.log\n", (unsigned long)pthread_self());</span><br><span class="line">    printf(logfilename);</span><br><span class="line"></span><br><span class="line">    fclose((FILE *)logfile);</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">void* thread_function(void* args)</span><br><span class="line">{</span><br><span class="line">    char logfilename[128];</span><br><span class="line">    sprintf(logfilename, "thread%ld.log", (unsigned long)pthread_self());</span><br><span class="line"></span><br><span class="line">    FILE* logfile = fopen(logfilename, "w");</span><br><span class="line">    if (logfile != NULL)</span><br><span class="line">    {</span><br><span class="line">        pthread_setspecific(thread_log_key, logfile);</span><br><span class="line"></span><br><span class="line">        write_to_thread_log("Thread starting...");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_t threadIDs[5]; </span><br><span class="line">    pthread_key_create(&amp;thread_log_key, close_thread_log);</span><br><span class="line">    for(int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;threadIDs[i], NULL, thread_function, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(threadIDs[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述程序一共创建 5 个线程，每个线程都会自己生成一个日志文件，每个线程将自己的日志写入自己的文件中，当线程执行结束时，会关闭打开的日志文件句柄。</p><p>程序运行结果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded17.71kbgtf0rgg0.jpg" alt="multithreaded17"></p><p>生成的 5 个日志文件中，其内容都写入了一行“Thread starting…”。</p><p>上面的程序首先调用 <code>pthread_key_create</code> 函数来申请一个槽位。在 NPTL 实现下，<code>pthread_key_t</code> 是无符号整型，<code>pthread_key_create</code> 调用成功时会将一个小于 1024 的值填入第一个入参指向的 <code>pthread_key_t</code> 类型的变量中。之所以小于 1024，是因为 NPTL 实现一共提供了 1024 个槽位。</p><p>如图所示，记录槽位分配情况的数据结构 <code>pthread_keys</code> 是进程唯一的，<code>pthread_keys</code> 结构示意图如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded18.9zlu7acf7eo.jpg" alt="multithreaded18"></p><p>和 Windows 一样 Linux gcc 编译器也提供了一个关键字 <code>__thread</code> 去简化定义线程局部变量。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__thread int val = 0;</span><br></pre></td></tr></table></figure><p>我们再来看一个示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">//线程局部存储 key</span><br><span class="line">__thread int g_mydata = 99;</span><br><span class="line"></span><br><span class="line">void* thread_function1(void* args)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        g_mydata ++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">void* thread_function2(void* args)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {       </span><br><span class="line">        std::cout &lt;&lt; "g_mydata = " &lt;&lt; g_mydata &lt;&lt; ", ThreadID: " &lt;&lt; pthread_self() &lt;&lt; std::endl;</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_t threadIDs[2]; </span><br><span class="line">    pthread_create(&amp;threadIDs[0], NULL, thread_function1, NULL);</span><br><span class="line">    pthread_create(&amp;threadIDs[1], NULL, thread_function2, NULL);</span><br><span class="line"></span><br><span class="line">    for(int i = 0; i &lt; 2; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(threadIDs[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>由于 <code>thread_function1</code> 修改的是自己的 <code>g_mydata</code>，因此 <code>thread_function2</code> 输出 <code>g_mydata</code> 的值始终是 99。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o linuxtls2 linuxtls2.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./linuxtls2</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">g_mydata = 99, ThreadID: 140243186276096</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure><h2 id="C-11-的-thread-local-关键字"><a href="#C-11-的-thread-local-关键字" class="headerlink" title="C++ 11 的 thread_local 关键字"></a>C++ 11 的 thread_local 关键字</h2><p><code>C++ 11</code> 标准提供了一个新的关键字 <code>thread_local</code> 来定义一个线程变量。使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread_local int g_mydata = 1;</span><br></pre></td></tr></table></figure><p>有了这个关键字，使用线程局部存储的代码同时在 Windows 和 Linux 运行了。示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">thread_local int g_mydata = 1;</span><br><span class="line"></span><br><span class="line">void thread_func1()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        ++g_mydata;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void thread_func2()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; "g_mydata = " &lt;&lt; g_mydata &lt;&lt; ", ThreadID = " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::thread t1(thread_func1);</span><br><span class="line">    std::thread t2(thread_func2);</span><br><span class="line"></span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>需要注意的是，如果读者是在 Windows 平台下，虽然 <code>thread_local</code> 关键字在 C++ 11 标准中引入，但是 Visual Studio 2013 （支持 C++ 11 语法的最低的一个版本）编译器却并不支持这个关键字，建议在 Visual Studio 2015 及以上版本中测试上述代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后关于线程局部存储变量，我还再强调两点：</p><ul><li>对于线程变量，每个线程都会有该变量的一个拷贝，并行不悖，互不干扰，该局部变量一直都在，直到线程退出为止；</li><li>系统的线程局部存储区域内存空间并不大，因此尽量不要利用这个空间存储大的数据块，如果不得不使用大的数据块，可以将大的数据块存储在堆内存中，再将该堆内存的地址指针存储在线程局部存储区域。</li></ul><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>锁使用实践经验总结</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-15/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-15/</id>
    <published>2021-10-18T06:37:51.000Z</published>
    <updated>2022-05-01T13:40:22.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-pdOUejGB" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1826924917" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="锁使用实践经验总结"><a href="#锁使用实践经验总结" class="headerlink" title="锁使用实践经验总结"></a>锁使用实践经验总结</h1><p>关于锁的使用，根据我的经验总结如下几点。</p><h2 id="减少锁的使用"><a href="#减少锁的使用" class="headerlink" title="减少锁的使用"></a>减少锁的使用</h2><p>实际开发中能不使用锁尽量不使用锁，当然这不是绝对的，如果使用锁也能满足性能要求，使用也无妨，一般使用了锁的代码会带来如下性能损失：</p><ul><li>加锁和解锁操作，本身有一定的开销；</li><li>临界区的代码不能并发执行；</li><li>进入临界区的次数过于频繁，线程之间对临界区的争夺太过激烈，若线程竞争互斥量失败，就会陷入阻塞，让出 CPU，因此执行上下文切换的次数要远远多于不使用互斥量的版本。<br>替代锁的方式有很多，如无锁队列。</li></ul><h2 id="明确锁的范围"><a href="#明确锁的范围" class="headerlink" title="明确锁的范围"></a>明确锁的范围</h2><p>看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if(hashtable.is_empty())</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&amp;mutex);</span><br><span class="line">    htable_insert(hashtable, &amp;elem);</span><br><span class="line">    pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>读者能看出这段代码的问题吗？代码行 4 虽然对 <code>hashtable</code> 的插入使用了锁做保护，但是判断 <code>hash_table</code> 是否为空也需要使用锁保护，因此正确的写法应该是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">if(hashtable.is_empty())</span><br><span class="line">{   </span><br><span class="line">    htable_insert(hashtable, &amp;elem);  </span><br><span class="line">}</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure><h2 id="减少锁的粒度"><a href="#减少锁的粒度" class="headerlink" title="减少锁的粒度"></a>减少锁的粒度</h2><p>所谓减小锁使用粒度指的是尽量减小锁作用的临界区代码范围，临界区的代码范围越小，多个线程排队进入临界区的时间就会越短。这就类似高速公路上堵车，如果堵车的路段越长，那么后续过来的车辆通行等待时间就会越长。</p><p>我们来看两个具体的例子：</p><p>示例一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void TaskPool::addTask(Task* task)</span><br><span class="line">{</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard(m_mutexList); </span><br><span class="line">    std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">    spTask.reset(task);            </span><br><span class="line">    m_taskList.push_back(spTask);</span><br><span class="line"></span><br><span class="line">    m_cv.notify_one();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中 <code>guard</code> 锁保护 <code>m_taskList</code>，仔细分析下这段代码发现，代码行 4、5 和 8 行其实没必要作为临界区内的代码的，因此建议挪到临界区外面去，修改如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void TaskPool::addTask(Task* task)</span><br><span class="line">{</span><br><span class="line">    std::shared_ptr&lt;Task&gt; spTask;</span><br><span class="line">    spTask.reset(task);</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        std::lock_guard&lt;std::mutex&gt; guard(m_mutexList);             </span><br><span class="line">        m_taskList.push_back(spTask);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    m_cv.notify_one();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>修改之后，<code>guard</code> 锁的作用范围就是 7 、8 两行了，仅对 <code>m_taskList.push_back()</code> 操作做保护，这样锁的粒度就变小了。</p><p>示例二</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::doPendingFunctors()</span><br><span class="line">{</span><br><span class="line">    std::unique_lock&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">    for (size_t i = 0; i &lt; pendingFunctors_.size(); ++i)</span><br><span class="line">    {</span><br><span class="line">        pendingFunctors_[i]();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中 <code>pendingFunctors_</code> 是被锁保护的对象，它的类型是 <code>std::vector&lt;Functor&gt;</code>，这样的代码效率比较低，必须等当前线程挨个处理完 <code>pendingFunctors_</code> 中的元素后其他线程才能操作 <code>pendingFunctors_</code> 。修改代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void EventLoop::doPendingFunctors()</span><br><span class="line">{</span><br><span class="line">    std::vector&lt;Functor&gt; functors;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; lock(mutex_);</span><br><span class="line">        functors.swap(pendingFunctors_);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; functors.size(); ++i)</span><br><span class="line">    {</span><br><span class="line">        functors[i]();</span><br><span class="line">    }   </span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>修改之后的代码使用了一个局部变量 <code>functors</code>，然后把 <code>pendingFunctors_</code> 中的内容倒换到 <code>functors</code> 中，这样就可以释放锁了，允许其他线程操作 <code>pendingFunctors_</code> ，现在只要继续操作本地对象 <code>functors</code> 就可以了，提高了效率。</p><h2 id="避免死锁的一些建议"><a href="#避免死锁的一些建议" class="headerlink" title="避免死锁的一些建议"></a>避免死锁的一些建议</h2><ul><li><p><strong>一个函数中，如果有一个加锁操作，那么一定要记得在函数退出时记得解锁，且每个退出路径上都不要忘记解锁路径。</strong>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">void some_func()</span><br><span class="line">{</span><br><span class="line">    //加锁代码</span><br><span class="line"></span><br><span class="line">    if (条件1)</span><br><span class="line">    {</span><br><span class="line">        //其他代码</span><br><span class="line">        //解锁代码</span><br><span class="line">        return;</span><br><span class="line">    } </span><br><span class="line">    else</span><br><span class="line">    {</span><br><span class="line">        //其他代码</span><br><span class="line">        //解锁代码</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (条件2)</span><br><span class="line">    {</span><br><span class="line">        if (条件3)</span><br><span class="line">        {</span><br><span class="line">            //其他代码</span><br><span class="line">            //解锁代码</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        if (条件4)</span><br><span class="line">        {</span><br><span class="line">            //其他代码</span><br><span class="line">            //解锁代码</span><br><span class="line">            return;</span><br><span class="line">        }   </span><br><span class="line">    } </span><br><span class="line"></span><br><span class="line">    while (条件5)</span><br><span class="line">    {</span><br><span class="line">        if (条件6)</span><br><span class="line">        {</span><br><span class="line">            //其他代码</span><br><span class="line">            //解锁代码</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述函数中每个逻辑出口处都需要写上解锁代码。前面也说过，这种逻辑非常容易因为疏忽忘记在某个地方加上解锁代码而造成死锁，因此一般建议使用 <code>RAII</code> 技术将加锁和解锁代码封装起来。</p></li><li><p>线程退出时一定要及时释放其持有的锁<br>实际开发中会因一些特殊需求创建一些临时线程，这些线程执行完相应的任务后就会退出。对于这类线程，如果其持有了锁，一定记得在线程退出时记得释放其持有的锁对象。</p></li><li><p>多线程请求锁的方向要一致，以避免死锁<br>假设现在有两个锁 A 和 B，线程 1 在请求了锁 A 之后再请求 B，线程 2 在请求了锁 B 后再请求锁 A，这种线程请求锁的方向就不一致了，线程 1 的方向是从 A 到 B，线程 2 的方向是从 B 到 A，多个线程请求锁的方向不一致容易造成死锁。因此建议的方式是线程 1 和 线程 2 请求锁的方向保持一致，要么都从 A 到 B，要么都从 B 到 A。</p></li><li><p>当需要同一个线程重复请求一个锁时，搞清楚你所使用的锁的行为，是递增锁引用计数，还是会阻塞抑或是直接获得锁？</p><h2 id="避免活锁的一些建议"><a href="#避免活锁的一些建议" class="headerlink" title="避免活锁的一些建议"></a>避免活锁的一些建议</h2><p>前面说了避免“死锁”，读者应该能理解，但是这里突然出现了避免“活锁”，我相信很多人看到这个标题一下子就懵了。所谓活锁就是，当多个线程使用 <code>trylock</code> 系列的函数时，由于多个线程相互谦让，导致即使在某段时间内锁资源是可用的，也可能导致需要锁的线程拿不到锁。举个生活中的例子，马路上两个人迎面走来，两个人同时往一个方向避让，原来本意是给对方让路，结果还是发生了碰撞。</p></li></ul><p>我们在实际编码时，尽量避免不要过多的线程使用 <code>trylock</code> 请求锁，以免出现“活锁”现象，这是对资源的一种浪费。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从第 08 节到 第 17 节我们介绍 Windows 和 Linux 操作系统 API 层面上的各种常用多线程同步对象，本节是对它们的使用做了一个规范性和效率性总结。学会使用锁并不难，如何高效地使用它们则是一个不断积累不断总结的过程，希望本节的经验能对读者有帮助。同时，本节介绍锁的注意事项也适用于其他编程语言。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++ 11/14/17 线程资源同步对象</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-14/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-14/</id>
    <published>2021-10-18T06:12:33.000Z</published>
    <updated>2022-05-01T13:40:22.714Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-KpKOqDnG" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1818178340" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="C-11-14-17-线程资源同步对象"><a href="#C-11-14-17-线程资源同步对象" class="headerlink" title="C++ 11/14/17 线程资源同步对象"></a>C++ 11/14/17 线程资源同步对象</h1><p>在 C/C++ 语言中直接使用操作系统提供的多线程资源同步 API 虽然功能强大，但毕竟存在诸多限制，且同样的代码却不能同时兼容 Windows 和 Linux 两个平台；再者 C/C++ 这种传统语言的使用份额正在被 Java、Python、Go 等语言慢慢蚕食，很大一部分原因是 C/C++ 这门编程语言在一些功能上缺少“完备性”，如对线程同步技术的支持，而这些功能在像 Java、Python、Go 中是标配。</p><p>因此，<code>C++ 11</code> 标准新加入了很多现代语言标配的东西，其中线程资源同步对象就是其中很重要的一部分。本小节将讨论 <code>C++ 11</code> 标准中新增的用于线程同步的 <code>std::mutex</code> 和 <code>std::condition_variable</code> 对象的用法，有了它们我们就可以写出跨平台的多线程程序了。</p><h2 id="std-mutex-系列"><a href="#std-mutex-系列" class="headerlink" title="std::mutex 系列"></a>std::mutex 系列</h2><p>关于 <code>mutex</code> 的基本概念上文已经介绍过了，这里不再赘述。</p><p><code>C++ 11/14/17</code> 中提供了如下 <code>mutex</code> 系列类型：</p><table><thead><tr><th>互斥量</th><th>版本</th><th>作用</th></tr></thead><tbody><tr><td>mutex</td><td>C++11</td><td>最基本的互斥量</td></tr><tr><td>timed_mutex</td><td>C++11</td><td>有超时机制的互斥量</td></tr><tr><td>recursive_mutex</td><td>C++11</td><td>可重入的互斥量</td></tr><tr><td>recursive_timed_mutex</td><td>C++11</td><td>结合 timed_mutex 和 recursive_mutex 特点的互斥量</td></tr><tr><td>shared_timed_mutex</td><td>C++14</td><td>具有超时机制的可共享互斥量</td></tr><tr><td>shared_mutex</td><td>C++17</td><td>共享的互斥量</td></tr><tr><td>这个系列的对象均提供了加锁（lock）、尝试加锁（trylock）和解锁（unlock）的方法，我们以 std::mutex 为例来看一段示例代码：</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">// protected by g_num_mutex</span><br><span class="line">int g_num = 0;  </span><br><span class="line">std::mutex g_num_mutex;</span><br><span class="line"></span><br><span class="line">void slow_increment(int id) </span><br><span class="line">{</span><br><span class="line">    for (int i = 0; i &lt; 3; ++i) {</span><br><span class="line">        g_num_mutex.lock();</span><br><span class="line">        ++g_num;</span><br><span class="line">        std::cout &lt;&lt; id &lt;&lt; " =&gt; " &lt;&lt; g_num &lt;&lt; std::endl;</span><br><span class="line">        g_num_mutex.unlock();</span><br><span class="line"></span><br><span class="line">        //sleep for 1 second</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::thread t1(slow_increment, 0);</span><br><span class="line">    std::thread t2(slow_increment, 1);</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中，创建了两个线程 <code>t1</code> 和 <code>t2</code>，在线程函数的 <code>for</code> 循环中调用 <code>std::mutex.lock()</code> 和 <code>std::mutex.unlock()</code> 对全局变量<code> g_num</code> 进行保护。编译程序并输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o mutex c11mutex.cpp -std=c++0x -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./mutex </span><br><span class="line">0 =&gt; 1</span><br><span class="line">1 =&gt; 2</span><br><span class="line">0 =&gt; 3</span><br><span class="line">1 =&gt; 4</span><br><span class="line">1 =&gt; 5</span><br><span class="line">0 =&gt; 6</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果你在 Linux 下编译和运行程序，在编译时需要链接 pthread 库，否则能够正常编译但是运行时程序会崩溃，崩溃原因：</p><p>terminate called after throwing an instance of ‘std::system_error’</p><p>what(): Enable multithreading to use std::thread: Operation not permitted</p></blockquote><p>为了避免死锁，<code>std::mutex.lock()</code> 和 <code>std::mutex::unlock() </code>方法需要成对使用，但是如上文介绍的如果一个函数中有很多出口，而互斥体对象又是需要在整个函数作用域保护的资源，那么在编码时因为忘记在某个出口处调用 <code>std::mutex.unlock </code>而造成死锁，上文中推荐使用利用 <code>RAII</code> 技术封装这两个接口，其实 <code>C++ 11</code> 标准也想到了整个问题，因为已经为我们提供了如下封装：</p><table><thead><tr><th>互斥量管理</th><th>版本</th><th>作用</th></tr></thead><tbody><tr><td>lock_guard</td><td>C++11</td><td>基于作用域的互斥量管理</td></tr><tr><td>unique_lock</td><td>C++11</td><td>更加灵活的互斥量管理</td></tr><tr><td>shared_lock</td><td>C++14</td><td>共享互斥量的管理</td></tr><tr><td>scope_lock</td><td>C++17</td><td>多互斥量避免死锁的管理</td></tr><tr><td>我们这里以 <code>std::lock_guard</code> 为例：</td><td></td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard(mymutex);</span><br><span class="line">    //在这里放被保护的资源操作</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>mymutex</code> 的类型是 <code>std::mutex</code>，在 <code>guard</code> 对象的构造函数中，会自动调用<code> mymutex.lock()</code> 方法加锁，当该函数出了作用域后，调用 <code>guard</code> 对象时析构函数时会自动调用 <code>mymutex.unlock()</code> 方法解锁。</p><p>注意： <code>mymutex</code> 生命周期必须长于函数 <code>func</code> 的作用域，很多人在初学这个利用 <code>RAII</code> 技术封装的 <code>std::lock_guard</code> 对象时，可能会写出这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//错误的写法，这样是没法在多线程调用该函数时保护指定的数据的</span><br><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::mutex m;</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; guard(m);</span><br><span class="line">    //在这里放被保护的资源操作</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="std-mutex-重复加锁问题"><a href="#std-mutex-重复加锁问题" class="headerlink" title="std::mutex 重复加锁问题"></a>std::mutex 重复加锁问题</h2><p>另外，如果一个 <code>std::mutex</code> 对象已经调用了 <code>lock()</code> 方法，再次调用时，其行为是未定义的，这是一个错误的做法。所谓“行为未定义”即在不同平台上可能会有不同的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::mutex m;</span><br><span class="line">    m.lock();</span><br><span class="line">    m.lock();</span><br><span class="line">    m.unlock();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>实际测试时，上述代码重复调用 <code>std::mutex.lock()</code> 方法在 Windows 平台上会引起程序崩溃。如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded14.5c12po8n0gk0.jpg" alt="multithreaded14"></p><p>上述代码在 Linux 系统上运行时会阻塞在第二次调用 <code>std::mutex.lock()</code> 处，验证结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o mutexlock mutexlock.cpp -std=c++0x -lpthread</span><br><span class="line">[root@localhost testmultithread]# gdb mutexlock</span><br><span class="line">Reading symbols from /root/testmultithread/mutexlock...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/testmultithread/mutexlock </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x00007ffff7bc8dcb in _L_lock_883 () from /lib64/libpthread.so.0</span><br><span class="line">#2  0x00007ffff7bc8c98 in pthread_mutex_lock () from /lib64/libpthread.so.0</span><br><span class="line">#3  0x00000000004006f7 in __gthread_mutex_lock (__mutex=0x7fffffffe3e0)</span><br><span class="line">    at /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/gthr-default.h:748</span><br><span class="line">#4  0x00000000004007a2 in std::mutex::lock (this=0x7fffffffe3e0) at /usr/include/c++/4.8.2/mutex:134</span><br><span class="line">#5  0x0000000000400777 in main () at mutexlock.cpp:7</span><br><span class="line">(gdb) f 5</span><br><span class="line">#5  0x0000000000400777 in main () at mutexlock.cpp:7</span><br><span class="line">7        m.lock();</span><br><span class="line">(gdb) l</span><br><span class="line">2    </span><br><span class="line">3    int main()</span><br><span class="line">4    {</span><br><span class="line">5        std::mutex m;</span><br><span class="line">6        m.lock();</span><br><span class="line">7        m.lock();</span><br><span class="line">8        m.unlock();</span><br><span class="line">9    </span><br><span class="line">10        return 0;</span><br><span class="line">11    }</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>我们使用 <code>gdb</code> 运行程序，然后使用 <code>bt</code> 命令看到程序确实阻塞在第二个 <code>m.lock()</code> 的地方（代码第 7 行）。</p><p>不管怎样，对一个已经调用 <code>lock()</code> 方法再次调用 <code>lock()</code> 方法的做法是错误的，我们实际开发中要避免这么做。</p><blockquote><p>有不少开发者诟病 C++ 新标准的多线程库原因之一是 <code>C++ 11</code> 引入了 <code>std::mutex</code>，却到<code> C++ 17</code> 才引入 <code>std::shared_mutex</code>，这给使用带来了非常不方便的地方。</p></blockquote><h2 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h2><p><code>C++ 11</code> 提供了 <code>std::condition_variable</code> 这个类代表条件变量，与 Linux 系统原生的条件变量一样，同时提供了等待条件变量满足的 <code>wait</code> 系列方法（<code>wait</code>、<code>wait_for</code>、<code>wait_until</code> 方法），发送条件信号使用 <code>notify</code> 方法（<code>notify_one </code>和 <code>notify_all</code> 方法），当然使用 <code>std::condition_variable</code> 对象时需要绑定一个 <code>std::unique_lock</code> 或 <code>std::lock_guard</code> 对象。</p><blockquote><p><code>C++ 11</code> 中 <code>std::condition_variable</code> 不再需要显式调用方法初始化和销毁。</p></blockquote><p>我们将上文中介绍 Linux 条件变量的例子改写成 <code>C++ 11</code> 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;condition_variable&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Task(int taskID)</span><br><span class="line">    {</span><br><span class="line">        this-&gt;taskID = taskID;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void doTask()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; "handle a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int taskID;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">std::mutex                mymutex;</span><br><span class="line">std::list&lt;Task*&gt;          tasks;</span><br><span class="line">std::condition_variable   mycv;</span><br><span class="line"></span><br><span class="line">void* consumer_thread()</span><br><span class="line">{    </span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        std::unique_lock&lt;std::mutex&gt; guard(mymutex);</span><br><span class="line">        while (tasks.empty())</span><br><span class="line">        {               </span><br><span class="line">            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行</span><br><span class="line">            //当发生变化后，条件合适，pthread_cond_wait将直接获得锁</span><br><span class="line">            mycv.wait(guard);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pTask = tasks.front();</span><br><span class="line">        tasks.pop_front();</span><br><span class="line"></span><br><span class="line">        if (pTask == NULL)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        pTask-&gt;doTask();</span><br><span class="line">        delete pTask;</span><br><span class="line">        pTask = NULL;       </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* producer_thread()</span><br><span class="line">{</span><br><span class="line">    int taskID = 0;</span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        pTask = new Task(taskID);</span><br><span class="line"></span><br><span class="line">        //使用括号减小guard锁的作用范围</span><br><span class="line">        {</span><br><span class="line">            std::lock_guard&lt;std::mutex&gt; guard(mymutex);</span><br><span class="line">            tasks.push_back(pTask);</span><br><span class="line">            std::cout &lt;&lt; "produce a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl; </span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //释放信号量，通知消费者线程</span><br><span class="line">        mycv.notify_one();</span><br><span class="line"></span><br><span class="line">        taskID ++;</span><br><span class="line"></span><br><span class="line">        //休眠1秒</span><br><span class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //创建5个消费者线程</span><br><span class="line">    std::thread consumer1(consumer_thread);</span><br><span class="line">    std::thread consumer2(consumer_thread);</span><br><span class="line">    std::thread consumer3(consumer_thread);</span><br><span class="line">    std::thread consumer4(consumer_thread);</span><br><span class="line">    std::thread consumer5(consumer_thread);</span><br><span class="line"></span><br><span class="line">    //创建一个生产者线程</span><br><span class="line">    std::thread producer(producer_thread);</span><br><span class="line"></span><br><span class="line">    producer.join();</span><br><span class="line">    consumer1.join();</span><br><span class="line">    consumer2.join();</span><br><span class="line">    consumer3.join();</span><br><span class="line">    consumer4.join();</span><br><span class="line">    consumer5.join();</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译并执行程序输出结果如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o cpp11cv cpp11cv.cpp -std=c++0x -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./cpp11cv </span><br><span class="line">produce a task, taskID: 0, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 0, threadID: 140427623671552</span><br><span class="line">produce a task, taskID: 1, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 1, threadID: 140427632064256</span><br><span class="line">produce a task, taskID: 2, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 2, threadID: 140427615278848</span><br><span class="line">produce a task, taskID: 3, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 3, threadID: 140427606886144</span><br><span class="line">produce a task, taskID: 4, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 4, threadID: 140427598493440</span><br><span class="line">produce a task, taskID: 5, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 5, threadID: 140427623671552</span><br><span class="line">produce a task, taskID: 6, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 6, threadID: 140427632064256</span><br><span class="line">produce a task, taskID: 7, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 7, threadID: 140427615278848</span><br><span class="line">produce a task, taskID: 8, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 8, threadID: 140427606886144</span><br><span class="line">produce a task, taskID: 9, threadID: 140427590100736</span><br><span class="line">handle a task, taskID: 9, threadID: 140427598493440</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，如果在 Linux 平台上，<code>std::condition_variable</code> 也存在虚假唤醒这一现象，如何避免与上文中介绍 Linux 原生的条件变量方法一样。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>除了 <code>std::mutex</code>、<code>std::condition_variable</code> 类，<code>C++ 11/14/17</code> 还同步引入的其他一些多线程资源同步辅助类，如 <code>std::lock_guard</code>、<code>std::unique_lock</code> 等，它们被加入 C++ 语言中极大地方便了 C++ 的跨平台开发。当然，读者一定要明白，这些引入的对象其实就是前面章节介绍的 <code>mutex</code>、条件变量等操作系统平台的多线程资源同步 API 的封装。</p><blockquote><p>从笔者自身的开发经历来说，自从有了 <code>std::mutex</code>、<code>std::condition_variable</code> 等对象，我在项目中大量使用他们，很少再使用操作系统本身提供的多线程资源同步 API 了，它们也在各种开源 C++ 项目中广泛使用。</p></blockquote><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 线程同步之读写锁</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-13/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-13/</id>
    <published>2021-10-18T06:04:23.000Z</published>
    <updated>2022-05-01T13:40:22.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-TuXCNfOW" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1826142553" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Linux-线程同步之读写锁"><a href="#Linux-线程同步之读写锁" class="headerlink" title="Linux 线程同步之读写锁"></a>Linux 线程同步之读写锁</h1><p>在实际应用中，很多时候对共享变量的访问有以下特点：</p><blockquote><p>大多数情况下线程只是读取共享变量的值，并不修改，只有在极少数情况下，线程才会真正地修改共享变量的值。</p></blockquote><p>对于这种情况，读请求之间是无需同步的，它们之间的并发访问是安全的。然而写请求必须锁住读请求和其他写请求。</p><p>这种情况在实际中是存在的，如读取一个全局对象的状态属性，大多数情况下这个状态属性值是不会变化的，偶尔才会出现被修改的情况。如果使用互斥量，完全阻止读请求并发，则会造成性能的损失。</p><h2 id="读写锁使用方法"><a href="#读写锁使用方法" class="headerlink" title="读写锁使用方法"></a>读写锁使用方法</h2><p>读写锁在 Linux 系统中使用类型 <code>pthread_rwlock_t</code> 表示，读写锁的初始化和销毁使用如下系统 API 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr);</span><br><span class="line">int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);</span><br></pre></td></tr></table></figure><p>参数 <code>rwlock</code> 即需要初始化和销毁的读写锁对象的地址，参数 <code>attr</code> 用于设置读写锁的属性，一般设置未 <code>NULL</code> 表示使用默认属性。函数调用成功返回 0，调用失败返回非 0 值，你可以通过检测错误码 <code>errno</code> 获取错误原因。</p><p>当然，如果你不需要动态创建或者设置非默认属性的读写锁对象，也可以使用如下语法初始化一个读写锁对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlock_t myrwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br></pre></td></tr></table></figure><p>下面是三个请求读锁的系统 API 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);</span><br><span class="line">int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock);</span><br><span class="line">int pthread_rwlock_timedrdlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);</span><br></pre></td></tr></table></figure><p>而下面三个请求写锁的系统 API 接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);</span><br><span class="line">int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock);</span><br><span class="line">int pthread_rwlock_timedwrlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);</span><br></pre></td></tr></table></figure><p>读锁用于共享模式：</p><ul><li>如果当前读写锁已经被某线程以读模式占有了，其他线程调用 <code>pthread_rwlock_rdlock</code> （请求读锁）会立刻获得读锁；</li><li>如果当前读写锁已经被某线程以读模式占有了，其他线程调用 <code>pthread_rwlock_wrlock</code> （请求写锁）会陷入阻塞。</li></ul><p>写锁用的是独占模式：</p><ul><li>如果当前<strong>读写锁</strong>被某线程以<strong>写模式</strong>占有，无论调用 <code>pthread_rwlock_rdlock</code> 还是 <code>pthread_rwlock_wrlock</code> 都会陷入<strong>阻塞</strong>，即<strong>写模式</strong>下不允许任何<strong>读锁</strong>请求通过，也不允许任何<strong>写锁</strong>请求通过，<strong>读锁</strong>请求和<strong>写锁</strong>请求都要陷入<strong>阻塞</strong>，直到线程释放<strong>写锁</strong>。<br>可以将上述读写锁逻辑总结成如下表格：</li></ul><p>|锁当前状态/其他线程请求锁类型|    请求读锁|    请求写锁|<br>|—|—|<br>|无锁|    通过|    通过|<br>|已经获得读锁|    通过|    阻止|<br>|已经获得写锁|    阻止|    阻止|<br>无论是读锁还是写锁，锁的释放都是一个接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlock_unlock (pthread_rwlock_t* rwlock);</span><br></pre></td></tr></table></figure><p>无论是请求读锁还是写锁，都提供了 <code>trylock</code> 的功能（<code>pthread_rwlock_tryrdlock</code> 和 <code>pthread_rwlock_trywrlock</code>），调用线程不会阻塞，而会立即返回。如果能成功获得读锁或者写锁，函数返回 0，如果不能获得读锁或写锁时，函数返回非 0 值，此时错误码 <code>errno</code> 是 <code>EBUSY</code>。</p><p>当然，无论是请求读锁还是写锁都提供了限时等待功能，如果不能获取读写锁，则会陷入阻塞，最多等待到参数 <code>abstime</code> 设置的时间；如果仍然无法获得锁，则返回，错误码 <code>errno</code> 是 <code>ETIMEOUT</code>。</p><h2 id="读写锁的属性"><a href="#读写锁的属性" class="headerlink" title="读写锁的属性"></a>读写锁的属性</h2><p>上文介绍 <code>pthread_rwlock_init</code> 函数时，提到其第二个参数可以设置读写锁的属性，读写锁的属性类型是 <code>pthread_rwlockattr_t</code> ，<code>glibc</code> 引入了如下接口来查询和改变读写锁的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t* attr, int pref);</span><br><span class="line">int pthread_rwlockattr_getkind_np(const pthread_rwlockattr_t* attr, int* pref);</span><br></pre></td></tr></table></figure><p><code>pthread_rwlockattr_setkind_np</code> 的第二个参数 <code>pref</code> 即设置读写锁的类型，其取值有如下几种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">enum</span><br><span class="line">{</span><br><span class="line">    //读者优先（即同时请求读锁和写锁时，请求读锁的线程优先获得锁）</span><br><span class="line">    PTHREAD_RWLOCK_PREFER_READER_NP, </span><br><span class="line">    //不要被名字所迷惑，也是读者优先</span><br><span class="line">    PTHREAD_RWLOCK_PREFER_WRITER_NP, </span><br><span class="line">    //写者优先（即同时请求读锁和写锁时，请求写锁的线程优先获得锁）</span><br><span class="line">    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,                 </span><br><span class="line">    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>当然，为了得到一个有效的 <code>pthread_rwlockattr_t</code> 对象，你需要调用 <code>pthread_rwlockattr_init</code> 函数初始化这样一个属性对象，在你不需要的时候记得使用 <code>pthread_rwlockattr_destroy</code> 销毁之：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_rwlockattr_init(pthread_rwlockattr_t* attr);</span><br><span class="line">int pthread_rwlockattr_destroy(pthread_rwlockattr_t* attr);</span><br></pre></td></tr></table></figure><p>以下代码片段演示了如何初始化一个写者优先的读写锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pthread_rwlockattr_t attr;</span><br><span class="line">pthread_rwlockattr_init(&amp;attr);</span><br><span class="line">pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</span><br><span class="line">pthread_rwlock_t rwlock;</span><br><span class="line">pthread_rwlock_init(&amp;rwlock, &amp;attr);</span><br></pre></td></tr></table></figure><p>读写锁使用示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int resourceID = 0;</span><br><span class="line">pthread_rwlock_t myrwlock;</span><br><span class="line"></span><br><span class="line">void* read_thread(void* param)</span><br><span class="line">{    </span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求读锁</span><br><span class="line">        pthread_rwlock_rdlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "read thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        //使用睡眠模拟读线程读的过程消耗了很久的时间</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* write_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求写锁</span><br><span class="line">        pthread_rwlock_wrlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        ++resourceID;</span><br><span class="line">        std::cout &lt;&lt; "write thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        //使用睡眠模拟读线程读的过程消耗了很久的时间</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_rwlock_init(&amp;myrwlock, NULL);</span><br><span class="line"></span><br><span class="line">    //创建5个请求读锁线程</span><br><span class="line">    pthread_t readThreadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个请求写锁线程</span><br><span class="line">    pthread_t writeThreadID;</span><br><span class="line">    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(writeThreadID, NULL);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(readThreadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述程序中创建五个请求读锁的“读”线程和一个请求写锁的“写”线程，共享的资源是一个整形变量 <code>resourceID</code>，我们编译并执行得到输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o rwlock rwlock.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./rwlock</span><br><span class="line">read thread ID: 140575861593856, resourceID: 0</span><br><span class="line">read thread ID: 140575878379264, resourceID: 0</span><br><span class="line">read thread ID: 140575853201152, resourceID: 0</span><br><span class="line">read thread ID: 140575869986560, resourceID: 0</span><br><span class="line">read thread ID: 140575886771968, resourceID: 0</span><br><span class="line">read thread ID: read thread ID: read thread ID: read thread ID: 140575861593856140575886771968, resourceID: 0, resourceID: </span><br><span class="line">0</span><br><span class="line">140575878379264read thread ID: 140575869986560, resourceID: 0</span><br><span class="line">, resourceID: 0</span><br><span class="line">140575853201152, resourceID: 0</span><br><span class="line">read thread ID: read thread ID: read thread ID: 140575861593856140575853201152140575886771968, resourceID: , resourceID: 0, resourceID: 00</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read thread ID: 140575869986560, resourceID: 0</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure><p>上述输出结果，我们验证了两个结论：</p><ul><li>由于读写锁对象 <code>myrwlock</code> 使用了默认属性，其行为是请求读锁的线程优先获得到锁，请求写锁的线程 <code>write_thread</code> 很难获得锁的机会，因此结果中基本没有请求写锁线程的输出结果；</li><li>由于多个请求读锁的线程 <code>read_thread</code> 可以自由获得读锁，且代码 15 行（<code>std::cout &lt;&lt; "read thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</code>）的输出不是原子性的，因而多个“读”线程的输出可能会交替，出现“错乱”现象。<br>我们将读写锁对象 <code>myrwlock</code> 的属性修改成请求写锁优先，再来试一试：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int resourceID = 0;</span><br><span class="line">pthread_rwlock_t myrwlock;</span><br><span class="line"></span><br><span class="line">void* read_thread(void* param)</span><br><span class="line">{    </span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求读锁</span><br><span class="line">        pthread_rwlock_rdlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "read thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        //使用睡眠模拟读线程读的过程消耗了很久的时间</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* write_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求写锁</span><br><span class="line">        pthread_rwlock_wrlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        ++resourceID;</span><br><span class="line">        std::cout &lt;&lt; "write thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        //使用睡眠模拟读线程读的过程消耗了很久的时间</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_rwlockattr_t attr;</span><br><span class="line">    pthread_rwlockattr_init(&amp;attr);</span><br><span class="line">    //设置成请求写锁优先</span><br><span class="line">    pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</span><br><span class="line">    pthread_rwlock_init(&amp;myrwlock, &amp;attr);</span><br><span class="line"></span><br><span class="line">    //创建5个请求读锁线程</span><br><span class="line">    pthread_t readThreadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个请求写锁线程</span><br><span class="line">    pthread_t writeThreadID;</span><br><span class="line">    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(writeThreadID, NULL);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(readThreadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>编译程序并运行，输出结果如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o rwlock2 rwlock2.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./rwlock2</span><br><span class="line">read thread ID: 140122217539328, resourceID: 0</span><br><span class="line">read thread ID: 140122242717440, resourceID: 0</span><br><span class="line">read thread ID: 140122209146624, resourceID: 0</span><br><span class="line">write thread ID: 140122200753920, resourceID: 1</span><br><span class="line">read thread ID: 140122234324736, resourceID: 1</span><br><span class="line">write thread ID: 140122200753920, resourceID: 2</span><br><span class="line">write thread ID: 140122200753920, resourceID: 3</span><br><span class="line">write thread ID: 140122200753920, resourceID: 4</span><br><span class="line">write thread ID: 140122200753920, resourceID: 5</span><br><span class="line">write thread ID: 140122200753920, resourceID: 6</span><br><span class="line">write thread ID: 140122200753920, resourceID: 7</span><br><span class="line">write thread ID: 140122200753920, resourceID: 8</span><br><span class="line">write thread ID: 140122200753920, resourceID: 9</span><br><span class="line">write thread ID: 140122200753920, resourceID: 10</span><br><span class="line">write thread ID: 140122200753920, resourceID: 11</span><br><span class="line">write thread ID: 140122200753920, resourceID: 12</span><br><span class="line">write thread ID: 140122200753920, resourceID: 13</span><br><span class="line">read thread ID: 140122217539328, resourceID: 13</span><br><span class="line">write thread ID: 140122200753920, resourceID: 14</span><br><span class="line">write thread ID: 140122200753920, resourceID: 15</span><br><span class="line">write thread ID: 140122200753920, resourceID: 16</span><br><span class="line">write thread ID: 140122200753920, resourceID: 17</span><br><span class="line">write thread ID: 140122200753920, resourceID: 18</span><br><span class="line">write thread ID: 140122200753920, resourceID: 19</span><br><span class="line">write thread ID: 140122200753920, resourceID: 20</span><br><span class="line">write thread ID: 140122200753920, resourceID: 21</span><br><span class="line">write thread ID: 140122200753920, resourceID: 22</span><br><span class="line">write thread ID: 140122200753920, resourceID: 23</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure>由于将 <code>myrwlock</code> 设置成请求写锁优先，上述结果中几乎都是 <code>write_thread</code> 的输出结果。</li></ul><p>我们将 <code>write_thread</code> 中的 37 行 <code>sleep</code> 语句挪到 39 行后面，增加请求写锁线程的睡眠时间，再看看执行结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int resourceID = 0;</span><br><span class="line">pthread_rwlock_t myrwlock;</span><br><span class="line"></span><br><span class="line">void* read_thread(void* param)</span><br><span class="line">{    </span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求读锁</span><br><span class="line">        pthread_rwlock_rdlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; "read thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        //使用睡眠模拟读线程读的过程消耗了很久的时间</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* write_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //请求写锁</span><br><span class="line">        pthread_rwlock_wrlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        ++resourceID;</span><br><span class="line">        std::cout &lt;&lt; "write thread ID: " &lt;&lt; pthread_self() &lt;&lt; ", resourceID: " &lt;&lt; resourceID &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        pthread_rwlock_unlock(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">        //放在这里增加请求读锁线程获得锁的几率</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_rwlockattr_t attr;</span><br><span class="line">    pthread_rwlockattr_init(&amp;attr);</span><br><span class="line">    //设置成请求写锁优先</span><br><span class="line">    pthread_rwlockattr_setkind_np(&amp;attr, PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP);</span><br><span class="line">    pthread_rwlock_init(&amp;myrwlock, &amp;attr);</span><br><span class="line"></span><br><span class="line">    //创建5个请求读锁线程</span><br><span class="line">    pthread_t readThreadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;readThreadID[i], NULL, read_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个请求写锁线程</span><br><span class="line">    pthread_t writeThreadID;</span><br><span class="line">    pthread_create(&amp;writeThreadID, NULL, write_thread, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(writeThreadID, NULL);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(readThreadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_rwlock_destroy(&amp;myrwlock);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>再次编译程序并执行，得到输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o rwlock3 rwlock3.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./rwlock3</span><br><span class="line">read thread ID: 140315524790016, resourceID: 0</span><br><span class="line">read thread ID: 140315549968128, resourceID: 0</span><br><span class="line">read thread ID: 140315541575424, resourceID: 0</span><br><span class="line">write thread ID: 140315508004608, resourceID: 1</span><br><span class="line">read thread ID: 140315549968128, resourceID: 1</span><br><span class="line">read thread ID: 140315541575424, resourceID: 1</span><br><span class="line">read thread ID: 140315524790016, resourceID: 1</span><br><span class="line">read thread ID: 140315516397312, resourceID: 1</span><br><span class="line">read thread ID: 140315533182720, resourceID: 1</span><br><span class="line">write thread ID: 140315508004608, resourceID: 2</span><br><span class="line">read thread ID: 140315541575424, resourceID: 2</span><br><span class="line">read thread ID: 140315524790016, resourceID: 2</span><br><span class="line">read thread ID: 140315533182720, resourceID: 2</span><br><span class="line">read thread ID: 140315516397312, resourceID: 2</span><br><span class="line">read thread ID: 140315549968128, resourceID: 2</span><br><span class="line">read thread ID: 140315516397312, resourceID: 2</span><br><span class="line">write thread ID: 140315508004608, resourceID: 3</span><br><span class="line">read thread ID: 140315549968128, resourceID: 3</span><br><span class="line">read thread ID: 140315541575424, resourceID: 3</span><br><span class="line">read thread ID: 140315533182720, resourceID: 3read thread ID: read thread ID: 140315524790016, resourceID: 3</span><br><span class="line">140315516397312, resourceID: 3</span><br><span class="line"></span><br><span class="line">read thread ID: read thread ID: read thread ID: 140315524790016140315549968128, resourceID: , resourceID: 33</span><br><span class="line">140315516397312, resourceID: 3</span><br><span class="line">read thread ID: 140315541575424, resourceID: read thread ID: 140315533182720, resourceID: 3</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">write thread ID: 140315508004608, resourceID: 4</span><br><span class="line">read thread ID: 140315516397312, resourceID: 4</span><br><span class="line">read thread ID: 140315541575424, resourceID: 4</span><br><span class="line">read thread ID: 140315524790016, resourceID: 4</span><br><span class="line">read thread ID: 140315549968128, resourceID: 4</span><br><span class="line">read thread ID: 140315533182720, resourceID: 4</span><br><span class="line">read thread ID: 140315524790016, resourceID: 4</span><br><span class="line">read thread ID: 140315541575424, resourceID: 4</span><br><span class="line">write thread ID: 140315508004608, resourceID: 5</span><br><span class="line">read thread ID: 140315516397312, resourceID: 5</span><br><span class="line">read thread ID: 140315541575424, resourceID: 5</span><br><span class="line">read thread ID: 140315524790016, resourceID: 5</span><br><span class="line">read thread ID: 140315533182720, resourceID: 5</span><br><span class="line">read thread ID: 140315549968128, resourceID: 5</span><br></pre></td></tr></table></figure><p>这次请求读锁的线程和请求写锁的线程的输出结果分布就比较均匀了。</p><p>以上例子比较简单，建议读者实际运行一下代码实验一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>mutex</code> 多线程之间，无论线程对共享资源是读还是写一概加上锁，加锁期间，不允许其他线程进行任何操作，而读写锁允许多个线程的读操作，因此相对于 <code>mutex</code> 提高了效率， 这也是 <code>boost::mutex</code> 和 <code>boost::shared_mutex</code> 在 Linux 平台的实现原理，前者使用 <code>mutex</code> 实现，后者使用读写锁实现。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 线程同步之条件变量</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-12/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-12/</id>
    <published>2021-10-18T05:56:20.000Z</published>
    <updated>2022-05-01T13:40:22.713Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-IFOroEyq" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="2059056" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Linux-线程同步之条件变量"><a href="#Linux-线程同步之条件变量" class="headerlink" title="Linux 线程同步之条件变量"></a>Linux 线程同步之条件变量</h1><p>有人说 Linux 条件变量（<code>Condition Variable</code>）是最不会用错的一种线程同步对象，确实是这样，但这必须建立在你对条件变量熟练使用的基础之上。我们先来讨论一下为什么会存在条件变量这样一种机制。</p><h2 id="为什么需要使用条件变量"><a href="#为什么需要使用条件变量" class="headerlink" title="为什么需要使用条件变量"></a>为什么需要使用条件变量</h2><p>实际应用中，我们常常会有类似如下需求：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//以下是伪码，m 的类型是 pthread_mutex_t，并且已经初始化过了</span><br><span class="line">int WaitForTrue()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_lock(&amp;m);</span><br><span class="line">    while (condition is false)      //条件不满足</span><br><span class="line">    {</span><br><span class="line">        pthread_mutex_unlock(&amp;m);   //解锁等待其他线程改变 condition</span><br><span class="line">        sleep(n);                   //睡眠n秒</span><br><span class="line">        //n秒后再次加锁验证条件是否满足</span><br><span class="line">        pthread_mutex_lock(&amp;m);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上逻辑可以表示成如下流程图：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded13.1lhc2y26j7mo.jpg" alt="multithreaded13"></p><p>这段逻辑的用途是我们需要反复判断一个多线程共享条件是否满足，一直到该条件满足为止，由于该条件被多个线程操作因此每次判断之前都需要进行加锁操作，判断完毕后需要进行解锁操作。但是上述逻辑存在严重的效率问题，假设解锁离开临界区后，此时由于其他线程修改了条件导致条件满足了，此时程序仍然需要睡眠 n 秒后才能得到反馈。因此我们需要这样一种机制：</p><blockquote><p>某个线程 A 在条件不满足的情况下，主动让出互斥量，让其他线程去折腾，线程在此处等待，等待条件的满足；一旦条件满足，线程就可以被立刻唤醒。线程 A 之所以可以安心等待，依赖的是其他线程的协作，它确信会有一个线程在发现条件满足以后，将向它发送信号，并且让出互斥量。如果其他线程不配合（不发信号，不让出互斥量），这个主动让出互斥量并等待事件发生的线程 A 就真的要等到花儿都谢了。</p></blockquote><p>这个例子解释了为什么需要条件等待，但是条件等待还不是条件变量的全部功能。</p><h2 id="条件变量为什么要与互斥体对象结合"><a href="#条件变量为什么要与互斥体对象结合" class="headerlink" title="条件变量为什么要与互斥体对象结合"></a>条件变量为什么要与互斥体对象结合</h2><p>很多第一次学习 Linux 条件变量的读者会觉得困惑：为什么条件变量一定要与一个互斥体对象结合使用？我们来看下，假设条件变量不与互斥体对象结合的效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 //m的类型是 pthread_mutex_t，并且已经初始化过了，cv 是条件变量</span><br><span class="line">2 pthread_mutex_lock(&amp;m)</span><br><span class="line">3 while(condition_is_false)</span><br><span class="line">4 {</span><br><span class="line">5     pthread_mutex_unlock(&amp;m);</span><br><span class="line">6     //解锁之后，等待之前，可能条件已经满足，信号已经发出，但是该信号可能会被错过</span><br><span class="line">7     cond_wait(&amp;cv);</span><br><span class="line">8     pthread_mutex_lock(&amp;m);</span><br><span class="line">9 }</span><br></pre></td></tr></table></figure><p>上述代码中，假设线程 A 执行完第 5 行代码 <code>pthread_mutex_unlock(&amp;m)</code>; 后 CPU 时间片被剥夺，此时另外一个线程 B 获得该互斥体对象 m，然后发送条件信号，等线程 A 重新获得时间片后，由于该信号已经被错过了，这样可能会导致线程 A 在 第 7 行 <code>cond_wait(&amp;cv)</code>; 无限阻塞下去。</p><p>造成这个问题的根源是释放互斥体对象与条件变量等待唤醒不是原子操作，即解锁和等待这两个步骤必须是同一个原子性的操作，以确保 <code>cond_wait</code> 唤醒之前不会有其他线程获得这个互斥体对象。</p><h2 id="条件变量的使用"><a href="#条件变量的使用" class="headerlink" title="条件变量的使用"></a>条件变量的使用</h2><p>介绍了这么多，我们来正式介绍一下条件变量相关的系统 API 的使用方法。</p><p>条件变量的初始化和销毁可以使用如下 API 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr);</span><br><span class="line">int pthread_cond_destroy(pthread_cond_t* cond);</span><br></pre></td></tr></table></figure><p>在 Linux 系统中 <code>pthread_cond_t</code> 即是条件变量的类型，当然和前面介绍的互斥体一样，也可以使用如下方式去初始化一个条件变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_t cond = PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure><p>等待条件变量的满足可以使用如下 API 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_wait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex);</span><br><span class="line">int pthread_cond_timedwait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex, const struct timespec* restrict abstime);</span><br></pre></td></tr></table></figure><p>一般情况下如果条件变量代表的条件不会满足，调用 <code>pthread_cond_wait</code> 的线程会一直等待下去；<code>pthread_cond_timedwait</code> 是 <code>pthread_cond_wait</code> 非阻塞版本，它会在指定时间内等待条件满足，超过参数 <code>abstime</code> 设置的时候后 <code>pthread_cond_timedwait</code> 函数会立即返回。</p><blockquote><p>注意：对于参数 <code>abstime</code>，正如其名字暗示的，这是一个 <code>absolute time</code>（绝对时间），也就是说，如果你打算让函数等待 5 秒，那么你应该先得到当前系统的时间，然后加上 5 秒计算出最终的时间作为参数 <code>abstime</code> 的值。</p></blockquote><p>因调用 <code>pthread_cond_wait</code> 等待的线程可以被以下 API 函数唤醒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_cond_signal(pthread_cond_t* cond);</span><br><span class="line">int pthread_cond_broadcast(pthread_cond_t* cond);     </span><br></pre></td></tr></table></figure><p><code>pthread_cond_signal</code> 一次唤醒一个线程，如果有多个线程调用 <code>pthread_cond_wait</code> 等待，具体哪个线程被唤醒是不确定的（可以认为是随机的）；<code>pthread_cond_broadcast</code> 可以同时唤醒多个调用 <code>pthread_cond_wait</code> 等待的线程。前者相当于发送一次条件通知，后者广播一次条件通知。成功等待到条件信号，<code>pthread_cond_signal</code> 和 <code>pthread_cond_broadcast</code> 返回 0，反之返回非 0 值，具体错误原因可以通过错误码 <code>errno</code> 获得。</p><p>我们将前文中介绍信号量的示例代码用条件变量来改写下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Task(int taskID)</span><br><span class="line">    {</span><br><span class="line">        this-&gt;taskID = taskID;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void doTask()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; "handle a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int taskID;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">pthread_mutex_t  mymutex;</span><br><span class="line">std::list&lt;Task*&gt; tasks;</span><br><span class="line">pthread_cond_t   mycv;</span><br><span class="line"></span><br><span class="line">void* consumer_thread(void* param)</span><br><span class="line">{    </span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">        while (tasks.empty())</span><br><span class="line">        {               </span><br><span class="line">            //如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait 会释放锁，不往下执行</span><br><span class="line">            //当发生变化后，条件合适，pthread_cond_wait 将直接获得锁</span><br><span class="line">            pthread_cond_wait(&amp;mycv, &amp;mymutex);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pTask = tasks.front();</span><br><span class="line">        tasks.pop_front();</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        if (pTask == NULL)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        pTask-&gt;doTask();</span><br><span class="line">        delete pTask;</span><br><span class="line">        pTask = NULL;       </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* producer_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    int taskID = 0;</span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        pTask = new Task(taskID);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">        tasks.push_back(pTask);</span><br><span class="line">        std::cout &lt;&lt; "produce a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        //释放信号量，通知消费者线程</span><br><span class="line">        pthread_cond_signal(&amp;mycv);</span><br><span class="line"></span><br><span class="line">        taskID ++;</span><br><span class="line"></span><br><span class="line">        //休眠1秒</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, NULL);</span><br><span class="line">    pthread_cond_init(&amp;mycv, NULL);</span><br><span class="line"></span><br><span class="line">    //创建 5 个消费者线程</span><br><span class="line">    pthread_t consumerThreadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个生产者线程</span><br><span class="line">    pthread_t producerThreadID;</span><br><span class="line">    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(producerThreadID, NULL);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(consumerThreadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_cond_destroy(&amp;mycv);</span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译并执行上述程序，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsemaphore]# g++ -g -o cv cv.cpp -lpthread</span><br><span class="line">[root@localhost testsemaphore]# ./cv</span><br><span class="line">produce a task, taskID: 0, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 0, threadID: 140571242518272</span><br><span class="line">produce a task, taskID: 1, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 1, threadID: 140571225732864</span><br><span class="line">produce a task, taskID: 2, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 2, threadID: 140571208947456</span><br><span class="line">produce a task, taskID: 3, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 3, threadID: 140571242518272</span><br><span class="line">produce a task, taskID: 4, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 4, threadID: 140571234125568</span><br><span class="line">produce a task, taskID: 5, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 5, threadID: 140571217340160</span><br><span class="line">produce a task, taskID: 6, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 6, threadID: 140571225732864</span><br><span class="line">produce a task, taskID: 7, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 7, threadID: 140571208947456</span><br><span class="line">produce a task, taskID: 8, threadID: 140571200554752</span><br><span class="line">handle a task, taskID: 8, threadID: 140571242518272</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure><p>条件变量最关键的一个地方就是需要清楚地记得 <code>pthread_cond_wait</code> 在条件满足与不满足时的两种行为，这是难点也是<strong>重点</strong>：</p><ul><li>当 <code>pthread_cond_wait</code> 函数阻塞时，它会释放其绑定的互斥体，并阻塞线程，因此在调用该函数前应该对互斥体有个加锁操作（上述代码的第 34 行的 <code>pthread_mutex_lock(&amp;mymutex)</code>;）。</li><li>当收到条件信号时， <code>pthread_cond_wait</code> 会返回并对其绑定的互斥体进行加锁，因此在其下面一定有个对互斥体进行解锁的操作（上述代码的第 45 行 <code>pthread_mutex_unlock(&amp;mymutex)</code>;）。<h2 id="条件变量的虚假唤醒"><a href="#条件变量的虚假唤醒" class="headerlink" title="条件变量的虚假唤醒"></a>条件变量的虚假唤醒</h2>上面将互斥量和条件变量配合使用的示例代码中有个很有意思的地方，就是用了 <code>while</code> 语句，醒来 之后要再次判断条件是否满足。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while (tasks.empty())</span><br><span class="line">{                </span><br><span class="line">    pthread_cond_wait(&amp;mycv, &amp;mymutex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>为什么不写成：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (tasks.empty())</span><br><span class="line">{                </span><br><span class="line">    pthread_cond_wait(&amp;mycv, &amp;mymutex);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>答案是不得不如此。因为可能某次操作系统唤醒 <code>pthread_cond_wait</code> 时 <code>tasks.empty()</code> 可能仍然为 <code>true</code>，言下之意就是操作系统可能会在一些情况下唤醒条件变量，即使没有其他线程向条件变量发送信号，等待此条件变量的线程也有可能会醒来。我们将条件变量的这种行为称之为 <strong>虚假唤醒</strong> （spurious wakeup）。因此将条件（判断 <code>tasks.empty()</code> 为 <code>true</code>）放在一个 <code>while</code> 循环中意味着光唤醒条件变量不行，还必须条件满足程序才能继续执行正常的逻辑。</li></ul><p>这看起来这像是个 <code>bug</code>，但它在 Linux 系统中是实实在在存在的。为什么会存在虚假唤醒呢？一个原因是：<code>pthread_cond_wait</code> 是 <code>futex</code> 系统调用，属于阻塞型的系统调用，当系统调用被信号中断的时候，会返回 ﹣1，并且把 <code>errno</code> 错误码置为 <code>EINTR</code>。很多这种系统调用为了防止被信号中断都会重启系统调用（即再次调用一次这个函数），代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pid_t r_wait(int *stat_loc)</span><br><span class="line">{</span><br><span class="line">    int retval;</span><br><span class="line">    //wait 函数因为被信号中断导致调用失败会返回 ﹣1，错误码是 EINTR  </span><br><span class="line">    //注意：这里的 while 循环体是一条空语句</span><br><span class="line">    while(((retval = wait(stat_loc)) == -1 &amp;&amp; (errno == EINTR));</span><br><span class="line"></span><br><span class="line">    return retval;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>但是 <code>pthread_cond_wait</code> 用途有点不一样，假设 <code>pthread_cond_wait</code> 函数被信号中断了，在 <code>pthread_cond_wait</code> 返回之后，到重新调用之前，<code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code> 可能已经调用过。一旦错失，可能由于条件信号不再产生，再次调用 <code>pthread_cond_wait</code> 将导致程序无限制地等待下去。为了避免这种情况，宁可虚假唤醒，也不能再次调用 <code>pthread_cond_wait</code>，以免陷入无穷的等待中。</p><p>除了上面的信号因素外，还存在以下情况：条件满足了发送信号，但等到调用 <code>pthread_cond_wait</code> 的线程得到 CPU 资源时，条件又再次不满足了。</p><p>好在无论是哪种情况，醒来之后再次测试条件是否满足就可以解决虚假等待的问题。这就是使用 <code>while</code> 循环来判断条件，而不是使用 <code>if</code> 语句的原因。</p><h2 id="条件变量信号丢失问题"><a href="#条件变量信号丢失问题" class="headerlink" title="条件变量信号丢失问题"></a>条件变量信号丢失问题</h2><p>上文中，我们介绍了，如果一个条件变量信号条件产生时（调用 <code>pthread_cond_signal</code> 或 <code>pthread_cond_broadcast</code>），没有相关的线程调用 <code>pthread_cond_wait</code> 捕获该信号，那么该信号条件就会永久性地丢失了，再次调用 <code>pthread_cond_wait</code> 会导致永久性的阻塞。这种情况在设计那些条件变量信号条件只会产生一次的逻辑中尤其需要注意，例如假设现在某个程序有一批等待条件变量的线程，和一个只产生一次条件变量信号的线程。为了让你的等待条件变量的线程能正常运行不阻塞，你的逻辑中，一定要确保等待的线程在产生条件变量信号的线程发送条件信号之前调用 <code>pthread_cond_wait</code> 。</p><blockquote><p>这和生活中的很多例子一样，即许多事情你只有一次机会，必须提前准备好再去尝试这次机会，这个机会不会等待你的准备，一旦错过，就不会再有第二次机会了。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节介绍了学习 Linux 条件变量需要掌握的重难点知识，条件变量是最常用的一种多线程编程同步技术之一，也是面试高频问题之一，建议打算从事相关工作的读者务必理解和熟练使用它。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 线程同步之信号量</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-11/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-11/</id>
    <published>2021-10-18T05:51:03.000Z</published>
    <updated>2022-05-01T13:40:22.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-FDTXGhAU" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1320776019" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Linux-线程同步之信号量"><a href="#Linux-线程同步之信号量" class="headerlink" title="Linux 线程同步之信号量"></a>Linux 线程同步之信号量</h1><p>与 Windows 的 Semaphore 对象使用原理一样，Linux 的信号量本质上也是暗含着“资源有多份，可以同时被多个线程访问”的意味，故信号量的原理这里不再赘述。</p><p>Linux 信号量常用的一组 API 函数是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">int sem_init(sem_t* sem, int pshared, unsigned int value);</span><br><span class="line">int sem_destroy(sem_t* sem);</span><br><span class="line">int sem_post(sem_t* sem);</span><br><span class="line">int sem_wait(sem_t* sem);</span><br><span class="line">int sem_trywait(sem_t* sem);</span><br><span class="line">int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout);</span><br></pre></td></tr></table></figure><ul><li>函数 <code>sem_init</code> 用于初始化一个信号量，第一个参数 <code>sem</code> 传入需要初始化的信号量对象的地址；第二个参数 <code>pshared</code> 表示该信号量是否可以被共享，取值为 0 表示该信号量可以在同一个进程多个线程之间共享，取值为非 0 表示可以在多个进程之间共享；第三个参数 <code>value</code> 用于设置信号量初始状态下资源的数量。函数 sem_init 函数调用成功返回 0，失败返回 -1，实际编码中只要我们的写法得当一般不用关心该函数的返回值。</li><li>函数 <code>sem_destroy</code> 用于销毁一个信号量。</li><li>函数 <code>sem_post</code> 将信号量的资源计数递增 1，并解锁该信号量对象，这样其他由于使用 <code>sem_wait</code> 被阻塞的线程会被唤醒。</li><li>如果当前信号量资源计数为 0，函数 <code>sem_wait</code> 会阻塞调用线程；直到信号量对象的资源计数大于 0 时被唤醒，唤醒后将资源计数递减 1，然后立即返回；函数 <code>sem_trywait</code> 是函数 <code>sem_wait</code> 的非阻塞版本，如果当前信号量对象的资源计数等于 0，<code>sem_trywait</code> 会立即返回不会阻塞调用线程，返回值是 ﹣1，错误码 <code>errno</code> 被设置成 <code>EAGAIN</code>；函数 <code>sem_timedwait</code> 是带有等待时间的版本，等待时间在第二个参数 <code>abs_timeout</code> 中设置，这是个结构体的定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct timespec</span><br><span class="line">{</span><br><span class="line">    time_t tv_sec;      /* 秒 */</span><br><span class="line">    long   tv_nsec;     /* 纳秒 [0 .. 999999999] */</span><br><span class="line">};</span><br></pre></td></tr></table></figure><code>sem_timedwait</code> 在参数 <code>abs_timeout</code> 设置的时间内等待信号量对象的资源计数大于0，否则超时返回，返回值为 ﹣1，错误码 <code>errno</code> 是 <code>ETIMEDOUT</code>。当使用 <code>sem_timedwait</code> 时，参数 <code>abs_timeout</code> 不能设置为 <code>NULL</code>，否则程序会在运行时调用 <code>sem_timedwait</code> 产生崩溃。</li></ul><blockquote><p>注意：</p><p><code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 函数将资源计数递减一时会同时锁定信号量对象，因此当资源计数为 1 时，如果有多个线程调用 <code>sem_wait</code> 等函数等待该信号量时，只会有一个线程被唤醒。当 <code>sem_wait</code> 函数返回时，会释放对该信号量的锁。</p><p><code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 函数调用成功后返回值均为 0，调用失败返回 ﹣1，可以通过错误码 errno 获得失败原因。</p><p><code>sem_wait</code>、<code>sem_trywait</code>、<code>sem_timedwait</code> 可以被 Linux 信号中断，被信号中断后，函数立即返回，返回值是 ﹣1，错误码 <code>errno</code> 为 <code>EINTR</code>。</p></blockquote><p>虽然上述函数没有以 <code>pthread_</code> 作为前缀，实际使用这个系列的函数时需要链接 <code>pthread</code> 库。</p><p>我们看一个信号量的具体使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;semaphore.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Task</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Task(int taskID)</span><br><span class="line">    {</span><br><span class="line">        this-&gt;taskID = taskID;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void doTask()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; "handle a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int taskID;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">pthread_mutex_t  mymutex;</span><br><span class="line">std::list&lt;Task*&gt; tasks;</span><br><span class="line">sem_t            mysemaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void* consumer_thread(void* param)</span><br><span class="line">{    </span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        if (sem_wait(&amp;mysemaphore) != 0)</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        if (tasks.empty())</span><br><span class="line">            continue;</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mymutex);   </span><br><span class="line">        pTask = tasks.front();</span><br><span class="line">        tasks.pop_front();</span><br><span class="line">        pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        pTask-&gt;doTask();</span><br><span class="line">        delete pTask;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void* producer_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    int taskID = 0;</span><br><span class="line">    Task* pTask = NULL;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        pTask = new Task(taskID);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">        tasks.push_back(pTask);</span><br><span class="line">        std::cout &lt;&lt; "produce a task, taskID: " &lt;&lt; taskID &lt;&lt; ", threadID: " &lt;&lt; pthread_self() &lt;&lt; std::endl; </span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        //释放信号量，通知消费者线程</span><br><span class="line">        sem_post(&amp;mysemaphore);</span><br><span class="line"></span><br><span class="line">        taskID ++;</span><br><span class="line"></span><br><span class="line">        //休眠1秒</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, NULL);</span><br><span class="line">    //初始信号量资源计数为0</span><br><span class="line">    sem_init(&amp;mysemaphore, 0, 0);</span><br><span class="line"></span><br><span class="line">    //创建5个消费者线程</span><br><span class="line">    pthread_t consumerThreadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;consumerThreadID[i], NULL, consumer_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //创建一个生产者线程</span><br><span class="line">    pthread_t producerThreadID;</span><br><span class="line">    pthread_create(&amp;producerThreadID, NULL, producer_thread, NULL);</span><br><span class="line"></span><br><span class="line">    pthread_join(producerThreadID, NULL);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(consumerThreadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    sem_destroy(&amp;mysemaphore);</span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上代码中我们创建一个生产者线程和 5 个消费者线程，初始信号量计数为 0 代表开始没有可执行任务，因此 5 个消费线程均阻塞在 <code>sem_wait</code> 调用处，接着生产者每隔 1 秒产生一个任务，然后通过调用 <code>sem_post</code> 将信号量资源计数增加一，此时其中一个线程会被唤醒，然后从任务队列中取出任务，执行任务，由于任务对象是 <code>new</code> 出来的，需要 <code>delete</code> 掉以避免内存泄露。</p><p>有读者可能会奇怪，在调用 <code>sem_wait</code> 和 <code>sem_post</code> 时会对信号量对象进行加锁和解锁，为什么这里还需要使用一个 <code>mutex</code>？这个 <code>mutex</code> 是用来保护队列 <code>tasks</code> 的，因为多个线程会同时读写之。这个例子类似于银行里多个客户等待柜台有空闲办理取钱业务，每次有空闲的柜台，就可以告诉客户，但是多人同时取钱时，银行的资金总账户增减一定是原子性的。</p><p>编译并生成文件 <code>semaphore</code> ，然后运行之，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testsemaphore]# g++ -g -o semaphore semaphore.cpp -lpthread</span><br><span class="line">[root@localhost testsemaphore]# ./semaphore </span><br><span class="line">produce a task, taskID: 0, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 0, threadID: 140055277381376</span><br><span class="line">produce a task, taskID: 1, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 1, threadID: 140055277381376</span><br><span class="line">produce a task, taskID: 2, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 2, threadID: 140055268988672</span><br><span class="line">produce a task, taskID: 3, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 3, threadID: 140055294166784</span><br><span class="line">produce a task, taskID: 4, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 4, threadID: 140055302559488</span><br><span class="line">produce a task, taskID: 5, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 5, threadID: 140055285774080</span><br><span class="line">produce a task, taskID: 6, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 6, threadID: 140055277381376</span><br><span class="line">produce a task, taskID: 7, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 7, threadID: 140055268988672</span><br><span class="line">produce a task, taskID: 8, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 8, threadID: 140055294166784</span><br><span class="line">produce a task, taskID: 9, threadID: 140055260595968</span><br><span class="line">handle a task, taskID: 9, threadID: 140055302559488</span><br><span class="line">...更多输出结果省略...</span><br></pre></td></tr></table></figure><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a>。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux 线程同步之互斥体</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-10/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-10/</id>
    <published>2021-10-18T05:38:19.000Z</published>
    <updated>2022-05-01T13:40:22.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-KtSVTNpv" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1408861641" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Linux-线程同步之互斥体"><a href="#Linux-线程同步之互斥体" class="headerlink" title="Linux 线程同步之互斥体"></a>Linux 线程同步之互斥体</h1><p>介绍完 Windows 上的常用多线程同步内核对象后，我们来看一下 Linux 下的线程同步对象。本讲我们介绍一下 Linux 操作系统的 <code>mutex</code> 对象。</p><h2 id="Linux-mutex-的用法介绍"><a href="#Linux-mutex-的用法介绍" class="headerlink" title="Linux mutex 的用法介绍"></a>Linux mutex 的用法介绍</h2><p>Linux 互斥体的用法和 Windows 的临界区对象用法很相似，一般也是通过限制多个线程同时执行某段代码来达到保护资源的目的。和接下来要介绍的信号量、条件变量一样，Linux 互斥体都实现在 <code>NPTL</code> （<code>Native POSIX Thread Library</code>）。在 <code>NPTL</code> 中我们使用数据结构 <code>pthread_mutex_t</code> 来表示一个互斥体对象（定义于 <code>pthread.h</code> 头文件中）。互斥体对象我们可以使用两种方式来初始化：</p><ul><li><p>使用 PTHREAD_MUTEX_INITIALIZER 直接给互斥体变量赋值<br>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>pthread_mutex_init</code> 函数初始化<br>如果互斥量是动态分配的或者需要给互斥量设置属性，则需要使用 <code>pthread_mutex_init</code> 函数来初始化互斥体，这个函数的签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_init(pthread_mutex_t* restrict mutex, </span><br><span class="line">                      const pthread_mutexattr_t* restrict attr);</span><br></pre></td></tr></table></figure><p>参数 <code>mutex</code> 即我们需要初始化的 <code>mutex</code> 对象的指针，参数 <code>attr</code> 是需要设置的互斥体属性，通常情况下，使用默认属性可以将这个参数设置为 <code>NULL</code>，后面会详细介绍每一种属性的用法。如果函数执行成功则会返回 0，如果执行失败则会返回一个具体的错误码信息。</p><p>pthread_mutex_init 代码示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mymutex;</span><br><span class="line">pthread_mutex_init(&amp;mutex, NULL);</span><br></pre></td></tr></table></figure><p>当不再需要一个互斥体对象时，可以使用 <code>pthread_mutex_destroy</code> 函数来销毁它， <code>pthread_mutex_destroy</code> 函数的签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_destroy(pthread_mutex_t* mutex);</span><br></pre></td></tr></table></figure><p>参数 <code>mutex</code> 即我们需要销毁的互斥体对象，如果函数执行成功会返回 0，如果执行失败会返回一个错误码表面出错原因。这里我们需要注意两点：</p></li><li><p><strong>使用 <code>PTHREAD_MUTEX_INITIALIZER</code> 初始化的互斥量无须销毁</strong>；</p></li><li><p><strong>不要去销毁一个已经加锁或正在被条件变量使用的互斥体对象</strong>，当互斥量处于已加锁的状态或者正在和条件变量配合使用时，调用 <code>pthread_mutex_destroy</code> 函数会返回 <code>EBUSY</code> 错误。<br>以下代码段演示了尝试销毁一个被锁定的 <code>mutex</code> 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//test_destroy_locked_mutex.cpp</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_t mymutex;</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, NULL);</span><br><span class="line">    int ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">    //尝试对被锁定的mutex对象进行销毁</span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">    {</span><br><span class="line">        if (ret == EBUSY)</span><br><span class="line">            printf("EBUSY\n");</span><br><span class="line">        printf("Failed to destroy mutex.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ret = pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line">    //尝试对已经解锁的mutex对象进行销毁</span><br><span class="line">    ret = pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    if (ret == 0)</span><br><span class="line">        printf("Succeeded to destroy mutex.\n");</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译上述代码并执行得到我们期望的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@myaliyun codes]# g++ -g -o test_destroy_locked_mutex test_destroy_locked_mutex.cpp -lpthread</span><br><span class="line">[root@myaliyun codes]# ./test_destroy_locked_mutex </span><br><span class="line">EBUSY</span><br><span class="line">Failed to destroy mutex.</span><br><span class="line">Succeed to destroy mutex.</span><br></pre></td></tr></table></figure><p>在实际开发中，如果我们遵循正确的使用 <code>mutex</code> 的规范，如创建 <code>mutex</code> 对象后再对其加锁，加锁后才对其进行解锁操作，解锁后才做销毁操作，那么编码时一般不用考虑 <code>pthread_mutex_init</code>/<code>pthread_mutex_destroy</code>/<code>pthread_mutex_lock</code>/<code>pthread_mutex_unlock</code> 等函数的返回值。</p></li></ul><p>对于互斥体的加锁和解锁操作我们一般使用以下三个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutex_lock(pthread_mutex_t* mutex);</span><br><span class="line">int pthread_mutex_trylock(pthread_mutex_t* mutex);</span><br><span class="line">int pthread_mutex_unlock(pthread_mutex_t* mutex);</span><br></pre></td></tr></table></figure><p>参数 <code>mutex</code> 设置为我们需要加锁和解锁的互斥体对象，上述函数执行成功则返回 0；如果执行失败则返回一个错误码表示具体的出错原因。具体错误码，随互斥体对象的属性类型的不同而不同。</p><p>设置互斥体对象的属性需要创建一个 <code>pthread_mutexattr_t</code> 类型的对象，和互斥体对象一样，需要使用 <code>pthread_mutexattr_init</code> 函数初始化之，当不需要这个属性对象时，记得使用 <code>pthread_mutexattr_destroy</code> 去销毁它，这两个函数的签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutexattr_init(pthread_mutexattr_t* attr);</span><br><span class="line">int pthread_mutexattr_destroy(pthread_mutexattr_t* attr);</span><br></pre></td></tr></table></figure><p>使用 <code>pthread_mutexattr_settype</code>/<code>pthread_mutexattr_gettype</code> 设置或获取想要的属性类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int pthread_mutexattr_settype(pthread_mutexattr_t* attr, int type);</span><br><span class="line">int pthread_mutexattr_gettype(const pthread_mutexattr_t* restrict attr, int* restrict type);</span><br></pre></td></tr></table></figure><h2 id="mutex-锁的类型"><a href="#mutex-锁的类型" class="headerlink" title="mutex 锁的类型"></a>mutex 锁的类型</h2><p>属性类型一般有如下取值：</p><p><strong>PTHREAD_MUTEX_NORMAL</strong>（普通锁）<br>这是互斥体对象的默认属性（即上文中介绍的 <code>pthread_mutex_init</code> 第二个函数设置为 <code>NULL</code>）。当一个线程对一个普通锁加锁以后，其他线程会阻塞在 <code>pthread_mutex_lock</code> 调用处， 直到对互斥体加锁的线程释放了锁，我们来用一段实例代码来验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mymutex;</span><br><span class="line">int             resourceNo = 0;</span><br><span class="line"></span><br><span class="line">void* worker_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    pthread_t threadID = pthread_self();</span><br><span class="line"></span><br><span class="line">    printf("thread start, ThreadID: %d\n", threadID);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        pthread_mutex_lock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        printf("Mutex lock, resourceNo: %d, ThreadID: %d\n", resourceNo, threadID);</span><br><span class="line">        resourceNo++;</span><br><span class="line"></span><br><span class="line">        printf("Mutex unlock, resourceNo: %d, ThreadID: %d\n", resourceNo, threadID);</span><br><span class="line"></span><br><span class="line">        pthread_mutex_unlock(&amp;mymutex);</span><br><span class="line"></span><br><span class="line">        //休眠1秒</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutexattr_t mutex_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    //创建5个工作线程</span><br><span class="line">    pthread_t threadID[5];</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;threadID[i], NULL, worker_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(threadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码创建了 5 个工作线程，由于使用了互斥体保护资源 <code>resourceNo</code>，因而每次在 <code>pthread_mutex_lock</code> 与 <code>pthread_mutex_unlock</code> 之间的输出都是连续的，一个线程必须完成了这个工作，其他线程才有机会获得执行这段代码的机会，当一个线程拿到锁后，其他线程会阻塞在 <code>pthread_mutex_lock</code> 处。</p><p>程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# ./test</span><br><span class="line">thread start, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 0, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 1, ThreadID: 520349440</span><br><span class="line">thread start, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 1, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 2, ThreadID: 545527552</span><br><span class="line">thread start, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 2, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 3, ThreadID: 511956736</span><br><span class="line">thread start, ThreadID: 537134848</span><br><span class="line">Mutex lock, resourceNo: 3, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 4, ThreadID: 537134848</span><br><span class="line">thread start, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 4, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 5, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 5, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 6, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 6, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 7, ThreadID: 537134848</span><br><span class="line">Mutex lock, resourceNo: 7, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 8, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 8, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 9, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 9, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 10, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 10, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 11, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 11, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 12, ThreadID: 537134848</span><br><span class="line">Mutex lock, resourceNo: 12, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 13, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 13, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 14, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 14, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 15, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 15, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 16, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 16, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 17, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 17, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 18, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 18, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 19, ThreadID: 537134848</span><br><span class="line">Mutex lock, resourceNo: 19, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 20, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 20, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 21, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 21, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 22, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 22, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 23, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 23, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 24, ThreadID: 537134848</span><br><span class="line">Mutex lock, resourceNo: 24, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 25, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 25, ThreadID: 528742144</span><br><span class="line">Mutex unlock, resourceNo: 26, ThreadID: 528742144</span><br><span class="line">Mutex lock, resourceNo: 26, ThreadID: 545527552</span><br><span class="line">Mutex unlock, resourceNo: 27, ThreadID: 545527552</span><br><span class="line">Mutex lock, resourceNo: 27, ThreadID: 520349440</span><br><span class="line">Mutex unlock, resourceNo: 28, ThreadID: 520349440</span><br><span class="line">Mutex lock, resourceNo: 28, ThreadID: 511956736</span><br><span class="line">Mutex unlock, resourceNo: 29, ThreadID: 511956736</span><br><span class="line">Mutex lock, resourceNo: 29, ThreadID: 537134848</span><br><span class="line">Mutex unlock, resourceNo: 30, ThreadID: 537134848</span><br></pre></td></tr></table></figure><p>一个线程如果对一个已经加锁的普通锁再次使用 <code>pthread_mutex_lock</code> 加锁，程序会阻塞在第二次调用 <code>pthread_mutex_lock</code> 代码处。测试代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_t mymutex;</span><br><span class="line">    pthread_mutexattr_t mutex_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_NORMAL);</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    int ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    printf("ret = %d\n", ret);</span><br><span class="line"></span><br><span class="line">    ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    printf("ret = %d\n", ret);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译并使用 <code>gdb</code> 将程序运行起来，程序只输出了一行，我们按 <code>Ctrl + C</code> （下文中 ^C 字符）将 <code>gdb</code> 中断下来，然后使用 <code>bt</code> 命令发现程序确实阻塞在第二个 <code>pthread_mutex_lock</code> 函数调用处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o test test.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# gdb test</span><br><span class="line">Reading symbols from /root/testmultithread/test...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/testmultithread/test </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">ret = 0</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x00007ffff7bc8dcb in _L_lock_883 () from /lib64/libpthread.so.0</span><br><span class="line">#2  0x00007ffff7bc8c98 in pthread_mutex_lock () from /lib64/libpthread.so.0</span><br><span class="line">#3  0x00000000004007f4 in main () at ConsoleApplication10.cpp:17</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure><p>在这种类型的情况， <code>pthread_mutex_trylock</code> 函数如果拿不到锁，不会阻塞，函数会立即返回，并返回 <code>EBUSY</code> 错误码。</p><p><strong>PTHREAD_MUTEX_ERRORCHECK</strong>（检错锁）<br>如果一个线程使用 <code>pthread_mutex_lock</code> 对已经加锁的互斥体对象再次加锁，<code>pthread_mutex_lock</code> 会返回 <code>EDEADLK</code>。</p><p>我们验证一下线程对自己已经加锁的互斥体对象再次加锁是什么行为？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutex_t mymutex;</span><br><span class="line">    pthread_mutexattr_t mutex_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    int ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    printf("ret = %d\n", ret);</span><br><span class="line"></span><br><span class="line">    ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    printf("ret = %d\n", ret);</span><br><span class="line">    if (ret == EDEADLK)</span><br><span class="line">    {</span><br><span class="line">        printf("EDEADLK\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译并运行程序，程序输出结果确实如上面所说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o test11 test.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./test11</span><br><span class="line">ret = 0</span><br><span class="line">ret = 35</span><br><span class="line">EDEADLK</span><br></pre></td></tr></table></figure><p>再来看一下，一个线程加锁，其他线程再次加锁的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_mutex_t mymutex;</span><br><span class="line"></span><br><span class="line">void* worker_thread(void* param)</span><br><span class="line">{</span><br><span class="line">    pthread_t threadID = pthread_self();</span><br><span class="line"></span><br><span class="line">    printf("thread start, ThreadID: %d\n", threadID);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        int ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">        if (ret == EDEADLK)</span><br><span class="line">        {</span><br><span class="line">            printf("EDEADLK, ThreadID: %d\n", threadID);</span><br><span class="line">        } </span><br><span class="line">        else</span><br><span class="line">            printf("ret = %d, ThreadID: %d\n", ret, threadID);</span><br><span class="line"></span><br><span class="line">        //休眠1秒</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_mutexattr_t mutex_attr;</span><br><span class="line">    pthread_mutexattr_init(&amp;mutex_attr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;mutex_attr, PTHREAD_MUTEX_ERRORCHECK);</span><br><span class="line">    pthread_mutex_init(&amp;mymutex, &amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    int ret = pthread_mutex_lock(&amp;mymutex);</span><br><span class="line">    printf("ret = %d\n", ret);</span><br><span class="line"></span><br><span class="line">    //创建5个工作线程</span><br><span class="line">    pthread_t threadID[5];</span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_create(&amp;threadID[i], NULL, worker_thread, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        pthread_join(threadID[i], NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pthread_mutex_destroy(&amp;mymutex);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;mutex_attr);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>编译程序，然后使用 <code>gdb</code> 运行起来，发现程序并没有有任何输出，按 <code>Ctrl + C</code> 中断下来，输入 <code>info thread</code> 命令发现工作线程均阻塞在 <code>pthread_mutex_lock</code> 函数调用处。操作及输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testmultithread]# g++ -g -o test8 ConsoleApplication8.cpp -lpthread</span><br><span class="line">[root@localhost testmultithread]# ./test8</span><br><span class="line">ret = 0</span><br><span class="line">thread start, ThreadID: -1821989120</span><br><span class="line">thread start, ThreadID: -1830381824</span><br><span class="line">thread start, ThreadID: -1838774528</span><br><span class="line">thread start, ThreadID: -1847167232</span><br><span class="line">thread start, ThreadID: -1813596416</span><br><span class="line">^C</span><br><span class="line">[root@localhost testmultithread]# gdb test8</span><br><span class="line">GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-114.el7</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type "show copying"</span><br><span class="line">and "show warranty" for details.</span><br><span class="line">This GDB was configured as "x86_64-redhat-linux-gnu".</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;...</span><br><span class="line">Reading symbols from /root/testmultithread/test8...done.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/testmultithread/test8 </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">ret = 0</span><br><span class="line">[New Thread 0x7ffff6fd2700 (LWP 3276)]</span><br><span class="line">thread start, ThreadID: -151181568</span><br><span class="line">[New Thread 0x7ffff67d1700 (LWP 3277)]</span><br><span class="line">thread start, ThreadID: -159574272</span><br><span class="line">[New Thread 0x7ffff5fd0700 (LWP 3278)]</span><br><span class="line">thread start, ThreadID: -167966976</span><br><span class="line">[New Thread 0x7ffff57cf700 (LWP 3279)]</span><br><span class="line">thread start, ThreadID: -176359680</span><br><span class="line">[New Thread 0x7ffff4fce700 (LWP 3280)]</span><br><span class="line">thread start, ThreadID: -184752384</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x00000000004009e9 in main () at ConsoleApplication8.cpp:50</span><br><span class="line">(gdb) inf threads</span><br><span class="line">  Id   Target Id         Frame </span><br><span class="line">  6    Thread 0x7ffff4fce700 (LWP 3280) "test8" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">  5    Thread 0x7ffff57cf700 (LWP 3279) "test8" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">  4    Thread 0x7ffff5fd0700 (LWP 3278) "test8" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">  3    Thread 0x7ffff67d1700 (LWP 3277) "test8" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">  2    Thread 0x7ffff6fd2700 (LWP 3276) "test8" 0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span><br><span class="line">* 1    Thread 0x7ffff7fee740 (LWP 3272) "test8" 0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过上面的实验，如果互斥体的属性是 <code>PTHREAD_MUTEX_ERRORCHECK</code>，当前线程重复调用 <code>pthread_mutex_lock</code> 会直接返回 <code>EDEADLOCK</code>，其他线程如果对这个互斥体再次调用 <code>pthread_mutex_lock</code> 会阻塞在该函数的调用处。</p><p><strong>PTHREAD_MUTEX_RECURSIVE</strong>（嵌套锁）<br>该属性允许同一个线程对其持有的互斥体重复加锁，每次成功调用 <code>pthread_mutex_lock</code> 一次，该互斥体对象的锁引用计数就会增加一次，相反，每次成功调用 <code>pthread_mutex_unlock</code> 一次，锁引用计数就会减少一次，当锁引用计数值为 0 时允许其他线程获得该锁，否则其他线程调用 <code>pthread_mutex_lock</code> 时尝试获取锁时，会阻塞在那里。这种方式很好理解，这里就不贴示例代码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们来总结下 Linux 互斥体对象的使用要点：</p><ul><li>虽然在上文演示了同一个线程对一个互斥体对象反复进行加锁，但在实际开发中，我们需要用到这种场景的情形非常少；</li><li>与 Windows 的临界区对象一样，一些有很多出口的逻辑中，为了避免因忘记调用 <code>pthread_mutex_unlock</code> 出现死锁或者在逻辑出口处有大量解锁的重复代码出现，建议使用 RAII 技术将互斥体对象封装起来，具体方式在上文中已经介绍过了，这里不再赘述。</li></ul><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何让程序只能启动一个实例</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-9/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-9/</id>
    <published>2021-10-18T05:35:45.000Z</published>
    <updated>2022-05-01T13:40:22.720Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-OljzMWPe" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1342827169" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="如何让程序只能启动一个实例"><a href="#如何让程序只能启动一个实例" class="headerlink" title="如何让程序只能启动一个实例"></a>如何让程序只能启动一个实例</h1><p>前面介绍的 Windows <code>Event</code>、<code>Mutex</code>、<code>Semaphore</code> 对象其创建函数 <code>CreateX</code> 都可以给这些对象指定一个名字，有了名字之后这些线程资源同步对象就可以通过这个名字在不同进程之间共享。</p><p>在 Windows 系统上读者应该有这样的体验：有些程序无论双击其启动图标都只会启动一个，我们把这类程序叫做单实例程序（<code>Single Instance</code>）。可以利用命名的线程资源同步对象来实现这个效果，这里以互斥体为例。</p><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int APIENTRY _tWinMain(_In_ HINSTANCE hInstance,</span><br><span class="line">                     _In_opt_ HINSTANCE hPrevInstance,</span><br><span class="line">                     _In_ LPTSTR    lpCmdLine,</span><br><span class="line">                     _In_ int       nCmdShow)</span><br><span class="line">{</span><br><span class="line">    //...省略无关代码...</span><br><span class="line"></span><br><span class="line">    if (CheckInstance())</span><br><span class="line">    {</span><br><span class="line">        HWND hwndPre = FindWindow(szWindowClass, NULL);</span><br><span class="line">        if (IsWindow(hwndPre))</span><br><span class="line">        {</span><br><span class="line">            if (::IsIconic(hwndPre))</span><br><span class="line">                ::SendMessage(hwndPre, WM_SYSCOMMAND, SC_RESTORE | HTCAPTION, 0);</span><br><span class="line"></span><br><span class="line">            ::SetWindowPos(hwndPre, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW | SWP_NOACTIVATE);</span><br><span class="line">            ::SetForegroundWindow(hwndPre);</span><br><span class="line">            ::SetFocus(hwndPre);</span><br><span class="line">            return 0;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //...省略无关代码</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码在 <code>WinMain</code> 函数开始处先检查是否已经运行起来的程序实例，如果存在，则找到运行中的实例程序主窗口并激活之，这就是读者看到最小化很多单例程序后双击该程序图标会重新激活最小化的程序的效果实现原理。</p><p>现在重点是 <code>CheckInstance()</code> 函数的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bool CheckInstance()</span><br><span class="line">{</span><br><span class="line">    HANDLE hSingleInstanceMutex = CreateMutex(NULL, FALSE, _T("MySingleInstanceApp"));</span><br><span class="line">    if (hSingleInstanceMutex != NULL)</span><br><span class="line">    {</span><br><span class="line">        if (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">        {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return false;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>我们来分析一下上述 <code>CheckInstance</code> 函数：</p><p>假设首次启动这个进程，这个进程会调用 <code>CreateMutex</code> 函数创建一个名称为“<code>MySingleInstanceApp</code>”的互斥体对象。当再次准备启动一份这个进程时，再次调用 <code>CreateMutex</code> 函数，由于该名称的互斥体对象已经存在，将会返回已经存在的互斥体对象地址，此时通过 <code>GetLastError()</code> 函数得到的错误码是 <code>ERROR_ALREADY_EXISTS</code> 表示该名称的互斥体对象已经存在，此时我们激活已经存在的前一个实例，然后退出当前进程即可。</p><p>完整的代码下载地址请<a class="link" href="https://github.com/baloonwj/mybooksources">单击这里<i class="fas fa-external-link-alt"></i></a>。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Windows 上有太多的应用场景只允许程序启动一个示例，而其原理就是本节所介绍的，希望读者可以理解并掌握该方法。如何保证程序只会启动一个实例是 Windows 开发最常用的应用场景之一，建议读者自己练习一下，尽量掌握。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 线程同步之 Semaphore</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-8/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-8/</id>
    <published>2021-10-18T05:31:09.000Z</published>
    <updated>2022-05-01T13:40:22.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-LmmdsnOR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1423219826" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Windows-线程同步之-Semaphore"><a href="#Windows-线程同步之-Semaphore" class="headerlink" title="Windows 线程同步之 Semaphore"></a>Windows 线程同步之 Semaphore</h1><p><code>Semaphore</code> 也是 Windows 多线程同步常用的对象之一，与上面介绍的 <code>Event</code>、<code>Mutex</code> 不同，信号量存在一个资源计数的概念，<code>Event</code> 对象虽然可以同时唤醒多个线程，但是它不能精确地控制同时唤醒指定数目的线程，而 <code>Semaphore</code> 可以。创建 <code>Semaphore</code> 对象的 API 函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateSemaphore(</span><br><span class="line">      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span><br><span class="line">      LONG                  lInitialCount,</span><br><span class="line">      LONG                  lMaximumCount,</span><br><span class="line">      LPCTSTR               lpName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数和返回值介绍：</p><ul><li>参数 <code>lpSemaphoreAttributes</code> 指定了 <code>Semaphore</code> 对象的安全属性，一般设置为 <code>NULL</code> 使用默认安全属性；</li><li>参数 <code>lInitialCount</code> 指定初始可用资源数量，假设初始资源数量为 2，如果有 5 个线程正在调用 <code>WaitForSingleObject</code> 函数等待该信号量，则有 2 个线程会被唤醒，每调用一次 <code>WaitForSingleObject</code> 获得 <code>Semaphore</code> 对象，该对象的资源计数会减少一个。</li><li>参数 <code>lMaximumCount</code> 最大资源数量上限，如果使用 <code>ReleaseSemaphore</code> 不断增加资源计数，资源数量最大不能超过这个值，这个值必须设置大于 0。</li><li>参数 lpName 指定 <code>Semaphore</code> 对象的名称，<code>Semaphore</code> 对象也是可以通过名称跨进程共享的，如果不需要设置名称可以将该参数设置为 <code>NULL</code>，设置了名称的 <code>Semaphore</code> 对象被称为具名信号量，反之叫匿名信号量。</li><li>返回值：函数调用成功返回 <code>Semaphore</code> 对象的句柄，反之返回 <code>NULL</code>。<br>如果需要增加信号量的资源计数个数，可以使用 <code>ReleaseSemaphore</code> 函数，其签名如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseSemaphore(</span><br><span class="line">      HANDLE hSemaphore,</span><br><span class="line">      LONG   lReleaseCount,</span><br><span class="line">      LPLONG lpPreviousCount</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>参数 <code>hSemaphore</code> 是需要操作的信号量句柄；</li><li>参数 <code>lReleaseCount</code>，需要增加的资源数量；</li><li>参数 <code>lpPreviousCount</code> 是一个 <code>long</code> 型（32 位系统上 4 个字节）的指针，函数执行成功后，返回是上一次资源的数量，如果用不到该参数，可以设置为 <code>NULL</code>。</li></ul><p>信号量的使用方式类似，根据当前资源的数量按需分配资源消费者，资源消费者会让资源数量减少，如果资源数量减少为 0，消费者将全部处于挂起状态；当有新的资源来到时，消费者将继续被唤醒进行处理。</p><p>假设现在有一个即时通讯的程序，网络线程不断从网络上收到一条条聊天消息，其他 4 个消息处理线程需要对收到的聊天信息进行加工。由于我们需要根据当前消息的数量来唤醒其中 4 个工作线程中的一个或多个，这正是信号量使用的典型案例，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">HANDLE                  g_hMsgSemaphore = NULL;</span><br><span class="line">std::list&lt;std::string&gt;  g_listChatMsg;</span><br><span class="line">//保护 g_listChatMsg 的临界区对象</span><br><span class="line">CRITICAL_SECTION        g_csMsg;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall NetThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    int nMsgIndex = 0;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        EnterCriticalSection(&amp;g_csMsg);</span><br><span class="line">        //随机产生1～4条消息</span><br><span class="line">        int count = rand() % 4 + 1;</span><br><span class="line">        for (int i = 0; i &lt; count; ++i)</span><br><span class="line">        {</span><br><span class="line">            nMsgIndex++;</span><br><span class="line">            SYSTEMTIME st;</span><br><span class="line">            GetLocalTime(&amp;st);</span><br><span class="line">            char szChatMsg[64] = { 0 };</span><br><span class="line">            sprintf_s(szChatMsg, 64, "[%04d-%02d-%02d %02d:%02d:%02d:%03d] A new msg, NO.%d.",</span><br><span class="line">                st.wYear,</span><br><span class="line">                st.wMonth,</span><br><span class="line">                st.wDay,</span><br><span class="line">                st.wHour,</span><br><span class="line">                st.wMinute,</span><br><span class="line">                st.wSecond,</span><br><span class="line">                st.wMilliseconds,</span><br><span class="line">                nMsgIndex);</span><br><span class="line">            g_listChatMsg.emplace_back(szChatMsg);</span><br><span class="line">        }   </span><br><span class="line">        LeaveCriticalSection(&amp;g_csMsg);</span><br><span class="line"></span><br><span class="line">        //增加 count 个资源数量</span><br><span class="line">        ReleaseSemaphore(g_hMsgSemaphore, count, NULL);</span><br><span class="line">    }// end while-loop</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DWORD __stdcall ParseThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    DWORD dwThreadID = GetCurrentThreadId();</span><br><span class="line">    std::string current;</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        if (WaitForSingleObject(g_hMsgSemaphore, INFINITE) == WAIT_OBJECT_0)</span><br><span class="line">        {</span><br><span class="line">            EnterCriticalSection(&amp;g_csMsg);</span><br><span class="line">            if (!g_listChatMsg.empty())</span><br><span class="line">            {</span><br><span class="line">                current = g_listChatMsg.front();</span><br><span class="line">                g_listChatMsg.pop_front();</span><br><span class="line">                std::cout &lt;&lt; "Thread: " &lt;&lt; dwThreadID &lt;&lt; " parse msg: " &lt;&lt; current &lt;&lt; std::endl;</span><br><span class="line">            }         </span><br><span class="line">            LeaveCriticalSection(&amp;g_csMsg);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //初始化随机数种子</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    InitializeCriticalSection(&amp;g_csMsg);</span><br><span class="line"></span><br><span class="line">    //创建一个匿名的 Semaphore 对象，初始资源数量为 0</span><br><span class="line">    g_hMsgSemaphore = CreateSemaphore(NULL, 0, INT_MAX, NULL);</span><br><span class="line"></span><br><span class="line">    HANDLE hNetThread = CreateThread(NULL, 0, NetThreadProc, NULL, 0, NULL);</span><br><span class="line"></span><br><span class="line">    HANDLE hWorkerThreads[4];</span><br><span class="line">    for (int i = 0; i &lt; 4; ++i)</span><br><span class="line">    {</span><br><span class="line">        hWorkerThreads[i] = CreateThread(NULL, 0, ParseThreadProc, NULL, 0, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; ++i)</span><br><span class="line">    {</span><br><span class="line">        //等待工作线程退出</span><br><span class="line">        WaitForSingleObject(hWorkerThreads[i], INFINITE);</span><br><span class="line">        CloseHandle(hWorkerThreads[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hNetThread, INFINITE);</span><br><span class="line">    CloseHandle(hNetThread);</span><br><span class="line"></span><br><span class="line">    CloseHandle(g_hMsgSemaphore);</span><br><span class="line"></span><br><span class="line">    DeleteCriticalSection(&amp;g_csMsg);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上述代码中，网络线程每次随机产生 1 ～ 4 个聊天消息放入消息容器 <code>g_listChatMsg</code> 中，然后根据当前新产生的消息数目调用 <code>ReleaseSemaphore</code> 增加相应的资源计数，这样就有相应的处理线程被唤醒，从容器 <code>g_listChatMsg</code> 中取出消息进行处理。</p><blockquote><p>注意：由于会涉及到多个线程操作消息容器 <code>g_listChatMsg</code>，这里使用了一个临界区对象 <code>g_csMsg</code> 对其进行保护。</p></blockquote><p>程序执行效果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//这里截取输出中间部分...输出太多，部分结果省略</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.26.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.27.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.28.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.29.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.30.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.31.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.32.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.33.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.34.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.35.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.36.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.37.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.38.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.39.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.40.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.41.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.42.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:568] A new msg, NO.43.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.44.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.45.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.46.</span><br><span class="line">Thread: 3704 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.47.</span><br><span class="line">Thread: 5512 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.48.</span><br><span class="line">Thread: 6676 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.49.</span><br><span class="line">Thread: 6676 parse msg: [2019-01-20 16:31:47:569] A new msg, NO.50.</span><br></pre></td></tr></table></figure><p>总结起来，Semaphore 与上面介绍的 Event、Mutex 不一样，由于存在资源计数的概念，可以精准地控制同时唤醒几个等待的线程。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 线程同步之 Mutex</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-7/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-7/</id>
    <published>2021-10-18T05:25:45.000Z</published>
    <updated>2022-05-01T13:40:22.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-cFVdpxIm" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1458717405" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Windows-线程同步之-Mutex"><a href="#Windows-线程同步之-Mutex" class="headerlink" title="Windows 线程同步之 Mutex"></a>Windows 线程同步之 Mutex</h1><p><code>Mutex</code>（ 互斥量）采用的是英文 <code>Mutual Exclusive</code>（互相排斥之意）的缩写。见名知义，Windows 中的 <code>Mutex</code> 对象在同一个时刻最多只能属于一个线程，当然也可以不属于任何线程，获得 <code>Mutex</code> 对象的线程成为该 <code>Mutex</code> 的拥有者（<code>owner</code>）。我们可以在创建 <code>Mutex</code> 对象时设置 <code>Mutex</code> 是否属于创建它的线程，其他线程如果希望获得该 <code>Mutex</code>，则可以调用 <code>WaitForSingleObject</code> 进行申请。创建 <code>Mutex</code> 的 API 是 <code>CreateMutex</code>，其函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateMutex(</span><br><span class="line">      LPSECURITY_ATTRIBUTES lpMutexAttributes,</span><br><span class="line">      BOOL                  bInitialOwner,</span><br><span class="line">      LPCTSTR               lpName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数和返回值说明：</p><ul><li>参数 <code>lpMutexAttributes</code> 用法同 <code>CreateEvent</code>，上面已经介绍过了，一般设置为 <code>NULL</code>；</li><li>参数 <code>bInitialOwner</code>，设置调用 <code>CreateMutex</code> 的线程是否立即拥有该 <code>Mutex</code> 对象，<code>TRUE</code> 拥有，<code>FALSE</code> 不拥有，不拥有时，其他线程调用 <code>WaitForSingleObject</code> 可以获得该 <code>Mutex</code> 对象；</li><li>参数 <code>lpName</code>，<code>Mutex</code> 对象的名称，<code>Mutex</code> 对象和 <code>Event</code> 对象一样，也可以通过名称在多个线程之间共享，如果不需要名称则可以将该参数设置为 <code>NULL</code>，根据是否具有名称 <code>Mutex</code> 对象分为<code>具名 Mutex</code> 和<code>匿名 Mutex</code>；</li><li>返回值，如果函数调用成功返回 Mutex 的句柄，调用失败返回<code> NULL</code>。</li></ul><p>当一个线程不再需要该 <code>Mutex</code>，可以使用 <code>ReleaseMutex</code> 函数释放 <code>Mutex</code>，让其他需要等待该 <code>Mutex</code> 的线程有机会获得该 <code>Mutex，ReleaseMutex</code> 的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL ReleaseMutex(HANDLE hMutex);</span><br></pre></td></tr></table></figure><p>参数 <code>hMutex</code> 即需要释放所有权的 <code>Mutex</code> 对象句柄。</p><p>我们来看一段具体的实例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">HANDLE      g_hMutex = NULL;</span><br><span class="line">int         g_iResource = 0;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    DWORD dwThreadID = GetCurrentThreadId();</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        if (WaitForSingleObject(g_hMutex, 1000) == WAIT_OBJECT_0)</span><br><span class="line">        {</span><br><span class="line">            g_iResource++;</span><br><span class="line">            std::cout &lt;&lt; "Thread: " &lt;&lt; dwThreadID &lt;&lt; " becomes mutex owner, ResourceNo: " &lt;&lt; g_iResource  &lt;&lt; std::endl;</span><br><span class="line">            ReleaseMutex(g_hMutex);</span><br><span class="line">        }</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //创建一个匿名的 Mutex 对象，默认情况下主线程不拥有该 Mutex</span><br><span class="line">    g_hMutex = CreateMutex(NULL, FALSE, NULL);</span><br><span class="line"></span><br><span class="line">    HANDLE hWorkerThreads[5]; </span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        hWorkerThreads[i] = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 5; ++i)</span><br><span class="line">    {</span><br><span class="line">        //等待工作线程退出</span><br><span class="line">        WaitForSingleObject(hWorkerThreads[i], INFINITE);</span><br><span class="line">        CloseHandle(hWorkerThreads[i]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    CloseHandle(g_hMutex);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上述代码中，主线程创建一个 <code>Mutex</code>，并且设置不拥有它，然后五个工作线程去竞争获得这个 <code>Mutex</code> 的使用权，拿到这个 <code>Mutex</code> 之后就可以操作共享资源 <code>g_iResource</code> 了，程序的执行效果是五个工作线程随机获得该资源的使用权：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded12.1k981ygzp0ps.jpg" alt="multithreaded12"></p><p>互斥体对象的排他性，有点类似于公共汽车上的座位，如果一个座位已经被别人占用，其他人需要等待，如果该座位没人坐，则其他人“先到先得”。当你不需要使用的时候，要把座位腾出来让其他有需要的人使用。假设某个线程在退出后，仍然没有释放其持有的 <code>Mutex</code> 对象，这时候使用 <code>WaitForSingleObject</code> 等待该 <code>Mutex</code> 对象的线程，也会立即返回，返回值是 <code>WAIT_ABANDONED</code>，表示该 <code>Mutex</code> 处于废弃状态（<code>abandoned</code>），处于废弃状态的 <code>Mutex</code> 不能再使用，其行为是未定义的。</p><p>通过上面的分析，我们知道 Windows <code>Mutex</code> 对象存在一个 <code>owner</code> 的概念，即哪个线程获取了该 <code>Mutex</code> 即成为该线程的 <code>owner</code>，事实上 <code>Mutex</code> 对象有一个内部属性记录了 <code>owner</code>，只不过微软没有公开而已。如果对 <code>Mutex</code> 内部实现原理感兴趣，可以阅读“开源版的 Windows” 的源码——<code>ReactOS</code>，其主页如下：<a class="link" href="https://reactos.org/%E3%80%82">https://reactos.org/。<i class="fas fa-external-link-alt"></i></a></p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 线程资源同步之 Event</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-6/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-6/</id>
    <published>2021-10-18T05:15:07.000Z</published>
    <updated>2022-05-01T13:40:22.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-hxKNjBLM" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="440403855" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Windows-线程资源同步之-Event"><a href="#Windows-线程资源同步之-Event" class="headerlink" title="Windows 线程资源同步之 Event"></a>Windows 线程资源同步之 Event</h1><p>前面一讲我们介绍了 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 函数，它们是 Windows 多线程编程基础 API，所有资源同步对象都得和它们打交道；然后介绍了可以临界区对象，并且介绍了一个把临界区当自旋锁的扩展用法。本讲我们来介绍 Windows 最常用的多线程同步对象 —— <code>Event</code>。</p><h2 id="Event-使用方法"><a href="#Event-使用方法" class="headerlink" title="Event 使用方法"></a>Event 使用方法</h2><p>本节讨论的 <code>Event</code> 对象不是 Windows UI 事件驱动机制中的事件，而是多线程资源同步中的 <code>Event</code> 对象，它也是 Windows 内核对象之一。在 Windows 多线程程序设计中，使用频率较高，我们先来学习一下如何创建 <code>Event</code> 对象，然后逐步展开。创建 <code>Event</code> 的 Windows API 函数签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateEvent(</span><br><span class="line">  LPSECURITY_ATTRIBUTES lpEventAttributes,</span><br><span class="line">  BOOL                  bManualReset,</span><br><span class="line">  BOOL                  bInitialState,</span><br><span class="line">  LPCTSTR               lpName</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数和返回值的说明如下。</p><ul><li>参数 <code>lpEventAttributes</code>，这个参数设置了 <code>Event</code> 对象的安全属性，Windows 中所有的内核对象都可以设置这个属性，我们一般设置为 <code>NULL</code>，即使用默认安全属性。</li><li>参数 <code>bManualReset</code>，这个参数设置 <code>Event</code> 对象受信（变成有信号状态）时的行为，当设置为 <code>TRUE</code> 时，表示需要手动调用 <code>ResetEvent</code> 函数去将 <code>Event</code> 重置成无信号状态；当设置为 <code>FALSE</code>，<code>Event</code> 事件对象受信后会自动重置为无信号状态。</li><li>参数 <code>bInitialState</code> 设置 <code>Event</code> 事件对象初始状态是否是受信的，<code>TRUE</code> 表示有信号，<code>FALSE</code> 表示无信号。</li><li>参数 <code>lpName</code> 可以设置 <code>Event</code> 对象的名称，如果不需要设置名称，可以将该参数设置为 <code>NULL</code>。一个 <code>Event</code> 对象根据是否设置了名称分为具名对象（具有名称的对象）和匿名对象。<code>Event</code> 对象是可以通过名称在不同进程之间共享的，通过这种方式共享很有用，后面我们会详细介绍。</li><li>返回值，如果成功创建 <code>Event</code> 对象返回对象的句柄，如果创建失败返回 <code>NULL</code>。</li></ul><p>一个无信号的 <code>Event</code> 对象，我们可以通过 <code>SetEvent</code> 将其变成受信状态，<code>SetEvent</code> 的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetEvent(HANDLE hEvent);</span><br></pre></td></tr></table></figure><p>我们将参数 <code>hEvent</code> 设置为需要设置信号的 <code>Event</code> 句柄即可。</p><p>同理，一个已经受信的 <code>Event</code> 对象，可以使用 <code>ResetEvent</code> 对象将其变成无信号状态，<code>ResetEvent</code> 的函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL ResetEvent(HANDLE hEvent);</span><br></pre></td></tr></table></figure><p>参数 <code>hEvent</code> 即我们需要重置的 Event 对象句柄。</p><p>说了这么多，来看一个具体的例子。假设现在有两个线程，其中一个是主线程，主线程等待工作线程执行某一项耗时的任务完成后，将任务结果显示出来。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">bool        g_bTaskCompleted = false;</span><br><span class="line">std::string g_TaskResult;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    //使用 Sleep 函数模拟一个很耗时的操作</span><br><span class="line">    //睡眠3秒</span><br><span class="line">    Sleep(3000);</span><br><span class="line">    g_TaskResult = "task completed";</span><br><span class="line">    g_bTaskCompleted = true;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL); </span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        if (g_bTaskCompleted)</span><br><span class="line">        {</span><br><span class="line">            std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;</span><br><span class="line">            break;</span><br><span class="line">        }        </span><br><span class="line">        else</span><br><span class="line">            std::cout &lt;&lt; "Task is in progress..." &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    CloseHandle(hWorkerThread);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码在主线程（<code>main</code> 函数）创建一个工作线程，然后主线程进入一个无限循环等待布尔变量 <code>gbTaskCompleted</code> 变成真值；工作线程（<code>WorkerThreadProc</code> 为线程函数）休眠 3 秒后将变量 <code>gbTaskCompleted</code> 设置为真后主线程得以退出循环，并打印代表条件满足后的结果。</p><p>程序执行结果如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded11.2ls5e8ckeoe0.jpg" alt="multithreaded11"></p><p>在上述代码中，主线程为了等待工作线程完成任务后获取结果，使用了一个循环去不断查询任务完成标识，这是很低效的一种做法，等待的线程（主线程）做了很多无用功，对 CPU 时间片也是一种浪费。我们使用 <code>Event</code> 对象来改写一下上述代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">bool        g_bTaskCompleted = false;</span><br><span class="line">std::string g_TaskResult;</span><br><span class="line">HANDLE      g_hTaskEvent = NULL;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    //使用 Sleep 函数模拟一个很耗时的操作</span><br><span class="line">    //睡眠3秒</span><br><span class="line">    Sleep(3000);</span><br><span class="line">    g_TaskResult = "task completed";</span><br><span class="line">    g_bTaskCompleted = true;</span><br><span class="line"></span><br><span class="line">    //设置事件信号</span><br><span class="line">    SetEvent(g_hTaskEvent);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //创建一个匿名的手动重置初始无信号的事件对象</span><br><span class="line">    g_hTaskEvent = CreateEvent(NULL, TRUE, FALSE, NULL);</span><br><span class="line">    HANDLE hWorkerThread = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL); </span><br><span class="line">    </span><br><span class="line">    DWORD dwResult = WaitForSingleObject(g_hTaskEvent, INFINITE);</span><br><span class="line">    if (dwResult == WAIT_OBJECT_0)</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; g_TaskResult &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    CloseHandle(hWorkerThread);</span><br><span class="line">    CloseHandle(g_hTaskEvent);</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在上述代码中，主线程在工作线程完成任务之前会一直阻塞代码 29 行，没有任何消耗，当工作线程完成任务后调用 <code>SetEvent</code> 让事件对象受信，这样主线程会立即得到通知，从 <code>WaitForSingleObject</code> 返回，此时任务已经完成，就可以得到任务结果了。</p><p>在实际的开发中，可以利等待的时间去做一点其他的事情，在我们需要的时候去检测一下事件对象是否有信号即可。另外，<code>Event</code> 对象有两个显著的特点：</p><ul><li>与临界区对象（以及接下来要介绍的 <code>Mutex</code> 对象）相比，<code>Event</code> 对象没有被谁持让持有者线程变成其 <code>owner</code> 这一说法，因此 <code>Event</code> 对象可以同时唤醒多个等待的工作线程。</li><li>手动重置的 <code>Event</code> 对象一旦变成受信状态，其信号不会丢失，也就是说当 <code>Event</code> 从无信号变成有信号时，即使某个线程当时没有调用 <code>WaitForSingleObject</code> 等待该 <code>Event</code> 对象受信，而是在这之后才调用 <code>WaitForSingleObject</code> ，仍然能检测到事件的受信状态，即不会丢失信号，而后面要介绍的条件变量就可能会丢失信号。<h2 id="Event-使用示例"><a href="#Event-使用示例" class="headerlink" title="Event 使用示例"></a>Event 使用示例</h2>蘑菇街开源的即时通讯 Teamtalk pc 版（<a class="link" href="https://github.com/baloonwj/TeamTalk">代码下载地址请点击这里<i class="fas fa-external-link-alt"></i></a>）在使用 <code>socket</code> 连接服务器时，使用 <code>Event</code> 对象设计了一个超时做法。传统的做法是将 <code>socket</code> 设置为非阻塞的，调用完 <code>connect</code> 函数之后，调用 <code>select</code> 函数检测 <code>socket</code> 是否可写，在 <code>select</code> 函数里面设置超时时间。Teamtalk 的做法如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> //TcpClientModule_Impl.cpp 145行</span><br><span class="line"> IM::Login::IMLoginRes* TcpClientModule_Impl::doLogin(CString &amp;linkaddr, UInt16 port</span><br><span class="line">    ,CString&amp; uName,std::string&amp; pass)</span><br><span class="line">{</span><br><span class="line">    //imcore::IMLibCoreConnect 中通过 connect 连接服务器</span><br><span class="line">    m_socketHandle = imcore::IMLibCoreConnect(util::cStringToString(linkaddr), port);</span><br><span class="line">    imcore::IMLibCoreRegisterCallback(m_socketHandle, this);</span><br><span class="line">    if(util::waitSingleObject(m_eventConnected, 5000))</span><br><span class="line">    {</span><br><span class="line">        IM::Login::IMLoginReq imLoginReq;</span><br><span class="line">        string&amp; name = util::cStringToString(uName);</span><br><span class="line">        imLoginReq.set_user_name(name);</span><br><span class="line">        imLoginReq.set_password(pass);</span><br><span class="line">        imLoginReq.set_online_status(IM::BaseDefine::USER_STATUS_ONLINE);</span><br><span class="line">        imLoginReq.set_client_type(IM::BaseDefine::CLIENT_TYPE_WINDOWS);</span><br><span class="line">        imLoginReq.set_client_version("win_10086");</span><br><span class="line"></span><br><span class="line">        if (TCPCLIENT_STATE_OK != m_tcpClientState)</span><br><span class="line">            return 0;</span><br><span class="line"></span><br><span class="line">        sendPacket(IM::BaseDefine::SID_LOGIN, IM::BaseDefine::CID_LOGIN_REQ_USERLOGIN, ++g_seqNum</span><br><span class="line">            , &amp;imLoginReq);</span><br><span class="line">        m_pImLoginResp-&gt;Clear();</span><br><span class="line">        util::waitSingleObject(m_eventReceived, 10000);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return m_pImLoginResp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><code>util::waitSingleObject</code> 即封装 API <code>WaitForSingleObject</code> 函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//utilCommonAPI.cpp 197行</span><br><span class="line">BOOL waitSingleObject(HANDLE handle, Int32 timeout)</span><br><span class="line">{</span><br><span class="line">    int t = 0;</span><br><span class="line">    DWORD waitResult = WAIT_FAILED;</span><br><span class="line">    do</span><br><span class="line">    {</span><br><span class="line">        int timeWaiter = 500;</span><br><span class="line">        t += timeWaiter;</span><br><span class="line">        waitResult = WaitForSingleObject(handle, timeWaiter);</span><br><span class="line">    } while ((WAIT_TIMEOUT == waitResult) &amp;&amp; (t &lt; timeout));</span><br><span class="line"></span><br><span class="line">    return (WAIT_OBJECT_0 == waitResult);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>等待的 <code>m_eventConnected</code> 对象即是一个 <code>Event</code> 类型：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//定义</span><br><span class="line">HANDLE                            m_eventConnected;</span><br><span class="line">//在 TcpClientModule_Impl 构造函数中初始化</span><br><span class="line">//m_eventConnected = CreateEvent(NULL, FALSE, FALSE, NULL);</span><br></pre></td></tr></table></figure>这个 <code>WaitForSingleObejct</code> 何时会返回呢？如果网络线程中 <code>connect</code> 函数可以正常连接服务器，会让 <code>m_eventConnected</code> 受信，这样 <code>WaitForSingleObejct</code> 函数就会返回了，接着组装登录数据包接着发数据。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void TcpClientModule_Impl::onConnectDone()</span><br><span class="line">{</span><br><span class="line">    m_tcpClientState = TCPCLIENT_STATE_OK;</span><br><span class="line">    ::SetEvent(m_eventConnected);</span><br><span class="line"></span><br><span class="line">    m_bDoReloginServerNow = FALSE;</span><br><span class="line">    if (!m_pServerPingTimer)</span><br><span class="line">    {</span><br><span class="line">        _startServerPingTimer();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>归纳起来，这里利用了一个 <code>Event</code> 对象实现了一个同步登录的过程，网络连接最大超时事件设置成了 5000 毫秒（5 秒）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">util::waitSingleObject(m_eventConnected, 5000)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><code>Event</code> 对象是 Windows 多线程最常用的同步对象之一，其特点是简单易用，如果多个线程都是等待一个 <code>Event</code> 对象受信，无法精确控制唤醒指定数量的线程，后面我们用信号量来解决该问题。</li></ul><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows 线程资源同步之临界区</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-5/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-5/</id>
    <published>2021-10-18T04:59:12.000Z</published>
    <updated>2022-05-01T13:40:22.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-huCfmAOM" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="552448704" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Windows-线程资源同步之临界区"><a href="#Windows-线程资源同步之临界区" class="headerlink" title="Windows 线程资源同步之临界区"></a>Windows 线程资源同步之临界区</h1><p>前面章节介绍了多线程编程的一些基础内容，从本讲开始，我将系统地介绍一遍 Windows 和 Linux 操作系统下各种常用的多线程资源同步对象。</p><p>在开始介绍 Windows 多线程资源同步之前，我们来介绍两个重要的 Windows API 函数 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code>，Windows 上所有多线程同步对象基本上都是通过这两个函数完成的，前者只能一次操作一个资源同步对象，后者可以同时操作多个资源同步对象。</p><h2 id="WaitForSingleObject-与-WaitForMultipleObjects-函数"><a href="#WaitForSingleObject-与-WaitForMultipleObjects-函数" class="headerlink" title="WaitForSingleObject 与 WaitForMultipleObjects 函数"></a>WaitForSingleObject 与 WaitForMultipleObjects 函数</h2><p>先来说 <code>WaitForSingleObject</code>，这个函数的签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);</span><br></pre></td></tr></table></figure><p>这个函数的作用是等待一个内核对象，在 Windows 系统上一个内核对象通常使用其句柄来操作，参数 <code>hHandle</code> 即需要等待的内核对象，参数 <code>dwMilliseconds</code> 是等待这个内核对象的最大时间，时间单位是毫秒，其类型是 <code>DWORD</code>，这是一个 <code>unsigned long</code> 类型。如果我们需要无限等待下去，可以将这个参数值设置为 <code>INFINITE</code> 宏。</p><p>在 Windows 上可以调用 <code>WaitForSingleObject</code> 等待的常见对象如下表所示：</p><table><thead><tr><th>可以被等待的对象</th><th>等待对象成功的含义</th><th>对象类型</th></tr></thead><tbody><tr><td>线程</td><td>等待线程结束</td><td>HANDLE</td></tr><tr><td>Process</td><td>等待进程结束</td><td>HANDLE</td></tr><tr><td>Event（事件）</td><td>等待 Event 有信号</td><td>HANDLE</td></tr><tr><td>Mutex (互斥体)</td><td>等待持有 Mutex 的线程释放该 Mutex，等待成功，拥有该 Mutex</td><td>HANDLE</td></tr><tr><td>Semaphore（信号量）</td><td>等待该 Semaphore 对象有信号</td><td>HANDLE</td></tr></tbody></table><p>上面介绍的等待线程对象上文中已经详细介绍过了，这里不再重复了，等待进程退出与等待线程退出类似，也不再赘述。下文中我们将详细介绍 <code>Event</code>、<code>Mutex</code>、<code>Semaphore</code> 这三种类型的资源同步对象，这里我们先接着介绍 <code>WaitForSingleObject</code> 函数的用法，该函数的返回值一般有以下类型：</p><ul><li><code>WAIT_FAILED</code>，表示 <code>WaitForSingleObject</code> 函数调用失败了，可以通过 <code>GetLastError()</code> 函数得到具体的错误码；</li><li><code>WAIT_OBJECT_0</code>，表示 <code>WaitForSingleObject</code> 成功“等待”到设置的对象；</li><li><code>WAIT_TIMEOUT</code>，等待超时；</li><li><code>WAIT_ABANDONED</code>，当等待的对象是 <code>Mutex</code> 类型时，如果持有该 <code>Mutex</code> 对象的线程已经结束，但是没有在结束前释放该 <code>Mutex</code>，此时该 <code>Mutex</code> 已经处于废弃状态，其行为是未知的，不建议再使用。</li></ul><p><code>WaitForSingleObject</code> 如其名字一样，只能“等待”单个对象，如果需要同时等待多个对象可以使用 <code>WaitForMultipleObjects</code>，除了对象的数量变多了，其用法基本上和 <code>WaitForSingleObject</code> 一样。 <code>WaitForMultipleObjects</code> 函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForMultipleObjects(</span><br><span class="line">    DWORD        nCount,</span><br><span class="line">    const HANDLE *lpHandles,</span><br><span class="line">    BOOL         bWaitAll,</span><br><span class="line">    DWORD        dwMilliseconds</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数 <code>lpHandles</code> 是需要等待的对象数组指针，参数 <code>nCount</code> 指定了该数组的长度，参数 <code>bWaitAll</code> 表示是否等待数组 <code>lpHandles</code> 所有对象有“信号”，取值为 <code>TRUE</code> 时，<code>WaitForMultipleObjects</code> 会等待所有对象有信号才会返回，取值为 <code>FALSE</code> 时，当其中有一个对象有信号时，立即返回，此时其返回值表示哪个对象有信号。</p><p>在参数 <code>bWaitAll</code> 设置为 <code>FALSE</code> 的情况下， 除了上面介绍的返回值是 <code>WAITFAILED</code> 和 <code>WAITTIMEOUT</code> 以外，返回值还有另外两种情形（分别对应 <code>WaitForSingleObject</code> 返回值是 <code>WAIT_OBJECT_0</code> 和 <code>WAIT_ABANDONED</code> 两种情形）：</p><ul><li><code>WAIT_OBJECT_0</code> to (<code>WAIT_OBJECT_0 + nCount– 1</code>)，举个例子，假设现在等待三个对象 A1、A2、A3，它们在数组 <code>lpHandles</code> 中的下标依次是 0、1、2，某次 <code>WaitForMultipleObjects</code> 返回值是 <code>Wait_OBJECT_0 + 1</code>，则表示对象 A2 有信号，导致 <code>WaitForMultipleObjects</code> 调用成功返回。</li></ul><p>伪码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">HANDLE waitHandles[3];</span><br><span class="line">waitHandles[0] = hA1Handle;</span><br><span class="line">waitHandles[1] = hA2Handle;</span><br><span class="line">waitHandles[2] = hA3Handle;</span><br><span class="line"></span><br><span class="line">DWORD dwResult = WaitForMultipleObjects(3, waitHandles, FALSE, 3000);</span><br><span class="line">switch(dwResult)</span><br><span class="line">{</span><br><span class="line">    case WAIT_OBJECT_0 + 0:</span><br><span class="line">        //A1 有信号</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case WAIT_OBJECT_0 + 1:</span><br><span class="line">        //A2 有信号</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case WAIT_OBJECT_0 + 2:</span><br><span class="line">        //A3 有信号</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        //出错或超时</span><br><span class="line">        break;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ul><li><code>WAIT_ABANDONED_0</code> to (<code>WAIT_ABANDONED_0 + nCount– 1</code>)，这种情形与上面的使用方法相同，通过 <code>nCount - 1</code> 可以知道是等待对象数组中哪个对象始终没有被其他线程释放使用权。</li></ul><blockquote><p>这里说了这么多理论知识，读者将在下文介绍的 Windows 常用的资源同步对象章节中看到具体的示例代码。</p></blockquote><h2 id="Windows-的临界区对象"><a href="#Windows-的临界区对象" class="headerlink" title="Windows 的临界区对象"></a>Windows 的临界区对象</h2><p>在所有的 Windows 资源同步对象中，<code>CriticalSection</code> （临界区对象，有些书上翻译成“关键段”）是最简单易用的，从程序的术语来说，它防止多线程同时执行其保护的那段代码（<code>临界区代码</code>），即临界区代码某一时刻只允许一个线程去执行，示意图如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded9.1nxd1pd0sxhc.jpg" alt="multithreaded9"></p><p>Windows 没有公开 <code>CriticalSection</code> 数据结构的定义，我们一般使用如下五个 API 函数操作临界区对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</span><br><span class="line">void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</span><br><span class="line"></span><br><span class="line">BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</span><br><span class="line">void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</span><br><span class="line">void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);</span><br></pre></td></tr></table></figure><p><code>InitializeCriticalSection</code> 和 <code>DeleteCriticalSection</code> 用于初始化和销毁一个 <code>CRITICAL_SECTION</code> 对象；位于<code>EnterCriticalSection</code> 和 <code>LeaveCriticalSection</code> 之间的代码即临界区代码；调用 <code>EnterCriticalSection</code> 的线程会尝试“进入“临界区，如果进入不了，则会阻塞调用线程，直到成功进入或者超时；<code>TryEnterCriticalSection</code> 会尝试进入临界区，如果可以进入，则函数返回 <code>TRUE</code> ，如果无法进入则立即返回不会阻塞调用线程，函数返回 <code>FALSE</code>。<code>LeaveCriticalSection</code> 函数让调用线程离开临界区，离开临界区以后，临界区的代码允许其他线程调用 <code>EnterCriticalSection</code> 进入。</p><blockquote><p><code>EnterCriticalSection</code> 超时时间很长，可以在注册表 <code>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager</code> 这个位置修改参数 <code>CriticalSectionTimeout</code> 的值调整，当然实际开发中我们从来不会修改这个值，如果你的代码等待时间较长最终超时，请检查你的逻辑设计是否合理。</p></blockquote><p>我们来看一段实例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;list&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"> </span><br><span class="line">CRITICAL_SECTION       g_cs;</span><br><span class="line">int                    g_number = 0;</span><br><span class="line"></span><br><span class="line">DWORD __stdcall WorkerThreadProc(LPVOID lpThreadParameter)</span><br><span class="line">{</span><br><span class="line">    DWORD dwThreadID = GetCurrentThreadId();</span><br><span class="line">    </span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        EnterCriticalSection(&amp;g_cs);</span><br><span class="line">          std::cout &lt;&lt; "EnterCriticalSection, ThreadID: " &lt;&lt; dwThreadID &lt;&lt; std::endl;</span><br><span class="line">        g_number++;</span><br><span class="line">        SYSTEMTIME st;</span><br><span class="line">        //获取当前系统时间</span><br><span class="line">        GetLocalTime(&amp;st);</span><br><span class="line">        char szMsg[64] = { 0 };</span><br><span class="line">        sprintf(szMsg, </span><br><span class="line">                "[%04d-%02d-%02d %02d:%02d:%02d:%03d]NO.%d, ThreadID: %d.", </span><br><span class="line">                st.wYear, st.wMonth, st.wDay, </span><br><span class="line">                  st.wHour, st.wMinute, st.wSecond, st.wMilliseconds, </span><br><span class="line">                g_number, dwThreadID);</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; szMsg &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; "LeaveCriticalSection, ThreadID: " &lt;&lt; dwThreadID &lt;&lt; std::endl;</span><br><span class="line">        LeaveCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">        //睡眠1秒</span><br><span class="line">        Sleep(1000);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    InitializeCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">    HANDLE hWorkerThread1 = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);</span><br><span class="line">    HANDLE hWorkerThread2 = CreateThread(NULL, 0, WorkerThreadProc, NULL, 0, NULL);</span><br><span class="line"></span><br><span class="line">    WaitForSingleObject(hWorkerThread1, INFINITE);</span><br><span class="line">    WaitForSingleObject(hWorkerThread2, INFINITE);</span><br><span class="line"></span><br><span class="line">    //关闭线程句柄</span><br><span class="line">    CloseHandle(hWorkerThread1);</span><br><span class="line">    CloseHandle(hWorkerThread2);</span><br><span class="line"></span><br><span class="line">    DeleteCriticalSection(&amp;g_cs);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述程序执行输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">EnterCriticalSection, ThreadID: 1224</span><br><span class="line">[2019-01-19 22:25:41:031]NO.1, ThreadID: 1224.</span><br><span class="line">LeaveCriticalSection, ThreadID: 1224</span><br><span class="line">EnterCriticalSection, ThreadID: 6588</span><br><span class="line">[2019-01-19 22:25:41:031]NO.2, ThreadID: 6588.</span><br><span class="line">LeaveCriticalSection, ThreadID: 6588</span><br><span class="line">EnterCriticalSection, ThreadID: 6588</span><br><span class="line">[2019-01-19 22:25:42:031]NO.3, ThreadID: 6588.</span><br><span class="line">LeaveCriticalSection, ThreadID: 6588</span><br><span class="line">EnterCriticalSection, ThreadID: 1224</span><br><span class="line">[2019-01-19 22:25:42:031]NO.4, ThreadID: 1224.</span><br><span class="line">LeaveCriticalSection, ThreadID: 1224</span><br><span class="line">EnterCriticalSection, ThreadID: 1224</span><br><span class="line">[2019-01-19 22:25:43:031]NO.5, ThreadID: 1224.</span><br><span class="line">LeaveCriticalSection, ThreadID: 1224</span><br><span class="line">EnterCriticalSection, ThreadID: 6588</span><br><span class="line">[2019-01-19 22:25:43:031]NO.6, ThreadID: 6588.</span><br><span class="line">LeaveCriticalSection, ThreadID: 6588</span><br><span class="line">EnterCriticalSection, ThreadID: 1224</span><br><span class="line">[2019-01-19 22:25:44:031]NO.7, ThreadID: 1224.</span><br><span class="line">LeaveCriticalSection, ThreadID: 1224</span><br><span class="line">EnterCriticalSection, ThreadID: 6588</span><br><span class="line">[2019-01-19 22:25:44:031]NO.8, ThreadID: 6588.</span><br><span class="line">LeaveCriticalSection, ThreadID: 6588</span><br></pre></td></tr></table></figure><p>在上述代码中我们新建两个工作线程，线程函数都是 <code>WorkerThreadProc</code>。线程函数在 15 行调用 <code>EnterCriticalSection</code> 进入临界区，在 30 行调用 <code>LeaveCriticalSection</code> 离开临界区，16 ～ 29 行之间的代码即临界区的代码，这段代码由于受到临界区对象 <code>g_cs</code> 的保护，因为每次只允许一个工作线程执行这段代码。虽然临界区代码中有多个输出，但是这些输出一定都是连续的，不会出现交叉输出的结果。</p><p>细心的读者会发现上述输出中存在同一个的线程连续两次进入临界区，这是有可能的。也就是说，当其中一个线程离开临界区，即使此时有其他线程在这个临界区外面等待，由于线程调度的不确定性，此时正在等待的线程也不会有先进入临界区的优势，它和刚离开这个临界区的线程再次竞争进入临界区是机会均等的。我们来看一张图：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded10.4u16k5jia900.jpg" alt="multithreaded10"></p><p>上图中我们将线程函数的执行流程绘制成一个流程图，两个线程竞争进入临界区可能存在如下情形，为了表述方便，将线程称为 A、B。</p><ul><li><p>情形一：<strong>线程 A</strong> 被唤醒获得 CPU 时间片进入临界区，执行流程 ①，然后执行临界区代码输出 → <strong>线程 B</strong> 获得 CPU 时间片，执行流程 ②，然后失去 CPU 时间片进入休眠 → <strong>线程 A</strong> 执行完临界区代码离开临界区后执行流程 ⑤，然后失去 CPU 时间片进入休眠 → <strong>线程 B</strong> 被唤醒获得 CPU 时间片执行流程 ③、①，然后执行临界区代码输出。</p><p>这种情形下，线程 A 和线程 B 会轮流进入临界区执行代码。</p></li><li><p>情形二：<strong>线程 A</strong> 被唤醒获得 CPU 时间片进入临界区，执行流程 ①，然后执行临界区代码输出 → <strong>线程 B</strong> 获得 CPU 时间片，执行流程 ③，然后执行流程 ② 在临界区外面失去 CPU 时间片进入休眠 → <strong>线程 A</strong> 执行完临界区代码离开临界区后执行流程 ④、① 。</p><p>这种情形下，会出现某个线程连续两次甚至更多次的进入临界区执行代码。</p></li></ul><p>如果某个线程在尝试进入临界区时因无法阻塞而进入睡眠状态，当其他线程离开这个临界区后，之前因为这个临界区而阻塞的线程可能会被唤醒进行再次竞争，也可能不被唤醒。但是存在这样一种特例，假设现在存在两个线程 A 和 B，<strong>线程 A</strong> 离开临界区的线程再也不需要再次进入临界区，那么<strong>线程 B</strong> 在被唤醒时一定可以进入临界区。<strong>线程 B</strong> 从睡眠状态被唤醒，这涉及到一次线程的切换，有时候这种开销是不必要的，我们可以让 B 简单地执行一个循环等待一段时间后去进去临界区，而不是先睡眠再唤醒，与后者相比，执行这个循环的消耗更小。这就是所谓的“自旋”，在这种情形下，Windows 提供了另外一个初始化临界区的函数 <code>InitializeCriticalSectionAndSpinCount</code>，这个函数比 <code>InitializeCriticalSection</code> 多一个自旋的次数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL InitializeCriticalSectionAndSpinCount(</span><br><span class="line">      LPCRITICAL_SECTION lpCriticalSection,</span><br><span class="line">      DWORD              dwSpinCount</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>参数 <code>dwSpinCount</code> 是自旋的次数，利用自旋来代替让 CPU 进入睡眠和再次被唤醒，消除线程上下文切换带来的消耗，提高效率。当然，在实际开发中这种方式是靠不住的，线程调度是操作系统内核的策略，应用层上的应用不应该假设线程的调度策略是按预想的来执行。但是理解线程与临界区之间的原理有利于编写出更高效的应用来。</p><p>需要说明的是，临界区对象通过保护一段代码不被多个线程同时执行，进而来保证多个线程之间读写一个对象是安全的。由于同一时刻只有一个线程可以进入临界区，因此这种对资源的操作是排他的，即对于同一个临界区对象，不会出现多个线程同时操作该资源，哪怕是资源本身可以在同一时刻被多个线程进行操作，如多个线程对资源进行读操作，这就带来了效率问题。</p><p>我们一般将进入临界区的线程称为该临界区的拥有者（<code>owner</code>）——临界区持有者。</p><p>最后，为了避免死锁，<code>EnterCriticalSection</code> 和 <code>LeaveCriticalSection</code> 需要成对使用，尤其是在具有多个出口的函数中，记得在每个分支处加上 <code>LeaveCriticalSection</code>。伪码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">void someFunction()</span><br><span class="line">{</span><br><span class="line">    EnterCriticalSection(&amp;someCriticalSection);</span><br><span class="line">    if (条件A)</span><br><span class="line">    {</span><br><span class="line">        if (条件B)</span><br><span class="line">        {</span><br><span class="line">            LeaveCriticalSection(&amp;someCriticalSection);</span><br><span class="line">            //出口1</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        LeaveCriticalSection(&amp;someCriticalSection);</span><br><span class="line">        //出口2</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (条件C)</span><br><span class="line">    {</span><br><span class="line">        LeaveCriticalSection(&amp;someCriticalSection);</span><br><span class="line">        // 出口3</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (条件C)</span><br><span class="line">    {</span><br><span class="line">        LeaveCriticalSection(&amp;someCriticalSection);</span><br><span class="line">        // 出口4</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中，为了能让临界区对象被正常的释放，在函数的每个出口都加上了 <code>LeaveCriticalSection</code> 调用，如果函数的出口非常多，这样的代码太难维护了。因此一般建议使用 <code>RAII</code> 技术将临界区 API 封装成对象，该对象在函其作用域内进入临界区，在出了其作用域后自动离开临界区，示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CCriticalSection</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    CCriticalSection(CRITICAL_SECTION&amp; cs) : mCS(cs)</span><br><span class="line">    {</span><br><span class="line">        EnterCriticalSection(&amp;mCS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~CCriticalSection()</span><br><span class="line">    {</span><br><span class="line">        LeaveCriticalSection(&amp;mCS);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    CRITICAL_SECTION&amp; mCS;</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>利用 <code>CCriticalSection</code> 类，我们可以对上述伪码进行优化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void someFunction()</span><br><span class="line">{</span><br><span class="line">    CCriticalSection autoCS(someCriticalSection);</span><br><span class="line">    if (条件A)</span><br><span class="line">    {</span><br><span class="line">        if (条件B)</span><br><span class="line">        { </span><br><span class="line">            //出口1</span><br><span class="line">            return;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //出口2</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (条件C)</span><br><span class="line">    {      </span><br><span class="line">        // 出口3</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    if (条件C)</span><br><span class="line">    {        </span><br><span class="line">        // 出口4</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中由于变量 <code>autoCS</code> 会在出了函数作用域后调用其析构函数，在析构函数中调用 <code>LeaveCriticalSection</code> 自动离开临界区。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本讲介绍了 <code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 这两个重要的 Windows API 函数，同时介绍了 Windows 上第一个线程同步对象——临界区，为了避免因函数有多个出口造成的编码疏漏，我们介绍了使用 <code>RAII</code> 封装临界区对象的方法。临界区对象是 Windows 系统多线程资源同步最常用的对象之一。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>整型变量的原子操作</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-4/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-4/</id>
    <published>2021-10-18T04:42:37.000Z</published>
    <updated>2022-05-01T13:40:22.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-UZKzImCd" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1302090545" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="整型变量的原子操作"><a href="#整型变量的原子操作" class="headerlink" title="整型变量的原子操作"></a>整型变量的原子操作</h1><p>从本讲开始，我们讨论的主题为线程之间的同步技术。所谓线程同步技术，指的是多个线程同时操作某个资源（从程序的术语来说，这里的资源可能是一个简单的整型变量，也可能是一个复杂的 C++ 对象）。多线程同时操作资源指的是多线程同时对资源的读和写，我们需要采取一些特殊的措施去保护这些资源，以免引起一些资源访问冲突（如死锁）或者得到意料外的结果。</p><p>当然，最简单的资源类型应该就是整形变量了。这里给大家说个小故事：在我刚开始参加工作的那年，公司安排我开发一款即时通讯软件（IM，类似于 QQ 聊天软件），在这之前我心里也知道如果多线程操作一个整型值是要加锁的，但是当时为了图代码简便，而且在实际调试的时候，没有加锁的代码也从来没出过问题。于是我就心存侥幸了，觉得对整型值加锁真是多此一举。</p><p>我们的软件有类似于 QQ 这种单人聊天功能，每个用户都有一个整型的 userid，问题就出在这里。当时公司的老板和他媳妇儿也使用这款软件，问题来了：有一天早上老板在这个软件上给他媳妇发了一段亲密的话，问题是，由于多线程操作他媳妇儿的 userid 没加锁，最终变成了另外一个人的 userid，而这个 userid 恰好是我的账户。于是老板发给他媳妇儿的聊天内容就被发给我了。我当时看到聊天内容很奇怪，还回复了他一句，并且还带上了我自己的姓名……事情的结果，可想而知了，老板非常尴尬也非常生气……从那以后，老板看我的眼神都是怪怪的。我自知理亏，再也不侥幸了，凡是多线程读写整型变量都养成加锁的好习惯。</p><p>为什么整型变量赋值操作不是原子的</p><p>那么为什么整型变量的操作不是原子性的呢？常见的整型变量操作有如下几种情况：</p><ul><li><p>给整型变量赋值一个确定的值，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br></pre></td></tr></table></figure><p>这条指令操作一般是原子的，因为对应着一条计算机指令，CPU 将立即数 1 搬运到变量 a 的内存地址中即可，汇编指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr [a], 2</span><br></pre></td></tr></table></figure><p>然后这确是最不常见的情形，由于现代编译器一般存在优化策略，如果变量 <code>a</code> 的值在编译期间就可以计算出来（例如这里的例子中 <code>a</code> 的值就是1），那么 <code>a</code> 这个变量本身在正式版本的软件中（<code>release</code> 版）就很有可能被编译器优化掉，凡是使用 <code>a</code> 的地方，直接使用常量 1 来代替。因此实际的执行指令中，这样的指令存在的可能性比较低。</p></li><li><p>变量自身增加或者减去一个值，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a ++;</span><br></pre></td></tr></table></figure><p>从 C/C++ 语法的级别来看，这是一条语句，是原子的；但是从实际执行的二进制指令来看，也不是原子的，其一般对应三条指令，首先将变量 <code>a</code> 对应的内存值搬运到某个寄存器（如 <code>eax</code> ）中，然后将该寄存器中的值自增 1，再将该寄存器中的值搬运回 <code>a</code> 代表的内存中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [a]</span><br><span class="line">inc eax</span><br><span class="line">mov dword ptr [a], eax</span><br></pre></td></tr></table></figure><p>现在假设 <code>a</code> 的值是 0，有两个线程，每个线程对变量 <code>a</code> 的值递增 1，我们预想的结果应该是 2，可实际运行的结果可能是 1！是不是很奇怪？分析如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line"></span><br><span class="line">//线程1</span><br><span class="line">void thread_func1()</span><br><span class="line">{</span><br><span class="line">    a ++;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//线程2</span><br><span class="line">void thread_func2()</span><br><span class="line">{</span><br><span class="line">    a ++;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded5.33rjtpd0i540.jpg" alt="multithreaded5"></p><p>我们预想的结果是<strong>线程 1</strong> 和 <strong>线程 2</strong> 的三条指令各自执行，最终 <code>a</code> 的值变为 2，但是由于操作系统线程调度的不确定性，<strong>线程 1</strong> 执行完指令 ① 和 ② 后，<code>eax</code> 寄存器中的值变为 1，此时操作系统切换到 <strong>线程2</strong> 执行，执行指令 ③ ④ ⑤，此时 <code>eax</code> 的值变为 1；接着操作系统切回线程 1 继续执行，执行指令 ⑥，得到 <code>a</code> 的最终结果 1。</p></li><li><p>把一个变量的值赋值给另外一个变量，或者把一个表达式的值赋值给另外一个变量，如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = b;</span><br></pre></td></tr></table></figure><p>从 C/C++ 语法的级别来看，这也是一条语句，是原子的；但是从实际执行的二进制指令来看，由于现代计算机 CPU 架构体系的限制，数据不可以直接从内存搬运到另外一块内存，必须借助寄存器中转，这条语句一般对应两条计算机指令，即将变量 <code>b</code> 的值搬运到某个寄存器（如 <code>eax</code>）中，再从该寄存器搬运到变量 a 的内存地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax, dword ptr [b]</span><br><span class="line">mov dword ptr [a], eax </span><br></pre></td></tr></table></figure><p>既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺 CPU 时间片，切换到另外一个线程而产生不确定的情况。这和上一种情况类似，就不再详细分析了。</p><p>说点题外话，网上很多人强调某些特殊的整型数值类型（如 <code>bool</code> 类型）的操作是原子的，这是由于，某些 CPU 生产商开始有意识地从硬件平台保证这一类操作的原子性，但这并不是每一种类型的 CPU 架构都支持，在这一事实成为标准之前，我们在多线程操作整型时还是老老实实使用下文介绍的原子操作或线程同步技术来对这些数据类型进行保护。</p></li></ul><h2 id="Windows-平台上整型变量的原子操作"><a href="#Windows-平台上整型变量的原子操作" class="headerlink" title="Windows 平台上整型变量的原子操作"></a>Windows 平台上整型变量的原子操作</h2><p>整型变量的原子操作是一些非常常用且实用的操作，因此 Windows 操作系统也提供了 API 级别的支持，使用这些 API 可以直接对整型变量进行原子操作，而不用借助专门的锁对象，在 Windows 平台上，它们是 <code>Interlocked</code> 系列函数。这里给出 <code>Interlocked</code> 常用的 API 的一个列表：</p><table><thead><tr><th>函数名</th><th>函数说明</th></tr></thead><tbody><tr><td><code>InterlockedIncrement</code></td><td>将 32 位整型变量自增 1</td></tr><tr><td><code>InterlockedDecrement</code></td><td>将 32 位整型变量自减 1</td></tr><tr><td><code>InterlockedExchangeAdd</code></td><td>将 32 位整型值增加 n （n 可以是负值）</td></tr><tr><td><code>InterlockedXor</code></td><td>将 32 位整型值与 n 进行异或操作</td></tr><tr><td><code>InterlockedCompareExchange</code></td><td>将 32 位整型值与 n1 进行比较，如果相等，则替换成 n2</td></tr></tbody></table><p>上表中仅列出了与 32 位（bit）整型相关的 API 函数，Windows 还提供了对 8 位、16 位以及 64 位的整型变量进行原子操作的 API，读者在实际使用时可以自行参考 MSDN。</p><p>我们以上表中 <code>InterlockedIncrement</code> 为例来说明这类函数的用法，<code>InterlockedIncrement</code> 的函数签名是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LONG InterlockedIncrement(LONG volatile *Addend);</span><br></pre></td></tr></table></figure><p>这个函数的作用是将变量 <code>Addend</code> 自增 1，并返回自增后的值。</p><blockquote><p>注意：这里的 LONG 型即 long 型，在 32 位系统中，LONG 占 4个字节。</p></blockquote><p>我们来写一个例子来验证一下：</p><p>#include &lt;Windows.h&gt;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    LONG nPreValue = 99;</span><br><span class="line">    LONG nPostValue = InterlockedIncrement(&amp;nPreValue);</span><br><span class="line"></span><br><span class="line">    printf("nPreValue=%d, nPostValue=%d\n", nPreValue, nPostValue);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序执行结果：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded6.fhf5dvfpso8.jpg" alt="multithreaded6"></p><h2 id="C-11-对整型变量原子操作的支持"><a href="#C-11-对整型变量原子操作的支持" class="headerlink" title="C++11 对整型变量原子操作的支持"></a>C++11 对整型变量原子操作的支持</h2><p>在 C++ 98/03 标准中，如果想对整型变量进行原子操作，要么利用操作系统提供的相关原子操作 API，要么利用对应操作系统提供的锁对象来对变量进行保护，无论是哪种方式，编写的代码都无法实现跨平台操作。例如上一小介绍的 <code>Interlocked</code> 系列 API 代码仅能运行于 Windows 系统，无法移植到 Linux 系统。<code>C++ 11</code> 新标准发布以后，改变了这种困境，新标准提供了对整型变量原子操作的相关库，即 <code>std::atomic</code> ，这是一个模板类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;</span><br><span class="line">struct atomic;</span><br></pre></td></tr></table></figure><p>你可以传入具体的整型类型（如 bool、char、short、int、uint 等）对模板进行实例化，实际上 <code>stl</code> 库也提供了这些实例化的模板类型：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded7.4931o59wwr00.jpg" alt="multithreaded7"></p><p>上表中仅列出了 <code>C++ 11</code> 支持的常用的整型原子变量，完整的列表读者可以<a class="link" href="https://zh.cppreference.com/w/cpp/atomic/atomic">参考这里<i class="fas fa-external-link-alt"></i></a>。</p><p>有了 C++ 语言本身对原子变量的支持以后，我们就可以“愉快地”写出跨平台的代码了，来看一段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::atomic&lt;int&gt; value;</span><br><span class="line">    value = 99;</span><br><span class="line">    printf("%d\n", (int)value);</span><br><span class="line"></span><br><span class="line">    //自增1，原子操作</span><br><span class="line">    value++;</span><br><span class="line">    printf("%d\n", (int)value);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>以上代码可以同时在 Windows 和 Linux 平台上运行，但是有读者可能会根据个人习惯将上述代码写成如下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;atomic&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::atomic&lt;int&gt; value = 99;</span><br><span class="line">    printf("%d\n", (int)value);</span><br><span class="line"></span><br><span class="line">    //自增1，原子操作</span><br><span class="line">    value++;</span><br><span class="line">    printf("%d\n", (int)value);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>代码仅仅做了一点简单的改动，这段代码在 Windows 平台上运行良好，但是在 Linux 平台上会无法编译通过（这里指的是在支持 <code>C++ 11</code> 语法的 <code>G++</code> 编译中编译），提示错误是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: use of deleted function ‘std::atomic&lt;int&gt;::atomic(const std::atomic&lt;int&gt;&amp;)’</span><br></pre></td></tr></table></figure><p>产生这个错误的原因是 “<code>std::atomic\ value = 99;</code>” 这一行代码调用的是 <code>std::atomic</code> 的拷贝构造函数，对于 <code>int</code> 型，其形式一般如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;int&gt;::atomic(const std::atomic&lt;int&gt;&amp; rhs);</span><br></pre></td></tr></table></figure><p>而根据 <code>C++ 11</code> 的规范，这个拷贝构造函数是默认使用 <code>=delete</code> 语法禁止编译器生成的，<code>g++</code> 遵循了这个标准，<a class="link" href="https://zh.cppreference.com/w/cpp/atomic/atomic/operator%3D">参见这里<i class="fas fa-external-link-alt"></i></a>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atomic&amp; operator=( const atomic&amp; ) = delete;</span><br></pre></td></tr></table></figure><p>因此 Linux 平台上编译器会提示错误，而 Windows 的 <code>VC++</code> 编译器没有遵循这个规范。而对于代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = 99;</span><br></pre></td></tr></table></figure><p><code>g++ </code>和 <code>VC++</code> 同时实现规范中的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T operator=( T desired )</span><br></pre></td></tr></table></figure><blockquote><p>因此，如果读者想利用 C++ 11 提供的 <code>std::atomic</code> 库编写跨平台的代码，在使用 <code>std::atomic</code> 提供的方法时建议参考官方 <code>std::atomic</code> 提供的接口说明来使用，而不是想当然地认为一个方法在此平台上可以运行，在另外一个平台也能有相同的行为，避免出现上面说的这种情形。</p></blockquote><p>上述代码中之所以可以对 <code>value</code> 进行自增（<code>++</code>）操作是因为 <code>std::atomic</code> 类内部重载了 <code>operator++</code> 运算符，除此以外， <code>std::atomic</code> 还提供了大量有用的方法，这些方法读者一定会觉得似曾相似：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded8.5i45oh4m7480.jpg" alt="multithreaded8"></p><p>上表中各个函数基本上是见名知义，读者不必死记硬背，需要时知道如何查询即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本讲介绍了整型变量的原子操作，以及为何多线程操作一个整型变量是不安全的。整型变量的原子操作是实际开发中非常常用一个技术场景，建议读者熟练掌握。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程函数传 C++ 类实例指针惯用法</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-3/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-3/</id>
    <published>2021-10-18T04:39:09.000Z</published>
    <updated>2022-05-01T13:40:22.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-meJUaSjR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1366994516" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程函数传-C-类实例指针惯用法"><a href="#线程函数传-C-类实例指针惯用法" class="headerlink" title="线程函数传 C++ 类实例指针惯用法"></a>线程函数传 C++ 类实例指针惯用法</h1><p>前面的内容介绍了除了 <code>C++ 11</code> 的线程库提供了的 <code>std::thread</code> 类对线程函数签名没有特殊要求外，无论是 Linux 还是 Windows 的线程函数的签名都必须是指定的格式，即参数和返回值必须是规定的形式。如果使用 C++ 面向对象的方式对线程函数进行封装，那么线程函数就不能是类的实例方法，即必须是类的静态方法。那么，为什么不能是类的实例方法呢？我们以 Linux 的线程函数签名为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void threadFunc(void* arg);</span><br></pre></td></tr></table></figure><p>假设，将线程的基本功能封装到一个 <code>Thread</code> 类中，部分代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Thread</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Thread();</span><br><span class="line">    ~Thread();</span><br><span class="line"></span><br><span class="line">    void start();</span><br><span class="line">    void stop();</span><br><span class="line"></span><br><span class="line">    void* threadFunc(void* arg);</span><br><span class="line">};</span><br></pre></td></tr></table></figure><p>由于 <code>threadFunc</code> 是一个类实例方法，无论是类的实例方法还是静态方法，C++ 编译器在编译时都会将这些函数“翻译”成全局函数，即去掉类的域限制。对于实例方法，为了保证类方法的正常功能，C++ 编译器在翻译时，会将类的实例对象地址（也就是 <code>this</code> 指针）作为第一个参数传递给该方法，也就是说，翻译后的 <code>threadFunc</code> 的签名变成了如下形式（伪代码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void* threadFunc(Thread* this, void* arg);</span><br></pre></td></tr></table></figure><p>这样的话，就不符合线程函数签名要求了。因此如果一个线程函数作为类方法，只能是静态方法而不能是实例方法。</p><p>当然，如果是使用 <code>C++ 11</code> 的 <code>std::thread</code> 类就没有这个限制，即使类成员函数是类的实例方法也可以，但是必须显式地将线程函数所属的类对象实例指针（在类的内部就是 <code>this</code> 指针）作为构造函数参数传递给 <code>std::thread</code>，还是需要传递类的 <code>this</code> 指针，这在本质上是一样的，代码实例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">class Thread</span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    Thread()</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~Thread()</span><br><span class="line">    {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Start()</span><br><span class="line">    {</span><br><span class="line">        m_stopped = false;</span><br><span class="line">        //threadFunc 是类的非静态方法，因此作为线程函数，第一个参数必须传递类实例地址，即 this 指针</span><br><span class="line">        m_spThread.reset(new std::thread(&amp;Thread::threadFunc, this, 8888, 9999));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void Stop()</span><br><span class="line">    {</span><br><span class="line">        m_stopped = true;</span><br><span class="line">        if (m_spThread)</span><br><span class="line">        {</span><br><span class="line">            if (m_spThread-&gt;joinable())</span><br><span class="line">                m_spThread-&gt;join();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    void threadFunc(int arg1, int arg2)</span><br><span class="line">    {</span><br><span class="line">        while (!m_stopped)</span><br><span class="line">        {</span><br><span class="line">            printf("Thread function use instance method.\n");</span><br><span class="line">        }      </span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;std::thread&gt;  m_spThread;</span><br><span class="line">    bool                          m_stopped;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    Thread mythread;</span><br><span class="line">    mythread.Start();</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码中使用了 <code>C++ 11</code> 新增的智能指针 <code>std::shared_ptr</code> 类来包裹了一下 <code>new</code> 出来的 <code>std::thread</code> 对象，这样我们就不需要自己手动 <code>delete</code> 这个 <code>std::thread</code> 对象了。</p><p>综上所述，如果不使用 <code>C++ 11</code> 的语法，那么线程函数只能作为类的静态方法，且函数签名必须按规定的签名格式来。如果是类的静态方法，那么就没法访问类的实例方法了，为了解决这个问题，在实际开发中往往会在创建线程时将当前对象的地址（<code>this</code> 指针）传递给线程函数，然后在线程函数中，将该指针转换成原来的类实例，再通过这个实例就可以访问类的所有方法了。代码示例如下：</p><p><code>.h</code> 文件代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread.h</span><br><span class="line"> */</span><br><span class="line">#ifdef WIN32</span><br><span class="line">//#include &lt;windows.h&gt;</span><br><span class="line">typedef HANDLE THREAD_HANDLE ;</span><br><span class="line">#else</span><br><span class="line">//#include &lt;pthread.h&gt;</span><br><span class="line">typedef pthread_t THREAD_HANDLE ;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/**定义了一个线程对象</span><br><span class="line">*/</span><br><span class="line">class  CThread  </span><br><span class="line">{</span><br><span class="line">public:</span><br><span class="line">    /**构造函数</span><br><span class="line">    */</span><br><span class="line">    CThread();</span><br><span class="line"></span><br><span class="line">    /**析构函数</span><br><span class="line">    */</span><br><span class="line">    virtual ~CThread();</span><br><span class="line"></span><br><span class="line">    /**创建一个线程</span><br><span class="line">    * @return true:创建成功 false:创建失败</span><br><span class="line">    */</span><br><span class="line">    virtual bool Create();</span><br><span class="line"></span><br><span class="line">    /**获得本线程对象存储的线程句柄</span><br><span class="line">    * @return 本线程对象存储的线程句柄线程句柄</span><br><span class="line">    */</span><br><span class="line">    THREAD_HANDLE GetHandle();</span><br><span class="line"></span><br><span class="line">    /**线程睡眠 seconds 秒</span><br><span class="line">    * @param seconds 睡眠秒数</span><br><span class="line">    */</span><br><span class="line">    void OSSleep(int nSeconds);</span><br><span class="line"></span><br><span class="line">    void SleepMs(int nMilliseconds);</span><br><span class="line"></span><br><span class="line">    bool Join();</span><br><span class="line"></span><br><span class="line">    bool IsCurrentThread();</span><br><span class="line"></span><br><span class="line">    void ExitThread();</span><br><span class="line"></span><br><span class="line">private:    </span><br><span class="line">#ifdef WIN32</span><br><span class="line">    static DWORD WINAPI _ThreadEntry(LPVOID pParam);</span><br><span class="line">#else</span><br><span class="line">    static void* _ThreadEntry(void* pParam);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /**虚函数，子类可做一些实例化工作</span><br><span class="line">    * @return true:创建成功 false:创建失败</span><br><span class="line">    */</span><br><span class="line">    virtual bool InitInstance();</span><br><span class="line"></span><br><span class="line">    /**虚函数，子类清楚实例</span><br><span class="line">    */</span><br><span class="line">    virtual void ExitInstance();</span><br><span class="line"></span><br><span class="line">    /**线程开始运行，纯虚函数，子类必须继承实现</span><br><span class="line">    */</span><br><span class="line">    virtual void Run() = 0;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">     THREAD_HANDLE  m_hThread;  /**&lt; 线程句柄 */</span><br><span class="line">     DWORD          m_IDThread;</span><br><span class="line"></span><br><span class="line">};</span><br></pre></td></tr></table></figure><p><code>.cpp</code> 文件如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Thread.cpp</span><br><span class="line"> */</span><br><span class="line">#include "Thread.h"</span><br><span class="line"></span><br><span class="line">#ifdef WIN32</span><br><span class="line">DWORD WINAPI CThread::_ThreadEntry(LPVOID pParam)</span><br><span class="line">#else</span><br><span class="line">void* CThread::_ThreadEntry(void* pParam)</span><br><span class="line">#endif</span><br><span class="line">{</span><br><span class="line">    CThread *pThread = (CThread *)pParam;</span><br><span class="line">    if(pThread-&gt;InitInstance())</span><br><span class="line">    {</span><br><span class="line">        pThread-&gt;Run();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    pThread-&gt;ExitInstance();</span><br><span class="line"></span><br><span class="line">    return NULL;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">CThread::CThread()</span><br><span class="line">{</span><br><span class="line">    m_hThread = (THREAD_HANDLE)0;</span><br><span class="line">    m_IDThread = 0;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">CThread::~CThread()</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool CThread::Create()</span><br><span class="line">{</span><br><span class="line">    if (m_hThread != (THREAD_HANDLE)0)</span><br><span class="line">    {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">    bool ret = true;</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    m_hThread = ::CreateThread(NULL,0,_ThreadEntry,this,0,&amp;m_IDThread);</span><br><span class="line">    if(m_hThread==NULL)</span><br><span class="line">    {</span><br><span class="line">        ret = false;</span><br><span class="line">    }</span><br><span class="line">#else</span><br><span class="line">    ret = (::pthread_create(&amp;m_hThread,NULL,&amp;_ThreadEntry , this) == 0);</span><br><span class="line">#endif</span><br><span class="line">    return ret;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool CThread::InitInstance()</span><br><span class="line">{</span><br><span class="line">    return true;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void CThread::ExitInstance()</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void CThread::OSSleep(int seconds)</span><br><span class="line">{</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    ::Sleep(seconds*1000);</span><br><span class="line">#else</span><br><span class="line">    ::sleep(seconds);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void CThread::SleepMs(int nMilliseconds)</span><br><span class="line">{</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    ::Sleep(nMilliseconds);</span><br><span class="line">#else</span><br><span class="line">    ::usleep(nMilliseconds);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool CThread::IsCurrentThread()</span><br><span class="line">{</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    return ::GetCurrentThreadId() == m_IDThread;</span><br><span class="line">#else</span><br><span class="line">    return ::pthread_self() == m_hThread;</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">bool CThread::Join()</span><br><span class="line">{    </span><br><span class="line">    THREAD_HANDLE hThread = GetHandle();</span><br><span class="line">    if(hThread == (THREAD_HANDLE)0)</span><br><span class="line">    {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    return (WaitForSingleObject(hThread,INFINITE) != 0);</span><br><span class="line">#else</span><br><span class="line">    return (pthread_join(hThread, NULL) == 0);</span><br><span class="line">#endif</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void CThread::ExitThread()</span><br><span class="line">{</span><br><span class="line">#ifdef WIN32</span><br><span class="line">    ::ExitThread(0);</span><br><span class="line">#else</span><br><span class="line">#endif</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码 <code>CThread</code> 类封装了一个线程的常用的操作，使用宏 <code>WIN32</code> 来分别实现了 <code>Windows</code> 和 <code>Linux</code> 两个操作系统平台的线程操作。其中 <code>InitInstance</code> 和 <code>ExitInstance</code> 方法为虚函数，在继承 <code>CThread</code> 的子类中可以改写这两个方法，根据实际需要在线程函数正式业务逻辑前后做一些初始化和反初始化工作，而纯虚接口 Run 方法必须改写，改写成您的线程实际执行函数。</p><p>在线程函数中通过在创建线程时（调用 <code>CreateThread</code> 或 <code>pthread_create</code> 方法）时，将当前对象的 <code>this</code> 指针作为线程的函数的唯一参数传入，这样在线程函数中，可以通过线程函数参数得到对象的指针，通过这个指针就可以自由访问类的实例方法了。<strong>这一技巧非常常用，它广泛地用于各类开源 C++ 项目或者实际的商业 C++ 项目中，希望读者能理解并熟练掌握它。</strong></p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>如何等待线程结束</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-2/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-2/</id>
    <published>2021-10-18T04:31:43.000Z</published>
    <updated>2022-05-01T13:40:22.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-UrnSwZlR" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1826142553" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="如何等待线程结束"><a href="#如何等待线程结束" class="headerlink" title="如何等待线程结束"></a>如何等待线程结束</h1><p>前面课程介绍了创建线程，既然线程可以创建，线程也应该可以结束。那如何等待一个线程结束呢？</p><p>实际项目开发中，我们常常会有这样一种需求，即一个线程需要等待另外一个线程执行完任务退出后再继续执行。这在 Linux 和 Windows 操作系统中都提供了相应的操作系统 API，我们来分别介绍一下。</p><h2 id="Linux-下等待线程结束"><a href="#Linux-下等待线程结束" class="headerlink" title="Linux 下等待线程结束"></a>Linux 下等待线程结束</h2><p>Linux 线程库提供了 <code>pthread_join</code> 函数，用来等待某线程的退出并接收它的返回值。这种操作被称为连接（<code>joining</code>），<code>pthread_join</code> 函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int pthread_join(pthread_t thread, void** retval);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>thread</code>，需要等待的线程 id。</li><li>参数 <code>retval</code>，输出参数，用于接收等待退出的线程的退出码（<code>Exit Code</code>），线程退出码可以通过调用 <code>pthread_exit</code> 退出线程时指定，也可以在线程函数中通过 <code>return</code> 语句返回。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void pthread_exit(void* value_ptr);&amp;nbsp;</span><br></pre></td></tr></table></figure>参数 <code>value_ptr</code> 的值可以在 <code>pthread_join</code> 中拿到，没有可以设置为 <code>NULL</code>。</li></ul><p><strong><code>pthread_join</code> 函数等待其他线程退出期间会挂起等待的线程</strong>，被挂起的线程不会消耗宝贵任何 CPU 时间片。直到目标线程退出后，等待的线程会被唤醒。</p><p>我们通过一个实例来演示一下这个函数的使用方法，实例功能如下：</p><p>程序启动时，开启一个工作线程，工作线程将当前系统时间写入文件中后退出，主线程等待工作线程退出后，从文件中读取出时间并显示在屏幕上。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">#define TIME_FILENAME "time.txt"</span><br><span class="line"></span><br><span class="line">void* fileThreadFunc(void* arg)</span><br><span class="line">{</span><br><span class="line">    time_t now = time(NULL);</span><br><span class="line">    struct tm* t = localtime(&amp;now);</span><br><span class="line">    char timeStr[32] = {0};</span><br><span class="line">    snprintf(timeStr, 32, "%04d/%02d/%02d %02d:%02d:%02d", </span><br><span class="line">             t-&gt;tm_year+1900,</span><br><span class="line">             t-&gt;tm_mon+1,</span><br><span class="line">             t-&gt;tm_mday,</span><br><span class="line">             t-&gt;tm_hour,</span><br><span class="line">             t-&gt;tm_min,</span><br><span class="line">             t-&gt;tm_sec);</span><br><span class="line">    //文件不存在，则创建；存在，则覆盖</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "w");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">      printf("Failed to create time.txt.\n");</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size_t sizeToWrite = strlen(timeStr) + 1;</span><br><span class="line">    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);</span><br><span class="line">    if (ret != sizeToWrite)</span><br><span class="line">    {</span><br><span class="line">        printf("Write file error.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    pthread_t fileThreadID;</span><br><span class="line">    int ret = pthread_create(&amp;fileThreadID, NULL, fileThreadFunc, NULL);</span><br><span class="line">    if (ret != 0)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to create fileThread.\n");</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int* retval;</span><br><span class="line">    pthread_join(fileThreadID, (void**)&amp;retval);</span><br><span class="line"></span><br><span class="line">    //使用r选项，要求文件必须存在</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "r");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("open file error.\n");</span><br><span class="line">        return -2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    char buf[32] = {0};</span><br><span class="line">    int sizeRead = fread(buf, 1, 32, fp);</span><br><span class="line">    if (sizeRead == 0)</span><br><span class="line">    {</span><br><span class="line">      printf("read file error.\n");</span><br><span class="line">      return -3;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printf("Current Time is: %s.\n", buf);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost threadtest]# ./test</span><br><span class="line">Current Time is: 2018/09/24 21:06:01.</span><br></pre></td></tr></table></figure><h2 id="Windows-下等待线程结束"><a href="#Windows-下等待线程结束" class="headerlink" title="Windows 下等待线程结束"></a>Windows 下等待线程结束</h2><p>Windows 下使用 API <code>WaitForSingleObject</code> 或 <code>WaitForMultipleObjects</code> 函数，前者用于等待一个线程结束，后者可以同时等待多个线程结束。这是两个非常重要的函数，它们的作用不仅可以用于等待线程退出，还可以用于等待其他线程同步对象，本文后面的将详细介绍这两个函数。与 Linux 的 <code>pthread_join</code> 函数不同，Windows 的<code>WaitForSingleObject</code> 函数提供了可选择等待时间的精细控制。</p><p>这里我们仅演示等待线程退出。</p><p><code>WaitForSingleObject</code> 函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>hHandle</code> 是需要等待的对象的句柄，等待线程退出，传入线程句柄。</li><li>参数 <code>dwMilliseconds</code> 是需要等待的毫秒数，如果使用 <code>INFINITE</code> 宏，则表示无限等待下去。</li><li>返回值：该函数的返回值有点复杂，我们后面文章具体介绍。当 <code>dwMilliseconds</code> 参数使用 <code>INFINITE</code> 值，该函数会挂起当前等待线程，直到等待的线程退出后，等待的线程才会被唤醒，<code>WaitForSingleObject</code> 后的程序执行流继续执行。<br>我们将上面的 Linux 示例代码改写成 Windows 版本的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">#define TIME_FILENAME "time.txt"</span><br><span class="line"></span><br><span class="line">DWORD WINAPI FileThreadFunc(LPVOID lpParameters)</span><br><span class="line">{</span><br><span class="line">    time_t now = time(NULL);</span><br><span class="line">    struct tm* t = localtime(&amp;now);</span><br><span class="line">    char timeStr[32] = { 0 };</span><br><span class="line">    sprintf_s(timeStr, 32, "%04d/%02d/%02d %02d:%02d:%02d",</span><br><span class="line">              t-&gt;tm_year + 1900,</span><br><span class="line">              t-&gt;tm_mon + 1,</span><br><span class="line">              t-&gt;tm_mday,</span><br><span class="line">              t-&gt;tm_hour,</span><br><span class="line">              t-&gt;tm_min,</span><br><span class="line">              t-&gt;tm_sec);</span><br><span class="line">    //文件不存在，则创建；存在，则覆盖</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "w");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to create time.txt.\n");</span><br><span class="line">        return 1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size_t sizeToWrite = strlen(timeStr) + 1;</span><br><span class="line">    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);</span><br><span class="line">    if (ret != sizeToWrite)</span><br><span class="line">    {</span><br><span class="line">        printf("Write file error.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    return 2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    DWORD dwFileThreadID;</span><br><span class="line">    HANDLE hFileThread = CreateThread(NULL, 0, FileThreadFunc, NULL, 0, </span><br><span class="line">                                      &amp;dwFileThreadID);</span><br><span class="line">    if (hFileThread == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to create fileThread.\n");</span><br><span class="line">        return -1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //无限等待，直到文件线程退出，否则程序将一直挂起</span><br><span class="line">    WaitForSingleObject(hFileThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    //使用r选项，要求文件必须存在</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "r");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("open file error.\n");</span><br><span class="line">        return -2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    char buf[32] = { 0 };</span><br><span class="line">    int sizeRead = fread(buf, 1, 32, fp);</span><br><span class="line">    if (sizeRead == 0)</span><br><span class="line">    {</span><br><span class="line">        printf("read file error.\n");</span><br><span class="line">        return -3;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printf("Current Time is: %s.\n", buf);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>与 Linux 版本一样，我们得到类似的程序执行结果：</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded4.700vsr4a9js0.jpg" alt="multithreaded4"></p><h2 id="C-11-提供的等待线程结果函数"><a href="#C-11-提供的等待线程结果函数" class="headerlink" title="C++ 11 提供的等待线程结果函数"></a>C++ 11 提供的等待线程结果函数</h2><p>可以想到，<code>C++ 11</code> 的 <code>std::thread</code> 既然统一了 Linux 和 Windows 的线程创建函数，那么它应该也提供等待线程退出的接口，确实如此，<code>std::thread</code> 的 <code>join</code> 方法就是用来等待线程退出的函数。当然使用这个函数时，必须保证该线程还处于运行中状态，也就是说等待的线程必须是可以 “<code>join</code>”的，如果需要等待的线程已经退出，此时调用<code>join</code> 方法，程序会产生崩溃。因此，<code>C++ 11</code> 的线程库同时提供了一个 <code>joinable</code> 方法来判断某个线程是否可以 <code>join</code>，如果不确定线程是否可以“<code>join</code>”，可以先调用 <code>joinable</code> 函数判断一下是否需要等待。</p><p>还是以上面的例子为例，改写成 <code>C++11</code> 的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">#define TIME_FILENAME "time.txt"</span><br><span class="line"></span><br><span class="line">void FileThreadFunc()</span><br><span class="line">{</span><br><span class="line">    time_t now = time(NULL);</span><br><span class="line">    struct tm* t = localtime(&amp;now);</span><br><span class="line">    char timeStr[32] = { 0 };</span><br><span class="line">    sprintf_s(timeStr, 32, "%04d/%02d/%02d %02d:%02d:%02d",</span><br><span class="line">              t-&gt;tm_year + 1900,</span><br><span class="line">              t-&gt;tm_mon + 1,</span><br><span class="line">              t-&gt;tm_mday,</span><br><span class="line">              t-&gt;tm_hour,</span><br><span class="line">              t-&gt;tm_min,</span><br><span class="line">              t-&gt;tm_sec);</span><br><span class="line">    //文件不存在，则创建；存在，则覆盖</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "w");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to create time.txt.\n");</span><br><span class="line">        return;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    size_t sizeToWrite = strlen(timeStr) + 1;</span><br><span class="line">    size_t ret = fwrite(timeStr, 1, sizeToWrite, fp);</span><br><span class="line">    if (ret != sizeToWrite)</span><br><span class="line">    {</span><br><span class="line">        printf("Write file error.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    fclose(fp);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::thread t(FileThreadFunc);</span><br><span class="line">    if (t.joinable())</span><br><span class="line">        t.join();</span><br><span class="line"></span><br><span class="line">    //使用 r 选项，要求文件必须存在</span><br><span class="line">    FILE* fp = fopen(TIME_FILENAME, "r");</span><br><span class="line">    if (fp == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("open file error.\n");</span><br><span class="line">        return -2;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    char buf[32] = { 0 };</span><br><span class="line">    int sizeRead = fread(buf, 1, 32, fp);</span><br><span class="line">    if (sizeRead == 0)</span><br><span class="line">    {</span><br><span class="line">        printf("read file error.\n");</span><br><span class="line">        return -3;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    printf("Current Time is: %s.\n", buf);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 A 线程等待 B 线程结束，相当于 A 线程和 B 线程在该点汇集（或连接），这就是 <code>join</code> 函数的语义来源，因此很多其他编程语言也使用 <code>join</code> 一词表示等待线程结束。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程 ID 的用途及原理</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-1/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-1/</id>
    <published>2021-10-18T04:13:20.000Z</published>
    <updated>2022-05-01T13:40:22.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-YeCIuBDw" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1361335791" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程-ID-的用途及原理"><a href="#线程-ID-的用途及原理" class="headerlink" title="线程 ID 的用途及原理"></a>线程 ID 的用途及原理</h1><p>前面介绍了如何创建一个线程，本讲我们来介绍一下线程 ID 的内容，线程 ID 一般是用于标识一个线程的整形数值。</p><h2 id="线程-ID"><a href="#线程-ID" class="headerlink" title="线程 ID"></a>线程 ID</h2><p>一个线程创建成功以后，我们可以拿到一个线程 ID。我们可以使用线程 ID 来标识和区分线程，例如在日志文件中，把打印日志的所在的线程 ID 也一起打印出来，我们通过线程 ID 来确定日志内容是不是属于同一个线程上下文。创建线程时，上文也介绍了可以通过 <code>pthread_create</code> 函数的第一个参数 <code>thread</code> （linux平台）和 <code>CreateThread</code> 函数的最后一个参数 <code>lpThreadId</code> （Windows平台）得到线程的 ID。大多数时候，我们需要在当前调用线程中获取当前线程的 ID，在 Linux 平台上可以使用 <code>pthread_self</code> 函数（还有另外两种方式，下问介绍），在 Windows 平台上可以使用 <code>GetCurrentThreadID</code> 函数获取，这两个函数的签名分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pthread_t pthread_self(void);</span><br><span class="line"></span><br><span class="line">DWORD GetCurrentThreadId();</span><br></pre></td></tr></table></figure><p>这两个函数比较简单，这里就不介绍了，无论是 <code>pthread_t</code> 还是 DWORD 类型，都是一个 32 位无符号整型值。</p><p>在 Windows 7 操作系统中可以在任务管理器中查看某个进程的线程数量：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded1.37epdcvvdt40.jpg" alt="multithreaded1"></p><p>上图中标红的一栏即每个进程的线程数量，例如对于 vmware-tray.exe 进程一共有三个线程。如果读者打开任务管理器没有看到<strong>线程数</strong>这一列，可以点击任务管理器的 <strong>【查看】</strong>- <strong>【选择列</strong>】菜单，在弹出的对话框中勾选<strong>线程数</strong>即可显示出<strong>线程数</strong>这一列。</p><h2 id="Linux-系统线程-ID-的本质"><a href="#Linux-系统线程-ID-的本质" class="headerlink" title="Linux 系统线程 ID 的本质"></a>Linux 系统线程 ID 的本质</h2><p>Linux 系统中有三种方式可以获取一个线程的 ID。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>调用 <code>pthread_create</code> 函数时，第一个参数在函数调用成功后可以得到线程 ID：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t tid;</span><br><span class="line">pthread_create(&amp;tid, NULL, thread_proc, NULL);</span><br></pre></td></tr></table></figure><p><code>pthread_create</code> 函数我们在前面篇幅中已经介绍过了。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>在需要获取 ID 的线程中调用 <code>pthread_self()</code> 函数获取。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">pthread_t tid = pthread_self();</span><br></pre></td></tr></table></figure><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>通过系统调用获取线程 ID</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int tid = syscall(SYS_gettid);</span><br></pre></td></tr></table></figure><p><strong>方法一</strong>和<strong>方法二</strong>获取的线程 ID 结果是一样的，这是一个 <code>pthread_t</code>，输出时本质上是一块内存空间地址，示意图如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded2.4kg2ddtsxea0.jpg" alt="multithreaded2"></p><p>由于不同的进程可能有同样地址的内存块，因此<strong>方法一</strong>和<strong>方法二</strong>获取的线程 ID 可能不是全系统唯一的，一般是一个很大的数字（内存地址）。而<strong>方法三</strong>获取的线程 ID 是系统范围内全局唯一的，一般是一个不会太大的整数，这个数字也是就是所谓的 <code>LWP</code> （<code>Light Weight Process</code>，轻量级进程，早期的 Linux 系统的线程是通过进程来实现的，这种线程被称为轻量级线程）的 ID。</p><p>我们来看一段具体的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys/syscall.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">void* thread_proc(void* arg)</span><br><span class="line">{</span><br><span class="line">    pthread_t* tid1 = (pthread_t*)arg;</span><br><span class="line">    int tid2 = syscall(SYS_gettid);</span><br><span class="line">    pthread_t tid3 = pthread_self();</span><br><span class="line"></span><br><span class="line">    while(true)</span><br><span class="line">    {</span><br><span class="line">        printf("tid1: %ld, tid2: %ld, tid3: %ld\n", *tid1, tid2, tid3);</span><br><span class="line">        sleep(1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{    </span><br><span class="line">    pthread_t tid;</span><br><span class="line">    pthread_create(&amp;tid, NULL, thread_proc, &amp;tid);</span><br><span class="line"></span><br><span class="line">    pthread_join(tid, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码在新开的线程中使用上面介绍的三种方式获取线程 ID，并打印出来，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tid1: 140185007511296, tid2: 60837, tid3: 140185007511296</span><br></pre></td></tr></table></figure><p><code>tid2</code> 即 <code>LWP</code> 的 ID，而 <code>tid1</code> 和 <code>tid3</code> 是一个内存地址，转换成 16 进制即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7F7F5D935700</span><br></pre></td></tr></table></figure><p>这与我们用 <code>pstack</code> 命令看到的线程 ID 是一样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ps -efL | grep linuxtid</span><br><span class="line">root     60712 60363 60712  0    2 13:25 pts/1    00:00:00 ./linuxtid</span><br><span class="line">root     60712 60363 60713  0    2 13:25 pts/1    00:00:00 ./linuxtid</span><br><span class="line">root     60720 60364 60720  0    1 13:25 pts/3    00:00:00 grep --color=auto linuxtid</span><br><span class="line">[root@localhost ~]# pstack 60712</span><br><span class="line">Thread 2 (Thread 0x7fd897a50700 (LWP 60713)):</span><br><span class="line">#0  0x00007fd897b15e2d in nanosleep () from /lib64/libc.so.6</span><br><span class="line">#1  0x00007fd897b15cc4 in sleep () from /lib64/libc.so.6</span><br><span class="line">#2  0x0000000000400746 in thread_proc (arg=0x7fff390921c8) at linuxtid.cpp:15</span><br><span class="line">#3  0x00007fd898644dd5 in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#4  0x00007fd897b4eead in clone () from /lib64/libc.so.6</span><br><span class="line">Thread 1 (Thread 0x7fd898a6e740 (LWP 60712)):</span><br><span class="line">#0  0x00007fd898645f47 in pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x000000000040077e in main () at linuxtid.cpp:25</span><br><span class="line">[root@localhost ~]# ps -ef | grep linuxtid</span><br><span class="line">root     60838 60363  0 14:27 pts/1    00:00:00 ./linuxtid</span><br><span class="line">root     60846 60364  0 14:28 pts/3    00:00:00 grep --color=auto linuxtid</span><br><span class="line">[root@localhost ~]# pstack 60838</span><br><span class="line">Thread 2 (Thread 0x7f7f5d935700 (LWP 60839)):</span><br><span class="line">#0  0x00007f7f5d9fae2d in nanosleep () from /lib64/libc.so.6</span><br><span class="line">#1  0x00007f7f5d9facc4 in sleep () from /lib64/libc.so.6</span><br><span class="line">#2  0x0000000000400746 in thread_proc (arg=0x7fff0523ae68) at linuxtid.cpp:15</span><br><span class="line">#3  0x00007f7f5e529dd5 in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#4  0x00007f7f5da33ead in clone () from /lib64/libc.so.6</span><br><span class="line">Thread 1 (Thread 0x7f7f5e953740 (LWP 60838)):</span><br><span class="line">#0  0x00007f7f5e52af47 in pthread_join () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x000000000040077e in main () at linuxtid.cpp:25</span><br></pre></td></tr></table></figure><h2 id="C-11-的获取当前线程-ID-的方法"><a href="#C-11-的获取当前线程-ID-的方法" class="headerlink" title="C++11 的获取当前线程 ID 的方法"></a>C++11 的获取当前线程 ID 的方法</h2><p><code>C++11</code> 的线程库可以使用 <code>std::thisthread</code> 类的 <code>getid</code> 获取当前线程的 id，这是一个类静态方法。</p><p>当然也可以使用 <code>std::thread</code> 的 <code>get_id</code> 获取指定线程的 id，这是一个类实例方法。</p><p>但是 <code>get_id</code> 方法返回的是一个包装类型的 <code>std::thread::id</code> 对象，不可以直接强转成整型，也没有提供任何转换成整型的接口。所以，我们一般使用 <code>std::cout</code> 这样的输出流来输出，或者先转换为 <code>std::ostringstream</code> 对象，再转换成字符串类型，然后把字符串类型转换成我们需要的整型。这一点，个人觉得算是 <code>C++11</code> 线程库获取线程 id 一个不太方便的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//test_cpp11_thread_id.cpp</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"></span><br><span class="line">void worker_thread_func()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    std::thread t(worker_thread_func);</span><br><span class="line">    //获取线程 t 的 ID</span><br><span class="line">    std::thread::id worker_thread_id = t.get_id();</span><br><span class="line">    std::cout &lt;&lt; "worker thread id: " &lt;&lt; worker_thread_id &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    //获取主线程的线程 ID</span><br><span class="line">    std::thread::id main_thread_id = std::this_thread::get_id();</span><br><span class="line">    //先将 std::thread::id 转换成 std::ostringstream 对象</span><br><span class="line">    std::ostringstream oss;</span><br><span class="line">    oss &lt;&lt; main_thread_id;</span><br><span class="line">    //再将 std::ostringstream 对象转换成std::string</span><br><span class="line">    std::string str = oss.str();</span><br><span class="line">    std::cout &lt;&lt; "main thread id: " &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    //最后将 std::string 转换成整型值</span><br><span class="line">    unsigned long long threadid = std::stoull(str);</span><br><span class="line">    std::cout &lt;&lt; "main thread id: " &lt;&lt; threadid &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在 Linux x64 系统上编译并运行程序，输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@myaliyun codes]# g++ -g -o test_cpp11_thread_id test_cpp11_thread_id.cpp -lpthread</span><br><span class="line">[root@myaliyun codes]# ./test_cpp11_thread_id </span><br><span class="line">worker thread id: 139875808245504</span><br><span class="line">main thread id: 139875825641280</span><br><span class="line">main thread id: 139875825641280</span><br></pre></td></tr></table></figure><p>编译成 Windows x86 程序运行结果如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20210918/multithreaded3.3o0vg5lx5tk0.jpg" alt="multithreaded3"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>线程 ID 在实际编码中是一个很重要的上下文信息，因此熟练地获取某个线程的线程 ID，是多线程编程的基本功之一。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程的创建与使用</title>
    <link href="http://example.com/2021/10/18/CPP-multithreaded-0/"/>
    <id>http://example.com/2021/10/18/CPP-multithreaded-0/</id>
    <published>2021-10-18T03:55:34.000Z</published>
    <updated>2022-05-01T13:40:22.711Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4>    <div id="aplayer-JInkaTdK" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1473972374" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程的创建与使用"><a href="#线程的创建与使用" class="headerlink" title="线程的创建与使用"></a>线程的创建与使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a><strong>线程的创建</strong></h2><p>在使用线程之前，我们首先要学会如何创建一个新的线程。不管是哪个库还是哪种高级语言（如 Java），线程的创建最终还是调用操作系统的 API 来进行的。我们这里先介绍操作系统的接口，这里分为 Linux 和 Windows 两个常用的操作系统平台来介绍。当然，这里并不是照本宣科地把 Linux man 手册或者 msdn 上的函数签名搬过来，而是只介绍我们实际开发中常用的参数和需要注意的重难点。</p><h2 id="Linux-线程创建"><a href="#Linux-线程创建" class="headerlink" title="Linux 线程创建"></a>Linux 线程创建</h2><p>Linux 平台上使用 <strong>pthread_create</strong> 这个 API 来创建线程，其函数签名如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line">                   const pthread_attr_t *attr,</span><br><span class="line">                   void *(*start_routine) (void *), </span><br><span class="line">                   void *arg);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>thread</code>，是一个输出参数，如果线程创建成功，则通过这个参数可以得到创建成功的线程 ID（下文会介绍线程 ID 的知识）。</li><li>参数 <code>attr</code> 指定了该线程的属性，一般设置为 NULL，表示使用默认属性。</li><li>参数 <code>start_routine</code> 指定了线程函数，这里需要注意的是这个函数的调用方式必须是 <code>__cdecl</code> 调用，即 <code>C Declaration</code> 的缩写，这是 C/C++ 中定义函数时默认的调用方式，一般很少有人注意到这一点。而后面我们介绍在 Windows 操作系统上使用 <code>CreateThread</code> 定义线程函数时必须使用 <code>__stdcall</code> 调用方式时，由于函数不是默认函数调用方式，所以我们必须显式声明函数的调用方式了。<br>  也就是说，如下函数的调用方式是等价的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//代码片段1： 不显式指定函数调用方式，其调用方式为默认的 __cdecl</span><br><span class="line">void* start_routine (void* args)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//代码片段2： 显式指定函数调用方式为默认的 __cdecl，等价于代码片段1</span><br><span class="line">void* __cdecl start_routine (void* args)</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>参数 <code>arg</code>，通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个 <code>void*</code> 类型，可以方便我们最大化地传入任意多的信息给线程函数（下文会介绍一个使用示例）。</li><li>返回值：如果成功创建线程，则返回 <code>0</code>；如果创建失败，则返回相应的错误码。常见的错误码有 <code>EAGAIN</code>、<code>EINVAL</code>。<code>EAGAIN</code> 表示系统资源不足导致线程无法创建（如达到系统限制的最大线程数目），<code>EINVAL</code> 表示传入了无效的参数 <code>attr</code>。在实际开发只要我们正确的设置了各个参数，一般不关心该函数的返回值，即一般认为线程可以正确创建出来。</li></ul><p>下面是一个使用 <strong>pthread_create</strong> 创建线程的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadfunc(void* arg)</span><br><span class="line">{</span><br><span class="line">  while(1)</span><br><span class="line">  {</span><br><span class="line">    //睡眠1秒</span><br><span class="line">    sleep(1);</span><br><span class="line"></span><br><span class="line">    printf("I am New Thread!\n");</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">  pthread_t threadid;</span><br><span class="line">  pthread_create(&amp;threadid, NULL, threadfunc, NULL);</span><br><span class="line"></span><br><span class="line">  while (1)</span><br><span class="line">  {</span><br><span class="line">    sleep(1);</span><br><span class="line">    //权宜之计，让主线程不要提前退出</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>pthread_create</code> 函数在主线程创建了一个工作线程，线程函数为 <code>threadfunc</code>。</p><h2 id="Windows-线程创建"><a href="#Windows-线程创建" class="headerlink" title="Windows 线程创建"></a>Windows 线程创建</h2><p>Windows 上创建线程使用 <strong>CreateThread</strong>，其函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateThread(</span><br><span class="line">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span><br><span class="line">  SIZE_T                  dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE  lpStartAddress,</span><br><span class="line">  LPVOID                  lpParameter,</span><br><span class="line">  DWORD                   dwCreationFlags,</span><br><span class="line">  LPDWORD                 lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>lpThreadAttributes</code>，是线程的安全属性，一般设置为 <code>NULL</code>。</li><li>参数 <code>dwStackSize</code>，线程的栈空间大小，单位为字节数，一般指定为 <code>0</code>，表示使用默认大小。</li><li>参数 <code>lpStartAddress</code>，为线程函数，其类型是 <code>LPTHREAD_START_ROUTINE</code>，这是一个函数指针类型，其定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，Windows 上创建的线程的线程函数其调用方式必须是<code>__stdcall</code>，如果将如下函数设置成线程函数是不行的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure>如上文所说，如果不指定函数的调用方式，使用默认调用方式 <code>__cdecl</code>，而这里的线程函数要求是 <code>__stdcall</code>，因此必须在函数名前面显式指定函数调用方式为 <code>__stdcall</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD __stdcall threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure>Windows 上的宏 <code>WINAPI</code> 和 <code>CALLBACK</code> 这两个宏的定义都是 <code>__stdcall</code>。因为在项目中看到的线程函数的签名大多写成如下两种形式的一种：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//写法1</span><br><span class="line">DWORD WINAPI threadfunc(LPVOID lpThreadParameter);</span><br><span class="line">//写法2</span><br><span class="line">DWORD CALLBACK threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure></li><li>参数 <code>lpParameter</code> 为传给线程函数的参数，和 Linux 下的 <code>pthread_create</code> 函数的 <code>arg</code> 一样，这实际上也是一个 void* 类型（LPVOID 类型是用 typedef 包装后的 void* 类型）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void* LPVOID;</span><br></pre></td></tr></table></figure></li><li>参数 <code>dwCreationFlags</code>，是一个 32 位无符号整型（DWORD），一般设置为 0，表示创建好线程后立即启动线程的运行；有一些特殊的情况，我们不希望创建线程后立即开始执行，可以将这个值设置为 4（对应 Windows 定义的宏 <code>CREATE_SUSPENDED</code>），后面在需要的时候，再使用 <code>ResumeThread</code> 这个 API 让线程运行起来。</li><li>参数 <code>lpThreadId</code>，为线程创建成功返回的线程 ID，这也是一个 32 位无符号整数（DWORD）的指针（LPDWORD）。</li><li>返回值：Windows 上使用句柄（HANDLE 类型）来管理线程对象，句柄本质上是内核句柄表中的索引值。如果成功创建线程，则返回该线程的句柄；如果创建失败，则返回 NULL。</li></ul><p>下面的代码片段，演示了 Windows 上如何创建一个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc(LPVOID lpParameters)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //睡眠 1 秒，Windows 上的 Sleep 函数参数事件单位为毫秒</span><br><span class="line">        Sleep(1000);</span><br><span class="line"></span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    DWORD dwThreadID;</span><br><span class="line">    HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &amp;dwThreadID);</span><br><span class="line">    if (hThread == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to CreateThread.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>CreateThread</code> 函数在主线程创建了一个工作线程，线程函数为 <code>ThreadProc</code>，线程函数名 <code>ThreadProc</code> 符合 Windows 程序设计风格。</p><h2 id="Windows-CRT-提供的线程创建函数"><a href="#Windows-CRT-提供的线程创建函数" class="headerlink" title="Windows CRT 提供的线程创建函数"></a>Windows CRT 提供的线程创建函数</h2><p>这里的 <code>CRT</code>，指的是 <code>C Runtime</code>（C 运行时），通俗地说就是 C 函数库。在 Windows 操作系统上，微软实现的 C 库也提供了一套用于创建线程的函数（当然这个函数底层还是调用相应的操作系统平台的线程创建 API）。<strong>在实际项目开发中推荐使用这个函数来创建线程而不是使用 <code>CreateThread</code> 函数。</strong></p><p>Windows C 库创建线程常用的函数是 <code>_beginthreadex</code>，声明位于 <code>process.h</code> 头文件中，其签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t _beginthreadex( </span><br><span class="line">   void *security,  </span><br><span class="line">   unsigned stack_size,  </span><br><span class="line">   unsigned ( __stdcall *start_address )( void * ),  </span><br><span class="line">   void *arglist,  </span><br><span class="line">   unsigned initflag,  </span><br><span class="line">   unsigned *thrdaddr   </span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>函数签名基本上和 Windows 上的 <code>CreateThread</code> 函数基本一致，这里就不再赘述了。</p><p>以下是使用 <code>_beginthreadex</code> 创建线程的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;process.h&gt;</span><br><span class="line">//#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int __stdcall threadfun(void* args)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {        </span><br><span class="line">        //Sleep(1000);</span><br><span class="line"></span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">{</span><br><span class="line">    unsigned int threadid;</span><br><span class="line">    _beginthreadex(0, 0, threadfun, 0, 0, &amp;threadid);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>_beginthreadex</code> 函数在主线程创建了一个工作线程，线程函数为 <code>threadfun</code>。</p><h2 id="C-11-提供的-std-thread-类"><a href="#C-11-提供的-std-thread-类" class="headerlink" title="C++ 11 提供的 std::thread 类"></a>C++ 11 提供的 std::thread 类</h2><p>无论是 Linux 还是 Windows 上创建线程的 API，都有一个非常不方便的地方，就是线程函数的签名必须是固定的格式（参数个数和类型、返回值类型都有要求）。<code>C++11</code> 新标准引入了一个新的类 <code>std::thread</code>（需要包含头文件 <code>&lt;thread&gt;</code>），使用这个类的可以将任何签名形式的函数作为线程函数。以下代码分别创建两个线程，线程函数签名不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void threadproc1()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread 1!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void threadproc2(int a, int b)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread 2!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //创建线程t1</span><br><span class="line">    std::thread t1(threadproc1);</span><br><span class="line">    //创建线程t2</span><br><span class="line">    std::thread t2(threadproc2, 1, 2);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当然， <code>std::thread</code> 在使用上容易犯一个错误，即在 <code>std::thread</code> 对象在线程函数运行期间必须是有效的。什么意思呢？我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void threadproc()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::thread t(threadproc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码在 <code>func</code> 中创建了一个线程，然后又在 <code>main</code> 函数中调用 <code>func</code> 方法，乍一看好像代码没什么问题，但是在实际运行时程序会崩溃。崩溃的原因是，当 <code>func</code> 函数调用结束后，<code>func</code> 中局部变量 <code>t</code> （线程对象）被销毁了，而此时线程函数仍然在运行。这就是我所说的，使用 <code>std::thread</code> 类时，必须保证线程函数运行期间，其线程对象有效。这是一个很容易犯的错误，解决这个问题的方法是，<code>std::thread</code> 对象提供了一个 <code>detach</code> 方法，这个方法让线程对象与线程函数脱离关系，这样即使线程对象被销毁，仍然不影响线程函数的运行。我们只需要在 <code>func</code> 函数中调用 <code>detach</code> 方法即可，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//其他代码保持不变，这里就不重复贴出来了</span><br><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::thread t(threadproc);</span><br><span class="line">    t.detach();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然而，在实际编码中，这也是一个不推荐的做法，原因是我们需要使用线程对象去控制和管理线程的运行和生命周期。所以，我们的代码应该尽量保证线程对象在线程运行期间有效，而不是单纯地调用 <code>detach</code> 方法使线程对象与线程函数的运行分离。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本讲介绍了 Linux 和 Windows 平台的线程创建基础 API，同时也介绍了 <code>CRT</code> 和 <code>C++ 11</code> 语言标准提供的创建线程的方法（它们可以方便我们写跨平台代码），但是读者一定要明白 <code>CRT </code>和 <code>C++ 11</code> 创建线程的函数其实现是在对应的操作系统平台调用我们介绍的线程创建函数。</p><hr><p><a class="link" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="C/C++ 多线程编程精髓" scheme="http://example.com/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/"/>
    
    
    <category term="Linux" scheme="http://example.com/tags/Linux/"/>
    
    <category term="Windows" scheme="http://example.com/tags/Windows/"/>
    
    <category term="C++ 开发" scheme="http://example.com/tags/C-%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
