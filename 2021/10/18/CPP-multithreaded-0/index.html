<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="blog"><meta name="author" content="白羽近墨"><title>线程的创建与使用 | 白羽小站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/mylogo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/author.svg",favicon:"/images/mylogo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"种一棵树，最好的时间是十年前,其次是现在。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="baiyu" type="application/atom+xml">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/mylogo.svg"> </a><a class="logo-title" href="/">白羽小站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">线程的创建与使用</span></div><div class="article-header"><div class="avatar"><img src="/images/author.svg"></div><div class="info"><div class="author"><span class="name">白羽近墨</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-10-18 11:55:34</span> <span class="mobile">2021-10-18 11:55</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/C-C-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%B2%BE%E9%AB%93/">C/C++ 多线程编程精髓</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/Windows/">Windows</a>&nbsp;</li><li>| <a href="/tags/C-%E5%BC%80%E5%8F%91/">C++ 开发</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>2.6k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>10 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4><div id="aplayer-JInkaTdK" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1473972374" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="线程的创建与使用"><a href="#线程的创建与使用" class="headerlink" title="线程的创建与使用"></a>线程的创建与使用</h1><h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a><strong>线程的创建</strong></h2><p>在使用线程之前，我们首先要学会如何创建一个新的线程。不管是哪个库还是哪种高级语言（如 Java），线程的创建最终还是调用操作系统的 API 来进行的。我们这里先介绍操作系统的接口，这里分为 Linux 和 Windows 两个常用的操作系统平台来介绍。当然，这里并不是照本宣科地把 Linux man 手册或者 msdn 上的函数签名搬过来，而是只介绍我们实际开发中常用的参数和需要注意的重难点。</p><h2 id="Linux-线程创建"><a href="#Linux-线程创建" class="headerlink" title="Linux 线程创建"></a>Linux 线程创建</h2><p>Linux 平台上使用 <strong>pthread_create</strong> 这个 API 来创建线程，其函数签名如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int pthread_create(pthread_t *thread, </span><br><span class="line">                   const pthread_attr_t *attr,</span><br><span class="line">                   void *(*start_routine) (void *), </span><br><span class="line">                   void *arg);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>thread</code>，是一个输出参数，如果线程创建成功，则通过这个参数可以得到创建成功的线程 ID（下文会介绍线程 ID 的知识）。</li><li>参数 <code>attr</code> 指定了该线程的属性，一般设置为 NULL，表示使用默认属性。</li><li>参数 <code>start_routine</code> 指定了线程函数，这里需要注意的是这个函数的调用方式必须是 <code>__cdecl</code> 调用，即 <code>C Declaration</code> 的缩写，这是 C/C++ 中定义函数时默认的调用方式，一般很少有人注意到这一点。而后面我们介绍在 Windows 操作系统上使用 <code>CreateThread</code> 定义线程函数时必须使用 <code>__stdcall</code> 调用方式时，由于函数不是默认函数调用方式，所以我们必须显式声明函数的调用方式了。<br>也就是说，如下函数的调用方式是等价的：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//代码片段1： 不显式指定函数调用方式，其调用方式为默认的 __cdecl</span><br><span class="line">void* start_routine (void* args)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">//代码片段2： 显式指定函数调用方式为默认的 __cdecl，等价于代码片段1</span><br><span class="line">void* __cdecl start_routine (void* args)</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>参数 <code>arg</code>，通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个 <code>void*</code> 类型，可以方便我们最大化地传入任意多的信息给线程函数（下文会介绍一个使用示例）。</li><li>返回值：如果成功创建线程，则返回 <code>0</code>；如果创建失败，则返回相应的错误码。常见的错误码有 <code>EAGAIN</code>、<code>EINVAL</code>。<code>EAGAIN</code> 表示系统资源不足导致线程无法创建（如达到系统限制的最大线程数目），<code>EINVAL</code> 表示传入了无效的参数 <code>attr</code>。在实际开发只要我们正确的设置了各个参数，一般不关心该函数的返回值，即一般认为线程可以正确创建出来。</li></ul><p>下面是一个使用 <strong>pthread_create</strong> 创建线程的简单示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void* threadfunc(void* arg)</span><br><span class="line">{</span><br><span class="line">  while(1)</span><br><span class="line">  {</span><br><span class="line">    //睡眠1秒</span><br><span class="line">    sleep(1);</span><br><span class="line"></span><br><span class="line">    printf("I am New Thread!\n");</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">  pthread_t threadid;</span><br><span class="line">  pthread_create(&amp;threadid, NULL, threadfunc, NULL);</span><br><span class="line"></span><br><span class="line">  while (1)</span><br><span class="line">  {</span><br><span class="line">    sleep(1);</span><br><span class="line">    //权宜之计，让主线程不要提前退出</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>pthread_create</code> 函数在主线程创建了一个工作线程，线程函数为 <code>threadfunc</code>。</p><h2 id="Windows-线程创建"><a href="#Windows-线程创建" class="headerlink" title="Windows 线程创建"></a>Windows 线程创建</h2><p>Windows 上创建线程使用 <strong>CreateThread</strong>，其函数签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE CreateThread(</span><br><span class="line">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span><br><span class="line">  SIZE_T                  dwStackSize,</span><br><span class="line">  LPTHREAD_START_ROUTINE  lpStartAddress,</span><br><span class="line">  LPVOID                  lpParameter,</span><br><span class="line">  DWORD                   dwCreationFlags,</span><br><span class="line">  LPDWORD                 lpThreadId</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>lpThreadAttributes</code>，是线程的安全属性，一般设置为 <code>NULL</code>。</li><li>参数 <code>dwStackSize</code>，线程的栈空间大小，单位为字节数，一般指定为 <code>0</code>，表示使用默认大小。</li><li>参数 <code>lpStartAddress</code>，为线程函数，其类型是 <code>LPTHREAD_START_ROUTINE</code>，这是一个函数指针类型，其定义如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是，Windows 上创建的线程的线程函数其调用方式必须是<code>__stdcall</code>，如果将如下函数设置成线程函数是不行的：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure>如上文所说，如果不指定函数的调用方式，使用默认调用方式 <code>__cdecl</code>，而这里的线程函数要求是 <code>__stdcall</code>，因此必须在函数名前面显式指定函数调用方式为 <code>__stdcall</code>。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD __stdcall threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure>Windows 上的宏 <code>WINAPI</code> 和 <code>CALLBACK</code> 这两个宏的定义都是 <code>__stdcall</code>。因为在项目中看到的线程函数的签名大多写成如下两种形式的一种：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//写法1</span><br><span class="line">DWORD WINAPI threadfunc(LPVOID lpThreadParameter);</span><br><span class="line">//写法2</span><br><span class="line">DWORD CALLBACK threadfunc(LPVOID lpThreadParameter);</span><br></pre></td></tr></table></figure></li><li>参数 <code>lpParameter</code> 为传给线程函数的参数，和 Linux 下的 <code>pthread_create</code> 函数的 <code>arg</code> 一样，这实际上也是一个 void* 类型（LPVOID 类型是用 typedef 包装后的 void* 类型）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef void* LPVOID;</span><br></pre></td></tr></table></figure></li><li>参数 <code>dwCreationFlags</code>，是一个 32 位无符号整型（DWORD），一般设置为 0，表示创建好线程后立即启动线程的运行；有一些特殊的情况，我们不希望创建线程后立即开始执行，可以将这个值设置为 4（对应 Windows 定义的宏 <code>CREATE_SUSPENDED</code>），后面在需要的时候，再使用 <code>ResumeThread</code> 这个 API 让线程运行起来。</li><li>参数 <code>lpThreadId</code>，为线程创建成功返回的线程 ID，这也是一个 32 位无符号整数（DWORD）的指针（LPDWORD）。</li><li>返回值：Windows 上使用句柄（HANDLE 类型）来管理线程对象，句柄本质上是内核句柄表中的索引值。如果成功创建线程，则返回该线程的句柄；如果创建失败，则返回 NULL。</li></ul><p>下面的代码片段，演示了 Windows 上如何创建一个线程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI ThreadProc(LPVOID lpParameters)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //睡眠 1 秒，Windows 上的 Sleep 函数参数事件单位为毫秒</span><br><span class="line">        Sleep(1000);</span><br><span class="line"></span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    DWORD dwThreadID;</span><br><span class="line">    HANDLE hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, &amp;dwThreadID);</span><br><span class="line">    if (hThread == NULL)</span><br><span class="line">    {</span><br><span class="line">        printf("Failed to CreateThread.\n");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>CreateThread</code> 函数在主线程创建了一个工作线程，线程函数为 <code>ThreadProc</code>，线程函数名 <code>ThreadProc</code> 符合 Windows 程序设计风格。</p><h2 id="Windows-CRT-提供的线程创建函数"><a href="#Windows-CRT-提供的线程创建函数" class="headerlink" title="Windows CRT 提供的线程创建函数"></a>Windows CRT 提供的线程创建函数</h2><p>这里的 <code>CRT</code>，指的是 <code>C Runtime</code>（C 运行时），通俗地说就是 C 函数库。在 Windows 操作系统上，微软实现的 C 库也提供了一套用于创建线程的函数（当然这个函数底层还是调用相应的操作系统平台的线程创建 API）。<strong>在实际项目开发中推荐使用这个函数来创建线程而不是使用 <code>CreateThread</code> 函数。</strong></p><p>Windows C 库创建线程常用的函数是 <code>_beginthreadex</code>，声明位于 <code>process.h</code> 头文件中，其签名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t _beginthreadex( </span><br><span class="line">   void *security,  </span><br><span class="line">   unsigned stack_size,  </span><br><span class="line">   unsigned ( __stdcall *start_address )( void * ),  </span><br><span class="line">   void *arglist,  </span><br><span class="line">   unsigned initflag,  </span><br><span class="line">   unsigned *thrdaddr   </span><br><span class="line">);  </span><br></pre></td></tr></table></figure><p>函数签名基本上和 Windows 上的 <code>CreateThread</code> 函数基本一致，这里就不再赘述了。</p><p>以下是使用 <code>_beginthreadex</code> 创建线程的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;process.h&gt;</span><br><span class="line">//#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">unsigned int __stdcall threadfun(void* args)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {        </span><br><span class="line">        //Sleep(1000);</span><br><span class="line"></span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">{</span><br><span class="line">    unsigned int threadid;</span><br><span class="line">    _beginthreadex(0, 0, threadfun, 0, 0, &amp;threadid);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码片段利用 <code>_beginthreadex</code> 函数在主线程创建了一个工作线程，线程函数为 <code>threadfun</code>。</p><h2 id="C-11-提供的-std-thread-类"><a href="#C-11-提供的-std-thread-类" class="headerlink" title="C++ 11 提供的 std::thread 类"></a>C++ 11 提供的 std::thread 类</h2><p>无论是 Linux 还是 Windows 上创建线程的 API，都有一个非常不方便的地方，就是线程函数的签名必须是固定的格式（参数个数和类型、返回值类型都有要求）。<code>C++11</code> 新标准引入了一个新的类 <code>std::thread</code>（需要包含头文件 <code>&lt;thread&gt;</code>），使用这个类的可以将任何签名形式的函数作为线程函数。以下代码分别创建两个线程，线程函数签名不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void threadproc1()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread 1!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void threadproc2(int a, int b)</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread 2!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    //创建线程t1</span><br><span class="line">    std::thread t1(threadproc1);</span><br><span class="line">    //创建线程t2</span><br><span class="line">    std::thread t2(threadproc2, 1, 2);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>当然， <code>std::thread</code> 在使用上容易犯一个错误，即在 <code>std::thread</code> 对象在线程函数运行期间必须是有效的。什么意思呢？我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void threadproc()</span><br><span class="line">{</span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        printf("I am New Thread!\n");</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::thread t(threadproc);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">{</span><br><span class="line">    func();</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    {</span><br><span class="line">        //Sleep(1000);</span><br><span class="line">        //权宜之计，让主线程不要提前退出</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>上述代码在 <code>func</code> 中创建了一个线程，然后又在 <code>main</code> 函数中调用 <code>func</code> 方法，乍一看好像代码没什么问题，但是在实际运行时程序会崩溃。崩溃的原因是，当 <code>func</code> 函数调用结束后，<code>func</code> 中局部变量 <code>t</code> （线程对象）被销毁了，而此时线程函数仍然在运行。这就是我所说的，使用 <code>std::thread</code> 类时，必须保证线程函数运行期间，其线程对象有效。这是一个很容易犯的错误，解决这个问题的方法是，<code>std::thread</code> 对象提供了一个 <code>detach</code> 方法，这个方法让线程对象与线程函数脱离关系，这样即使线程对象被销毁，仍然不影响线程函数的运行。我们只需要在 <code>func</code> 函数中调用 <code>detach</code> 方法即可，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//其他代码保持不变，这里就不重复贴出来了</span><br><span class="line">void func()</span><br><span class="line">{</span><br><span class="line">    std::thread t(threadproc);</span><br><span class="line">    t.detach();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>然而，在实际编码中，这也是一个不推荐的做法，原因是我们需要使用线程对象去控制和管理线程的运行和生命周期。所以，我们的代码应该尽量保证线程对象在线程运行期间有效，而不是单纯地调用 <code>detach</code> 方法使线程对象与线程函数的运行分离。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本讲介绍了 Linux 和 Windows 平台的线程创建基础 API，同时也介绍了 <code>CRT</code> 和 <code>C++ 11</code> 语言标准提供的创建线程的方法（它们可以方便我们写跨平台代码），但是读者一定要明白 <code>CRT</code>和 <code>C++ 11</code> 创建线程的函数其实现是在对应的操作系统平台调用我们介绍的线程创建函数。</p><hr><p><a class="link" target="_blank" rel="noopener" href="https://github.com/balloonwj/gitchat_cppmultithreadprogramming">点击这里下载课程源代码<i class="fas fa-external-link-alt"></i></a></p><p>来源:<a class="link" target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/column/5d11e726820bf61799b8277f">范蠡《C/C++ 多线程编程精髓》<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：线程的创建与使用</li><li>本文作者：白羽近墨</li><li>创建时间：2021-10-18 11:55:34</li><li>本文链接：https://keep.xpoet.cn/2021/10/18/CPP-multithreaded-0/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/Windows/">#Windows</a>&nbsp;</li><li class="tag-item"><a href="/tags/C-%E5%BC%80%E5%8F%91/">#C++ 开发</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/10/18/CPP-multithreaded-1/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">线程 ID 的用途及原理</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/10/17/Time-conversion/"><span class="title flex-center"><span class="post-nav-title-item">时间转换</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"irqOqaGORMEoxUV1bBigEGyr-gzGzoHsz",appKey:"Dkd9JB0KYotx5nS6IA6PKB6f",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="白羽近墨";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),r=n.innerHTML;r===t&&(n.innerHTML=`${r} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">白羽近墨</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E4%B9%90%E5%B0%8F%E6%B8%AF"><span class="nav-number">1.</span> <span class="nav-text">音乐小港</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">线程的创建与使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number"></span> <span class="nav-text">线程的创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number"></span> <span class="nav-text">Linux 线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="nav-number"></span> <span class="nav-text">Windows 线程创建</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Windows-CRT-%E6%8F%90%E4%BE%9B%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0"><span class="nav-number"></span> <span class="nav-text">Windows CRT 提供的线程创建函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-11-%E6%8F%90%E4%BE%9B%E7%9A%84-std-thread-%E7%B1%BB"><span class="nav-number"></span> <span class="nav-text">C++ 11 提供的 std::thread 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">总结</span></a></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>