<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="blog"><meta name="author" content="白羽近墨"><title>thrift | 白羽小站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/mylogo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/author.svg",favicon:"/images/mylogo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"种一棵树，最好的时间是十年前,其次是现在。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="baiyu" type="application/atom+xml">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/mylogo.svg"> </a><a class="logo-title" href="/">白羽小站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">thrift</span></div><div class="article-header"><div class="avatar"><img src="/images/author.svg"></div><div class="info"><div class="author"><span class="name">白羽近墨</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-10-13 15:36:54</span> <span class="mobile">2021-10-13 15:36</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Linux-%E5%9F%BA%E7%A1%80/">Linux 基础</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/thrift/">thrift</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>6.4k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>29 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4><div id="aplayer-OQQNigRY" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1313591405" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>Thrift</code>是一个轻量级、跨语言的远程服务调用框架，最初由<code>Facebook</code>开发，后面进入<code>Apache</code>开源项目。它通过自身的<code>IDL</code>中间语言, 并借助代码生成引擎生成各种主流语言的<code>RPC服务端/客户端模板代码</code>。</p><p><code>Thrift</code>支持多种不同的编程语言，包括<code>C++</code>、<code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>等</p><p><a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/">点我去<i class="fas fa-external-link-alt"></i></a>Thrift官网</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>(一) <strong>开发速度快</strong></p><p>通过编写<code>RPC</code>接口<code>Thrift IDL</code>文件，利用编译生成器自动生成服务端骨架(<code>Skeletons</code>)和客户端桩(<code>Stubs</code>)。从而省去开发者自定义和维护接口编解码、消息传输、服务器多线程模型等基础工作。</p><ul><li>服务端：只需要按照<strong>服务骨架</strong>即<strong>接口</strong>，编写好具体的<strong>业务处理程序</strong>(<code>Handler</code>)即<strong>实现类</strong>即可。</li><li>客户端：只需要拷贝<code>IDL</code>定义好的<strong>客户端桩</strong>和<strong>服务对象</strong>，然后就像调用本地对象的方法一样调用远端服务。</li></ul><p>(二) <strong>接口维护简单</strong></p><p>通过维护<code>Thrift</code>格式的<code>IDL</code>（接口描述语言）文件（注意写好注释），即可作为给<code>Client</code>使用的接口文档使用，也自动生成接口代码，始终保持代码和文档的一致性。且<code>Thrift</code>协议可灵活支持接口的可扩展性。</p><p>(三) <strong>学习成本低</strong></p><p>因为其来自<code>Google Protobuf</code>开发团队，所以其<code>IDL</code>文件风格类似<code>Google Protobuf</code>，且更加易读易懂；特别是<code>RPC</code>服务接口的风格就像写一个面向对象的<code>Class</code>一样简单。</p><p>初学者只需参照：<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/">thrift.apache.org/<i class="fas fa-external-link-alt"></i></a>，一个多小时就可以理解<code>Thrift IDL</code>文件的语法使用。</p><p>(四) <strong>多语言/跨语言支持</strong></p><p><code>Thrift</code>支持<code>C++</code>、 <code>Java</code>、<code>Python</code>、<code>PHP</code>、<code>Ruby</code>、<code>Erlang</code>、<code>Perl</code>、<code>Haskell</code>、<code>C#</code>、<code>Cocoa</code>、<code>JavaScript</code>、<code>Node.js</code>、<code>Smalltalk</code>等多种语言，即可生成上述语言的服务器端和客户端程序。</p><p>对于我们经常使用的<code>Java</code>、<code>PHP</code>、<code>Python</code>、<code>C++</code>支持良好，虽然对<code>iOS</code>环境的<code>Objective-C(Cocoa)</code>支持稍逊，但也完全满足我们的使用要求。</p><p>(五) <strong>稳定/广泛使用</strong></p><p><code>Thrift</code>在很多开源项目中已经被验证是稳定和高效的，例如Cassandra、Hadoop、HBase等；国外在Facebook中有广泛使用，国内包括百度、美团小米、和饿了么等公司。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>编写Thrift接口文件</li><li>使用thrift编译</li><li>实现业务代码</li></ul><h2 id="编写thrift文件"><a href="#编写thrift文件" class="headerlink" title="编写thrift文件"></a>编写thrift文件</h2><p>使用<code>Thrift</code>开发程序，首先要做的事情就是对接口进行描述， 然后再使用<code>Thrift</code>将接口的描述文件编译成对应语言的版本</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p><code>thrift</code>文件命名一般都是以<code>.thrift</code>作为后缀：<code>XXX.thrift</code>，可以在该文件的开头为该文件加上命名空间限制，格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace 语言名称 名称</span><br></pre></td></tr></table></figure><p>例如对<code>c++</code>来说，有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namespace cpp match_service</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>大小写敏感，它共支持以下几种基本的数据类型：</p><ol><li><code>string</code>， 字符串类型，注意是全部小写形式;</li><li><code>i16</code>, 16位整形类型;</li><li><code>i32</code>，32位整形类型，对应C/C++/java中的int类型;</li><li><code>i64</code>，64位整形，对应C/C++/java中的long类型;</li><li><code>byte</code>，8位的字符类型，对应C/C++中的char，java中的byte类型;</li><li><code>bool</code>, 布尔类型，对应C/C++中的bool，java中的boolean类型;</li><li><code>double</code>，双精度浮点类型，对应C/C++/java中的double类型;</li><li><code>void</code>，空类型，对应C/C++/java中的void类型；该类型主要用作函数的返回值;</li></ol><p>除上述基本类型外，IDL还支持以下类型：</p><ol><li><code>map</code>，map类型</li></ol><ul><li>例如，定义一个map对象：map[HTML_REMOVED] newmap;</li></ul><ol><li><code>set</code>，集合类型</li></ol><ul><li>例如，定义set[HTML_REMOVED]对象：set[HTML_REMOVED] aSet;</li></ul><ol><li><code>list</code>，链表类型</li></ol><ul><li>例如，定义一个list[HTML_REMOVED]对象：list[HTML_REMOVED] aList;</li></ul><p>struct，自定义结构体类型，在IDL中可以自己定义结构体，对应C中的struct，c++中的struct和class，java中的class。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct User{</span><br><span class="line">      1: i32 id,</span><br><span class="line">      2: string name,</span><br><span class="line">      3: i32 score</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>注意，在struct定义结构体时需要对每个结构体成员用序号标识：“序号: ”。</strong></p><h3 id="函数接口"><a href="#函数接口" class="headerlink" title="函数接口"></a>函数接口</h3><p>文件中对所有接口函数的描述都放在service中，service的名字可以自己指定，该名字也将被用作生成的特定语言接口文件的名字。</p><p><strong>接口函数需要对参数使用序号标号，除最后一个接口函数外，要以,结束对函数的描述。</strong></p><p>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">namespace cpp match_service</span><br><span class="line"></span><br><span class="line">struct User {</span><br><span class="line">    1: i32 id,</span><br><span class="line">    2: string name,</span><br><span class="line">    3: i32 score</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">service Match {</span><br><span class="line"></span><br><span class="line">    i32 add_user(1: User user, 2: string info),</span><br><span class="line"></span><br><span class="line">    i32 remove_user(1: User user, 2: string info),</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>创建项目文件夹thrift_project</p></li><li><p>业务逻辑图</p></li></ol><p><img lazyload="" src="/images/loading.svg" data-src="https://gitee.com/liuyutaocode/tao-blog-image/raw/master/img/20210930104820.png"></p><ol start="3"><li><p>游戏节点，创建game文件夹；</p></li><li><p>匹配系统节点，创建match_system文件夹；</p></li><li><p>thrift相关文件,创建thrift文件夹</p></li></ol><h3 id="服务端的建立"><a href="#服务端的建立" class="headerlink" title="服务端的建立"></a>服务端的建立</h3><p>对于匹配系统的<code>thrift</code>相关配置，我们在<code>thrift</code>文件夹下，创建<code>match.thrift</code>文件</p><p>打开<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/">thrift官网<i class="fas fa-external-link-alt"></i></a>，在上方选择<code>Tutorial</code>项，查看<code>thrift</code>官方教程</p><p>点击下方的<code>tutorial.thrift</code>进入一个示例文件</p><p>变写<code>thrift</code>配置文件，只需要在文件中写明接口和对象.然后执行命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -r --gen &lt;语言名&gt; &lt;.thrift文件的路径&gt;</span><br></pre></td></tr></table></figure><p>就会生成各种配置和连接文件，还有代码框架，只需要在框架中实现自己的业务即可</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>1.<strong>在<code>thrift</code>文件夹下，编辑<code>match.thrift</code>文件，用来生成<code>匹配系统服务端</code>的一系列文件</strong></p><p><code>match.thrift</code> 文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">##c++命名空间</span><br><span class="line">namespace cpp match_service</span><br><span class="line"></span><br><span class="line">struct User {</span><br><span class="line">    1: i32 id,</span><br><span class="line">    2: string name,</span><br><span class="line">    3: i32 score</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">service Match {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * user: 添加的用户信息</span><br><span class="line">     * info: 附加信息</span><br><span class="line">     * 在匹配池中添加一个名用户</span><br><span class="line">     */</span><br><span class="line">    i32 add_user(1: User user, 2: string info),</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * user: 删除的用户信息</span><br><span class="line">     * info: 附加信息</span><br><span class="line">     * 从匹配池中删除一名用户</span><br><span class="line">     */</span><br><span class="line">    i32 remove_user(1: User user, 2: string info),</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>2.<strong>进入到<code>match_system</code>文件夹，创建<code>src</code>文件夹。在<code>src</code>下执行语句：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -r --gen cpp ../../thrift/match.thrift</span><br></pre></td></tr></table></figure><p>这样，<code>thrift</code>服务端的一系列文件就会生成在<code>src</code>文件夹中的<code>gen-cpp</code>文件夹下，为了划分业务模块将<code>gen-cpp</code>重命名为<code>match_server</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv gen-cpp match_server</span><br></pre></td></tr></table></figure><p>文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">`-- match_server</span><br><span class="line">    |-- Match.cpp</span><br><span class="line">    |-- Match.h</span><br><span class="line">    |-- Match_server.skeleton.cpp</span><br><span class="line">    |-- match_types.cpp</span><br><span class="line">    `-- match_types.h</span><br></pre></td></tr></table></figure><p>其中<code>Match_server.skeleton.cpp</code>: 服务端的代码框架，具体业务就是在这个文件夹下编写实现</p><p>将<code>Match_server.skeleton.cpp</code>移动到<code>match_system/src</code>下并重命名为<code>main.cpp</code>，<code>match_system</code>的整个业务逻辑就是在这个文件中实现</p><p>3.<strong>初始<code>main.cpp</code>的改动</strong></p><ol><li>之前<code>main.cpp</code>在<code>match_server</code>下，现在在<code>match_system/src</code>下，所以<code>main.cpp</code>中对<code>Match.h</code>头文件的引入需要修改路径</li><li>文件中的两个函数<code>int32_t add_user</code>和<code>int32_t remove_user</code>需要有返回值，原来没有，会报警告，需要手动加上</li></ol><p><code>main.cpp</code>初始文件内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">// This autogenerated skeleton file illustrates how to build a server.</span><br><span class="line">// You should copy it to another filename to avoid overwriting it.</span><br><span class="line"></span><br><span class="line">#include "match_server/Match.h"</span><br><span class="line">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span><br><span class="line">#include &lt;thrift/server/TSimpleServer.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TServerSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TBufferTransports.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace ::apache::thrift;</span><br><span class="line">using namespace ::apache::thrift::protocol;</span><br><span class="line">using namespace ::apache::thrift::transport;</span><br><span class="line">using namespace ::apache::thrift::server;</span><br><span class="line"></span><br><span class="line">using namespace  ::match_service;</span><br><span class="line"></span><br><span class="line">class MatchHandler : virtual public MatchIf {</span><br><span class="line"> public:</span><br><span class="line">  MatchHandler() {</span><br><span class="line">    // Your initialization goes here</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  int32_t add_user(const User&amp; user, const std::string&amp; info) {</span><br><span class="line">    // Your implementation goes here</span><br><span class="line">    printf("add_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  int32_t remove_user(const User&amp; user, const std::string&amp; info) {</span><br><span class="line">    // Your implementation goes here</span><br><span class="line">    printf("remove_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) {</span><br><span class="line">  int port = 9090;</span><br><span class="line">  ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());</span><br><span class="line">  ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));</span><br><span class="line">  ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));</span><br><span class="line">  ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());</span><br><span class="line">  ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());</span><br><span class="line"></span><br><span class="line">  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);</span><br><span class="line">  server.serve();</span><br><span class="line">  return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="c-文件的编译、链接和运行"><a href="#c-文件的编译、链接和运行" class="headerlink" title="c++文件的编译、链接和运行"></a>c++文件的编译、链接和运行</h3><h4 id="C-的编译过程"><a href="#C-的编译过程" class="headerlink" title="C++的编译过程"></a>C++的编译过程</h4><p>(注意大小写)假设我有一个<code>main.cpp</code>文件</p><ol><li><p><code>-E</code>：只对文件进行预处理，不进行编译和汇编。<code>g++ -E main.cpp</code>——&gt;在dos命令行查看某文件的预处理过程，如果你想查看详细的预处理，可以重定向到一个文件中，如：<code>g++ -E main.cpp -o main.i</code></p></li><li><p><code>-s</code>：编译到汇编语言，不进行汇编和链接,即只激活预处理和编译，生成汇编语言,如果你想查看详细的编译，可以重定向到一个文件中，如：<code>g++ -S main.cpp -o main.s</code></p></li><li><p><code>-c</code>:编译到目标代码,<code>g++ -c main.s -o 文件名.o</code></p></li><li><p><code>-o</code>:生成链接文件: 如果该文件是独立的，与其他自己编写的文件无依赖关系。直接<code>g++ main.o -o 生成的可执行文件的文件名</code>，</p></li></ol><p>假设该文件依赖其他源文件（不需要加入头文件）<code>temp.cpp</code>,在对<code>temp.cpp</code>文件进行预处理-&gt;编译-&gt;汇编后，使用指令<code>g++ temp.o main.o -o main</code></p><ol><li><code>.\</code>:执行文件，输出结果。如: <code>.\main</code>，当然你可以直接<code>g++ main.cpp temp.cpp -o main</code> 生成目标文件让编译器自动为你处理其他流程。<h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4></li><li>编译<code>src</code>文件夹下的所有<code>.cpp</code>文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c *.cpp</span><br></pre></td></tr></table></figure></li><li>将所有生成的<code>.o</code>文件链接成一个可执行文件，要用到<code>thrift</code>动态链接库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o main -lthrift</span><br></pre></td></tr></table></figure></li><li>执行生成的可执行文件<code>main</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./main</span><br></pre></td></tr></table></figure>为了判断文件是否正确执行，可以在<code>main.cpp</code>中写一些输出语句，验证效果</li></ol><p>4.将项目版本提交git，提交时，一般会删除中间生成的文件和可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git restore --stage *.o</span><br><span class="line">git restore --stage match_system/src/main</span><br><span class="line">git commit -m "first can run"</span><br></pre></td></tr></table></figure><h3 id="客户端的实现"><a href="#客户端的实现" class="headerlink" title="客户端的实现"></a>客户端的实现</h3><h4 id="python文件的执行"><a href="#python文件的执行" class="headerlink" title="python文件的执行"></a>python文件的执行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 文件路径</span><br></pre></td></tr></table></figure><h4 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤"></a>步骤</h4><ol><li><strong>在<code>game</code>下创建<code>src</code>,在<code>src</code>下执行</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -r --gen py ../../thrift/match.thrift</span><br></pre></td></tr></table></figure>这样，<code>thrift</code>服务端的一系列文件就会生成在<code>src</code>文件夹中的<code>gen-py</code>文件夹下，为了划分业务模块将<code>gen-py</code>重命名为<code>match_client</code></li></ol><p>文件结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|-- __init__.py</span><br><span class="line">`-- match</span><br><span class="line">    |-- Match-remote</span><br><span class="line">    |-- Match.py</span><br><span class="line">    |-- __init__.py</span><br><span class="line">    |-- constants.py</span><br><span class="line">    `-- ttypes.py</span><br></pre></td></tr></table></figure><p>因为我们只需要实现客户端，不需要服务端，所以可以把<code>Match-remote</code>删除</p><ol start="2"><li>在<code>src</code>下创建文件<code>client.py</code>，将 <a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/tutorial/py.html">Apache Thrift - Python <i class="fas fa-external-link-alt"></i></a>，页面中，<code>client</code>中的代码复制到该文件中，并将代码进行适当的改动和删除，<code>client.py</code>中的初始代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">from match_client.match import Match</span><br><span class="line">from match_client.match.ttypes import User</span><br><span class="line"></span><br><span class="line">from thrift import Thrift</span><br><span class="line">from thrift.transport import TSocket</span><br><span class="line">from thrift.transport import TTransport</span><br><span class="line">from thrift.protocol import TBinaryProtocol</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    # Make socket</span><br><span class="line">    transport = TSocket.TSocket('127.0.0.1', 9090)</span><br><span class="line"></span><br><span class="line">    # Buffering is critical. Raw sockets are very slow</span><br><span class="line">    transport = TTransport.TBufferedTransport(transport)</span><br><span class="line"></span><br><span class="line">    # Wrap in a protocol</span><br><span class="line">    protocol = TBinaryProtocol.TBinaryProtocol(transport)</span><br><span class="line"></span><br><span class="line">    # Create a client to use the protocol encoder</span><br><span class="line">    client = Match.Client(protocol)</span><br><span class="line"></span><br><span class="line">    # Connect!</span><br><span class="line">    transport.open()</span><br><span class="line"></span><br><span class="line">    user = User(1,"lyt",50000)</span><br><span class="line">    client.add_user(user,"")</span><br><span class="line"></span><br><span class="line">    # Close!</span><br><span class="line">    transport.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == "__main__":</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li>运行查错</li><li>先在<code>thrift_project/match_system/src</code>下，执行:<code>./main</code>,使服务端运行</li><li>再在<code>thrift_project/game/src</code>下，执行：<code>python3 client.py</code>,使客户端运行</li><li>观察服务端运行处有无相应输出，若有，说明成功运行</li></ol><p>我们可以将此版本代码提交git</p><ol start="4"><li><strong>第一个简单输入输出版的<code>client</code></strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">from match_client.match import Match</span><br><span class="line">from match_client.match.ttypes import User</span><br><span class="line"></span><br><span class="line">from thrift import Thrift</span><br><span class="line">from thrift.transport import TSocket</span><br><span class="line">from thrift.transport import TTransport</span><br><span class="line">from thrift.protocol import TBinaryProtocol</span><br><span class="line">from sys import stdin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def operate(op: str, user_id: int, username: str, score: int):</span><br><span class="line">    # Make socket</span><br><span class="line">    transport = TSocket.TSocket('localhost', 9090)</span><br><span class="line"></span><br><span class="line">    # Buffering is critical. Raw sockets are very slow</span><br><span class="line">    transport = TTransport.TBufferedTransport(transport)</span><br><span class="line"></span><br><span class="line">    # Wrap in a protocol</span><br><span class="line">    protocol = TBinaryProtocol.TBinaryProtocol(transport)</span><br><span class="line"></span><br><span class="line">    # Create a client to use the protocol encoder</span><br><span class="line">    client = Match.Client(protocol)</span><br><span class="line"></span><br><span class="line">    # Connect!</span><br><span class="line">    transport.open()</span><br><span class="line"></span><br><span class="line">    user = User(user_id, username, score)</span><br><span class="line"></span><br><span class="line">    if op == "add":</span><br><span class="line">        client.add_user(user, "")</span><br><span class="line">    elif op == "remove":</span><br><span class="line">        client.remove_user(user, "")</span><br><span class="line"></span><br><span class="line">    # Close!</span><br><span class="line">    transport.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    for line in stdin:</span><br><span class="line">        op, user_id, username, score = line.split(" ")</span><br><span class="line">        operate(op, int(user_id), username, int(score))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == "__main__":</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>进行<code>运行查错</code>步骤并做正确输入，如果服务端处有相应输出，说明函数调用成功，运行成功</li></ol><p>我们可以将此版本代码提交git</p><h3 id="服务端具体匹配业务的实现"><a href="#服务端具体匹配业务的实现" class="headerlink" title="服务端具体匹配业务的实现"></a>服务端具体匹配业务的实现</h3><h4 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h4><p>学习各种语言多线程，需要关注的要点：</p><ol><li>用哪些头文件</li><li>如何创建一个线程(创建线程要用哪些函数)</li><li>如何使用锁(相关的函数)</li><li>如何使用条件变量</li></ol><p><strong>c++多线程</strong></p><p>参考博客：</p><p><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/kaleidopink/p/13817039.html">C++多线程编程 - kaleidopink - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p><p><a class="link" target="_blank" rel="noopener" href="https://blog.csdn.net/u011808673/article/details/80811998">C多线程编程_Nine days-CSDN博客_c多线程<i class="fas fa-external-link-alt"></i></a></p><h4 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤"></a>步骤</h4><ol><li>继续编写<code>thrift_project/match_system/src</code>下的<code>main.cpp</code><br>先添加头文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include "mutex"  //锁的头文件</span><br><span class="line">#include "thread"  //线程的头文件</span><br><span class="line">#include "condition_variable"  //条件变量的头文件</span><br><span class="line">#include "queue"</span><br></pre></td></tr></table></figure>傻瓜式匹配版<code>main.cpp</code>:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">// 这个自动生成的框架文件演示了如何构建服务器。</span><br><span class="line">// 你应该把它复制到另一个文件名以避免覆盖它。</span><br><span class="line"></span><br><span class="line">#include "match_server/Match.h"</span><br><span class="line">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span><br><span class="line">#include &lt;thrift/server/TSimpleServer.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TServerSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TBufferTransports.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include "mutex"  //锁的头文件</span><br><span class="line">#include "thread"  //线程的头文件</span><br><span class="line">#include "condition_variable"  //条件变量的头文件</span><br><span class="line">#include "queue"</span><br><span class="line">#include "vector"</span><br><span class="line"></span><br><span class="line">using namespace ::apache::thrift;</span><br><span class="line">using namespace ::apache::thrift::protocol;</span><br><span class="line">using namespace ::apache::thrift::transport;</span><br><span class="line">using namespace ::apache::thrift::server;</span><br><span class="line">using namespace std;</span><br><span class="line">using namespace ::match_service;</span><br><span class="line"></span><br><span class="line">struct Task {</span><br><span class="line">    User user;</span><br><span class="line">    string type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct MessageQueue {</span><br><span class="line">    //队列是互斥的，同时只能有一个线程访问队列</span><br><span class="line">    queue&lt;Task&gt; q;</span><br><span class="line">    mutex m;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">} message_queue;</span><br><span class="line"></span><br><span class="line">class Poll {</span><br><span class="line">public:</span><br><span class="line">    void add(User user) {</span><br><span class="line">        users.push_back(user);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void remove(User user) {</span><br><span class="line">        for (uint32_t i = 0; i &lt; users.size(); i++) {</span><br><span class="line">            if (users[i].id == user.id) {</span><br><span class="line">                users.erase(users.begin() + i);</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void match() {</span><br><span class="line">        while (users.size() &gt; 1) {</span><br><span class="line">//            printf("队列长度为: %ld\n", users.size());</span><br><span class="line">            auto player1 = users[0];</span><br><span class="line">            auto player2 = users[1];</span><br><span class="line">            users.erase(users.begin());</span><br><span class="line">            users.erase(users.begin());</span><br><span class="line"></span><br><span class="line">            save_result(player1.id, player2.id);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void save_result(int a, int b) {</span><br><span class="line">        printf(" %d 和 %d 匹配成功\n", a, b);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;User&gt; users;</span><br><span class="line">} pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MatchHandler : virtual public MatchIf {</span><br><span class="line">public:</span><br><span class="line">    MatchHandler() {</span><br><span class="line">        // 在这里初始化</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t add_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("add_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        message_queue.q.push({user, "add"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t remove_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("remove_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁</span><br><span class="line">        message_queue.q.push({user, "remove"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程操作的函数</span><br><span class="line">void consume_task() {</span><br><span class="line">    while (true) {</span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        if (message_queue.q.empty()) {</span><br><span class="line">            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里</span><br><span class="line">            //continue</span><br><span class="line">            message_queue.cv.wait(lock1);</span><br><span class="line">        } else {</span><br><span class="line">            auto task = message_queue.q.front();</span><br><span class="line">            message_queue.q.pop();</span><br><span class="line">            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁</span><br><span class="line">            lock1.unlock();</span><br><span class="line">            //具体任务</span><br><span class="line">            if (task.type == "add") {</span><br><span class="line">                pool.add(task.user);</span><br><span class="line">//                printf("执行了1次add");</span><br><span class="line">            } else if (task.type == "remove") {</span><br><span class="line">                pool.remove(task.user);</span><br><span class="line">            }</span><br><span class="line">            pool.match();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) {</span><br><span class="line">    int port = 9090;</span><br><span class="line">    ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());</span><br><span class="line">    ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));</span><br><span class="line">    ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));</span><br><span class="line">    ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());</span><br><span class="line">    ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());</span><br><span class="line">    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);</span><br><span class="line">    printf("Match server start\n");</span><br><span class="line"></span><br><span class="line">    thread matching_thread(consume_task);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.serve();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>编译链接<code>main.cpp</code><br>先编译<code>main.cpp</code>,在链接时，要用到<code>thrift</code>动态链接库和线程相关的动态链接库，所以链接时应该执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ *.o -o main -lthrift -pthread</span><br></pre></td></tr></table></figure><h3 id="数据存储客户端的实现"><a href="#数据存储客户端的实现" class="headerlink" title="数据存储客户端的实现"></a>数据存储客户端的实现</h3><h4 id="获取一个字符串的MD5加密串"><a href="#获取一个字符串的MD5加密串" class="headerlink" title="获取一个字符串的MD5加密串"></a>获取一个字符串的MD5加密串</h4>执行命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">md5sum</span><br></pre></td></tr></table></figure>回车后输入原字符串。在回车后按<code>ctrl+d</code>,就会生成MD5加密串</li></ol><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><ol><li>在<code>thrift</code>文件夹下，编辑<code>save.thrift</code>，用来生成数据存储客户端的一系列文件<br>这里的<code>thrift</code>接口由y总给出，可以在上课代码的git上找到，<code>save.thrift</code>中的代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">namespace cpp save_service</span><br><span class="line"></span><br><span class="line">service Save {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * username: myserver的名称</span><br><span class="line">     * password: myserver的密码的md5sum的前8位</span><br><span class="line">     * 用户名密码验证成功会返回0，验证失败会返回1</span><br><span class="line">     * 验证成功后，结果会被保存到myserver:homework/lesson_6/result.txt中</span><br><span class="line">     */</span><br><span class="line">    i32 save_data(1: string username, 2: string password, 3: i32 player1_id, 4: i32 player2_id)</span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>在match_system/src下执行：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thrift -r --gen cpp ../../thrift/save.thrift</span><br></pre></td></tr></table></figure>这样，thrift服务端的一系列文件就会生成在<code>src</code>文件夹中的<code>gen-cpp</code>文件夹下，为了划分业务模块将<code>gen-cpp</code>重命名为<code>save_client</code></li></ol><p>注意：</p><p>由于c++整个项目只能有一个<code>main</code>函数，而整个服务端的逻辑都在<code>thrift_project/match_system/src</code>下的<code>main.cpp</code>实现。所以一定要删除<code>thrift_project/match_system/src/save_client</code>下的<code>Save_server.skeleton.cpp</code>。而python没有这个问题，所以在用python实现客户端时，主框架文件可删可不删。</p><ol start="3"><li>改动<code>main.cpp</code>将数据存储端的业务写进去<br>改动点：</li><li>引入头文件，即<code>save_client/Save.h</code></li><li>补全命名空间，即添加<code>using namespace ::save_service</code>;</li><li>在<code>class Pool</code>中的<code>save_resut</code>函数中，添加<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/tutorial/cpp.html">官网 C++<i class="fas fa-external-link-alt"></i></a>样例的<code>client</code>中的<code>main</code>函数中的所有代码</li><li>由于数据存储是实现在<code>myserver</code>上，所以在连接时要更改<code>ip</code>地址。<code>myserver</code>的<code>ip</code>地址可以执行<code>homework 4 getinfo</code>查看</li><li>将<code>CalculatorClient</code>改为<code>SaveClient</code></li><li>将<code>transport-&gt;open()</code>和<code>transport-&gt;close()</code>;之间的教程代码删除，在此之间实现自己的业务<br>这里给出<code>save_result</code>函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void save_result(int a, int b) {</span><br><span class="line">    printf(" %d 和 %d 匹配成功\n", a, b);</span><br><span class="line"></span><br><span class="line">    std::shared_ptr&lt;TTransport&gt; socket(new TSocket("123.57.47.211", 9090));</span><br><span class="line">    std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));</span><br><span class="line">    std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));</span><br><span class="line">    CalculatorClient client(protocol);</span><br><span class="line"></span><br><span class="line">    try {</span><br><span class="line">        transport-&gt;open();</span><br><span class="line">        //----------在此之间实现自己的业务------------</span><br><span class="line">            //第二个参数是myserver密码的MD5值的前8位</span><br><span class="line">        client.save_data("acs_1642","6a46581f",a,b);</span><br><span class="line"></span><br><span class="line">        //-----------------------------------------</span><br><span class="line">        transport-&gt;close();</span><br><span class="line">    } catch (TException &amp;tx) {</span><br><span class="line">        cout &lt;&lt; "ERROR: " &lt;&lt; tx.what() &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></li><li>编译运行，并验证结果</li><li>编译链接：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -c save_client/*.cpp</span><br><span class="line">g++ -c main.cpp</span><br><span class="line">g++ *.o -o main -lthrift -pthread</span><br></pre></td></tr></table></figure></li><li>登录到myserver服务器上查看存储的结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh myserver</span><br><span class="line">cd homework/lesson_6 </span><br><span class="line">cat result.txt</span><br></pre></td></tr></table></figure>可以把此版本提交git</li></ol><h3 id="匹配系统2-0-按照分差匹配用户"><a href="#匹配系统2-0-按照分差匹配用户" class="headerlink" title="匹配系统2.0(按照分差匹配用户)"></a>匹配系统2.0(按照分差匹配用户)</h3><h4 id="c-lamda表达式"><a href="#c-lamda表达式" class="headerlink" title="c++lamda表达式"></a>c++lamda表达式</h4><p><a class="link" target="_blank" rel="noopener" href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">C++之Lambda表达式 - 季末的天堂 - 博客园 (cnblogs.com)<i class="fas fa-external-link-alt"></i></a></p><p>改动<code>main.cpp</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line">// 这个自动生成的框架文件演示了如何构建服务器。</span><br><span class="line">// 你应该把它复制到另一个文件名以避免覆盖它。</span><br><span class="line"></span><br><span class="line">#include "match_server/Match.h"</span><br><span class="line">#include "save_client/Save.h"</span><br><span class="line">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span><br><span class="line">#include &lt;thrift/server/TSimpleServer.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TServerSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TBufferTransports.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TTransportUtils.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;mutex&gt;  //锁的头文件</span><br><span class="line">#include &lt;thread&gt;  //线程的头文件</span><br><span class="line">#include &lt;condition_variable&gt;  //条件变量的头文件</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace ::apache::thrift;</span><br><span class="line">using namespace ::apache::thrift::protocol;</span><br><span class="line">using namespace ::apache::thrift::transport;</span><br><span class="line">using namespace ::apache::thrift::server;</span><br><span class="line">using namespace ::match_service;</span><br><span class="line">using namespace ::save_service;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Task {</span><br><span class="line">    User user;</span><br><span class="line">    string type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct MessageQueue {</span><br><span class="line">    //队列是互斥的，同时只能有一个线程访问队列</span><br><span class="line">    queue &lt;Task&gt; q;</span><br><span class="line">    mutex m;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">} message_queue;</span><br><span class="line"></span><br><span class="line">class Poll {</span><br><span class="line">public:</span><br><span class="line">    void add(User user) {</span><br><span class="line">        users.push_back(user);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void remove(User user) {</span><br><span class="line">        for (uint32_t i = 0; i &lt; users.size(); i++) {</span><br><span class="line">            if (users[i].id == user.id) {</span><br><span class="line">                users.erase(users.begin() + i);</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void match() {</span><br><span class="line">        while (users.size() &gt; 1) {</span><br><span class="line">//            printf("队列长度为: %ld\n", users.size());</span><br><span class="line">            sort(users.begin(),users.end(),[&amp;](User &amp;a,User b){</span><br><span class="line">                return a.score&lt;b.score;</span><br><span class="line">            });</span><br><span class="line">            bool flag = true;</span><br><span class="line">            for(uint32_t i = 1 ; i &lt;users.size(); i++) {</span><br><span class="line">              auto a = users[i-1],b = users[i];</span><br><span class="line">                if (b.score-a.score&lt;=50){</span><br><span class="line">                    users.erase(users.begin()+i,users.begin()+i+1);</span><br><span class="line"></span><br><span class="line">                    save_result(a.id,b.id);</span><br><span class="line">                    flag = false;</span><br><span class="line">                    break;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            if (flag){</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void save_result(int a, int b) {</span><br><span class="line">        printf(" %d 和 %d 匹配成功\n", a, b);</span><br><span class="line"></span><br><span class="line">        std::shared_ptr&lt;TTransport&gt; socket(new TSocket("123.57.47.211", 9090));</span><br><span class="line">        std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));</span><br><span class="line">        std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));</span><br><span class="line">        SaveClient client(protocol);</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            transport-&gt;open();</span><br><span class="line">            //----------在此之间实现自己的业务------------</span><br><span class="line">                //第二个参数是myserver密码的MD5值的前8位</span><br><span class="line">            client.save_data("acs_1642","6a46581f",a,b);</span><br><span class="line"></span><br><span class="line">            //-----------------------------------------</span><br><span class="line">            transport-&gt;close();</span><br><span class="line">        } catch (TException &amp;tx) {</span><br><span class="line">            cout &lt;&lt; "ERROR: " &lt;&lt; tx.what() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector &lt;User&gt; users;</span><br><span class="line">} pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MatchHandler : virtual public MatchIf {</span><br><span class="line">public:</span><br><span class="line">    MatchHandler() {</span><br><span class="line">        // 在这里初始化</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t add_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("add_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        message_queue.q.push({user, "add"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t remove_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("remove_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁</span><br><span class="line">        message_queue.q.push({user, "remove"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程操作的函数</span><br><span class="line">void consume_task() {</span><br><span class="line">    while (true) {</span><br><span class="line">        unique_lock &lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        if (message_queue.q.empty()) {</span><br><span class="line">            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里</span><br><span class="line">            //continue</span><br><span class="line">//            message_queue.cv.wait(lock1);</span><br><span class="line">            lock1.unlock();</span><br><span class="line">            pool.match();</span><br><span class="line">            sleep(1);</span><br><span class="line">            //当队列为空时。当前线程放弃持有锁，由其他线程持有锁，在进行匹配。这个过程1s后，再进行后面的判断</span><br><span class="line">        } else {</span><br><span class="line">            auto task = message_queue.q.front();</span><br><span class="line">            message_queue.q.pop();</span><br><span class="line">            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁</span><br><span class="line">            lock1.unlock();</span><br><span class="line">            //具体任务</span><br><span class="line">            if (task.type == "add") {</span><br><span class="line">                pool.add(task.user);</span><br><span class="line">//                printf("执行了1次add");</span><br><span class="line">            } else if (task.type == "remove") {</span><br><span class="line">                pool.remove(task.user);</span><br><span class="line">            }</span><br><span class="line">            pool.match();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) {</span><br><span class="line">    int port = 9090;</span><br><span class="line">    ::std::shared_ptr&lt;MatchHandler&gt; handler(new MatchHandler());</span><br><span class="line">    ::std::shared_ptr&lt;TProcessor&gt; processor(new MatchProcessor(handler));</span><br><span class="line">    ::std::shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));</span><br><span class="line">    ::std::shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());</span><br><span class="line">    ::std::shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());</span><br><span class="line">    TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);</span><br><span class="line">    printf("Match server start\n");</span><br><span class="line"></span><br><span class="line">    thread matching_thread(consume_task);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.serve();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h3 id="匹配系统3-0-升级为多线程服务器"><a href="#匹配系统3-0-升级为多线程服务器" class="headerlink" title="匹配系统3.0(升级为多线程服务器)"></a>匹配系统3.0(升级为多线程服务器)</h3><p>之前的版本都是用一个线程来add和remove <code>user</code>，想要提高效率和并发量，可以将服务端升级为多线程版本</p><h4 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤"></a>步骤</h4><p>引入<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/tutorial/cpp.html">官网 C++样例<i class="fas fa-external-link-alt"></i></a>的<code>Server</code>中,<code>main.cpp</code>没有的头文件。</p><p>将<code>main</code>函数中的<code>TSimpleServer</code>即相关函数，替换成<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/tutorial/cpp.html">官网 C++样例<i class="fas fa-external-link-alt"></i></a>的<code>Server</code>中的<code>main</code>函数中的<code>TThreadedServer</code>相关内容</p><p>将<a class="link" target="_blank" rel="noopener" href="https://thrift.apache.org/tutorial/cpp.html">官网 C++样例<i class="fas fa-external-link-alt"></i></a>的<code>Server</code>中的<code>class CalculatorCloneFactory</code>相关内容加进来</p><p>将文件中的所有<code>Calculator</code>替换为<code>Match</code>,在<code>vim</code>中的具体操作为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$s/Calculator/Match/g</span><br></pre></td></tr></table></figure><p>将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void releaseHandler(::shared::SharedServiceIf *handler) override { delete handler; }</span><br></pre></td></tr></table></figure><p>替换为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void releaseHandler(MatchIf *handler) override { delete handler; }</span><br></pre></td></tr></table></figure><p>编译运行检查错误</p><h3 id="匹配系统4-0-随时间扩大匹配阈值"><a href="#匹配系统4-0-随时间扩大匹配阈值" class="headerlink" title="匹配系统4.0(随时间扩大匹配阈值)"></a>匹配系统4.0(随时间扩大匹配阈值)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line">// 这个自动生成的框架文件演示了如何构建服务器。</span><br><span class="line">// 你应该把它复制到另一个文件名以避免覆盖它。</span><br><span class="line"></span><br><span class="line">#include "match_server/Match.h"</span><br><span class="line">#include "save_client/Save.h"</span><br><span class="line">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;</span><br><span class="line">#include &lt;thrift/server/TSimpleServer.h&gt;</span><br><span class="line">#include &lt;thrift/server/TThreadPoolServer.h&gt;</span><br><span class="line">#include &lt;thrift/server/TThreadedServer.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TServerSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TSocket.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TTransportUtils.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TBufferTransports.h&gt;</span><br><span class="line">#include &lt;thrift/transport/TTransportUtils.h&gt;</span><br><span class="line">#include &lt;thrift/concurrency/ThreadManager.h&gt;</span><br><span class="line">#include &lt;thrift/concurrency/ThreadFactory.h&gt;</span><br><span class="line">#include &lt;thrift/TToString.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;mutex&gt;  //锁的头文件</span><br><span class="line">#include &lt;thread&gt;  //线程的头文件</span><br><span class="line">#include &lt;condition_variable&gt;  //条件变量的头文件</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace ::apache::thrift;</span><br><span class="line">using namespace ::apache::thrift::protocol;</span><br><span class="line">using namespace ::apache::thrift::transport;</span><br><span class="line">using namespace ::apache::thrift::server;</span><br><span class="line">using namespace ::match_service;</span><br><span class="line">using namespace ::save_service;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct Task {</span><br><span class="line">    User user;</span><br><span class="line">    string type;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">struct MessageQueue {</span><br><span class="line">    //队列是互斥的，同时只能有一个线程访问队列</span><br><span class="line">    queue&lt;Task&gt; q;</span><br><span class="line">    mutex m;</span><br><span class="line">    condition_variable cv;</span><br><span class="line">} message_queue;</span><br><span class="line"></span><br><span class="line">class Poll {</span><br><span class="line">public:</span><br><span class="line">    void add(User user) {</span><br><span class="line">        users.push_back(user);</span><br><span class="line">        wt.push_back(0);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void remove(User user) {</span><br><span class="line">        for (uint32_t i = 0; i &lt; users.size(); i++) {</span><br><span class="line">            if (users[i].id == user.id) {</span><br><span class="line">                users.erase(users.begin() + i);</span><br><span class="line">                break;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">     }</span><br><span class="line"></span><br><span class="line">    bool check_match(uint32_t i, uint32_t j) {</span><br><span class="line">        auto a = users[i], b = users[j];</span><br><span class="line"></span><br><span class="line">        int dt = abs(a.score - b.score);</span><br><span class="line">        int a_max_dif = wt[i] * 50;</span><br><span class="line">        int b_max_dif = wt[j] * 50;</span><br><span class="line"></span><br><span class="line">        return dt &lt;= a_max_dif &amp;&amp; dt &lt;= b_max_dif;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void match() {</span><br><span class="line">        for (uint32_t i = 0; i &lt; wt.size(); i++)</span><br><span class="line">            wt[i]++;   // 等待秒数 + 1</span><br><span class="line">//            sort(users.begin(), users.end(), [&amp;](User &amp;a, User b) {</span><br><span class="line">//                return a.score &lt; b.score;</span><br><span class="line">//            });</span><br><span class="line">        while (users.size() &gt; 1) {</span><br><span class="line">            bool flag = true;</span><br><span class="line">            for (uint32_t i = 0; i &lt; users.size(); i++) {</span><br><span class="line">                for (uint32_t j = i + 1; j &lt; users.size(); j++) {</span><br><span class="line">                    if (check_match(i, j)) {</span><br><span class="line">                        auto a = users[i], b = users[j];</span><br><span class="line">                        users.erase(users.begin() + j);</span><br><span class="line">                        users.erase(users.begin() + i);</span><br><span class="line">                        wt.erase(wt.begin() + j);</span><br><span class="line">                        wt.erase(wt.begin() + i);</span><br><span class="line">                        save_result(a.id, b.id);</span><br><span class="line">                        flag = false;</span><br><span class="line">                        break;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                if (!flag) break;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            if (flag) break;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void save_result(int a, int b) {</span><br><span class="line">        printf(" %d 和 %d 匹配成功\n", a, b);</span><br><span class="line"></span><br><span class="line">        std::shared_ptr&lt;TTransport&gt; socket(new TSocket("123.57.47.211", 9090));</span><br><span class="line">        std::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));</span><br><span class="line">        std::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));</span><br><span class="line">        SaveClient client(protocol);</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            transport-&gt;open();</span><br><span class="line">            //----------在此之间实现自己的业务------------</span><br><span class="line">            //第二个参数是myserver密码的MD5值的前8位</span><br><span class="line">            client.save_data("acs_1642", "6a46581f", a, b);</span><br><span class="line"></span><br><span class="line">            //-----------------------------------------</span><br><span class="line">            transport-&gt;close();</span><br><span class="line">        } catch (TException &amp;tx) {</span><br><span class="line">            cout &lt;&lt; "ERROR: " &lt;&lt; tx.what() &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vector&lt;User&gt; users;</span><br><span class="line">    vector&lt;int&gt; wt;</span><br><span class="line">} pool;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MatchHandler : virtual public MatchIf {</span><br><span class="line">public:</span><br><span class="line">    MatchHandler() {</span><br><span class="line">        // 在这里初始化</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t add_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("add_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        message_queue.q.push({user, "add"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    int32_t remove_user(const User &amp;user, const std::string &amp;info) {</span><br><span class="line">        // 在这里实现接口</span><br><span class="line">        printf("remove_user\n");</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁,在队列为空的时候，不能拿到锁</span><br><span class="line">        message_queue.q.push({user, "remove"});</span><br><span class="line">        //当有操作时，应该唤醒线程</span><br><span class="line">        message_queue.cv.notify_all();</span><br><span class="line"></span><br><span class="line">        return 0;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">class MatchCloneFactory : virtual public MatchIfFactory {</span><br><span class="line">public:</span><br><span class="line">    ~MatchCloneFactory() override = default;</span><br><span class="line"></span><br><span class="line">    MatchIf *getHandler(const ::apache::thrift::TConnectionInfo &amp;connInfo) override {</span><br><span class="line">        std::shared_ptr&lt;TSocket&gt; sock = std::dynamic_pointer_cast&lt;TSocket&gt;(connInfo.transport);</span><br><span class="line">//        cout &lt;&lt; "Incoming connection\n";</span><br><span class="line">//        cout &lt;&lt; "\tSocketInfo: "  &lt;&lt; sock-&gt;getSocketInfo() &lt;&lt; "\n";</span><br><span class="line">//        cout &lt;&lt; "\tPeerHost: "    &lt;&lt; sock-&gt;getPeerHost() &lt;&lt; "\n";</span><br><span class="line">//        cout &lt;&lt; "\tPeerAddress: " &lt;&lt; sock-&gt;getPeerAddress() &lt;&lt; "\n";</span><br><span class="line">//        cout &lt;&lt; "\tPeerPort: "    &lt;&lt; sock-&gt;getPeerPort() &lt;&lt; "\n";</span><br><span class="line">        return new MatchHandler;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    void releaseHandler(MatchIf *handler) override {</span><br><span class="line">        delete handler;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">//线程操作的函数</span><br><span class="line">void consume_task() {</span><br><span class="line">    while (true) {</span><br><span class="line">        unique_lock&lt;mutex&gt; lock1(message_queue.m);//加锁</span><br><span class="line">        if (message_queue.q.empty()) {</span><br><span class="line">            //因为队列初始一定是空的，如果直接continue，会死循环。因此在初始时，应在有add操作后，才应该执行这里</span><br><span class="line">            //continue</span><br><span class="line">//            message_queue.cv.wait(lock1);</span><br><span class="line">            lock1.unlock();</span><br><span class="line">            pool.match();</span><br><span class="line">            sleep(1);</span><br><span class="line">            //当队列为空时。当前线程放弃持有锁，由其他线程持有锁，在进行匹配。这个过程1s后，再进行后面的判断</span><br><span class="line">        } else {</span><br><span class="line">            auto task = message_queue.q.front();</span><br><span class="line">            message_queue.q.pop();</span><br><span class="line">            //因为只有队列是互斥的，为了保证程序的快速运行，操作完队列就应该释放锁</span><br><span class="line">            lock1.unlock();</span><br><span class="line">            //具体任务</span><br><span class="line">            if (task.type == "add") {</span><br><span class="line">                pool.add(task.user);</span><br><span class="line">//                printf("执行了1次add");</span><br><span class="line">            } else if (task.type == "remove") {</span><br><span class="line">                pool.remove(task.user);</span><br><span class="line">            }</span><br><span class="line">//            pool.match();</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int main(int argc, char **argv) {</span><br><span class="line">    TThreadedServer server(</span><br><span class="line">            std::make_shared&lt;MatchProcessorFactory&gt;(std::make_shared&lt;MatchCloneFactory&gt;()),</span><br><span class="line">            std::make_shared&lt;TServerSocket&gt;(9090), //port</span><br><span class="line">            std::make_shared&lt;TBufferedTransportFactory&gt;(),</span><br><span class="line">            std::make_shared&lt;TBinaryProtocolFactory&gt;()</span><br><span class="line">    );</span><br><span class="line">    printf("Match server start\n");</span><br><span class="line"></span><br><span class="line">    thread matching_thread(consume_task);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    server.serve();</span><br><span class="line">    return 0;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><hr><h2 id="案例代码：参考"><a href="#案例代码：参考" class="headerlink" title="案例代码：参考"></a>案例代码：<a class="link" target="_blank" rel="noopener" href="https://git.acwing.com/zhouH/thrift">参考<i class="fas fa-external-link-alt"></i></a></h2><p>来源链接：<a class="link" target="_blank" rel="noopener" href="https://www.acwing.com/blog/content/7852/">10631179<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：thrift</li><li>本文作者：白羽近墨</li><li>创建时间：2021-10-13 15:36:54</li><li>本文链接：https://keep.xpoet.cn/2021/10/13/thrift/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/thrift/">#thrift</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/10/13/Longest-continuous-unrepeated-subsequence/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">最长连续不重复子序列</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/10/13/Pipes-environment-variables-and-common-commands/"><span class="title flex-center"><span class="post-nav-title-item">管道、环境变量与常用命令</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"irqOqaGORMEoxUV1bBigEGyr-gzGzoHsz",appKey:"Dkd9JB0KYotx5nS6IA6PKB6f",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="白羽近墨";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),r=n.innerHTML;r===t&&(n.innerHTML=`${r} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">白羽近墨</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E4%B9%90%E5%B0%8F%E6%B8%AF"><span class="nav-number">1.</span> <span class="nav-text">音乐小港</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#Thrift"><span class="nav-number"></span> <span class="nav-text">Thrift</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number"></span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number"></span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number"></span> <span class="nav-text">使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E5%86%99thrift%E6%96%87%E4%BB%B6"><span class="nav-number"></span> <span class="nav-text">编写thrift文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number"></span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number"></span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3"><span class="nav-number"></span> <span class="nav-text">函数接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number"></span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number"></span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number"></span> <span class="nav-text">服务端的建立</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91%E3%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BF%90%E8%A1%8C"><span class="nav-number"></span> <span class="nav-text">c++文件的编译、链接和运行</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">C++的编译过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-1"><span class="nav-number">2.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number"></span> <span class="nav-text">客户端的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#python%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="nav-number">1.</span> <span class="nav-text">python文件的执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-2"><span class="nav-number">2.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%85%B7%E4%BD%93%E5%8C%B9%E9%85%8D%E4%B8%9A%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number"></span> <span class="nav-text">服务端具体匹配业务的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">多线程编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-3"><span class="nav-number">2.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number"></span> <span class="nav-text">数据存储客户端的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84MD5%E5%8A%A0%E5%AF%86%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">获取一个字符串的MD5加密串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="nav-number">2.</span> <span class="nav-text">步骤：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F2-0-%E6%8C%89%E7%85%A7%E5%88%86%E5%B7%AE%E5%8C%B9%E9%85%8D%E7%94%A8%E6%88%B7"><span class="nav-number"></span> <span class="nav-text">匹配系统2.0(按照分差匹配用户)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#c-lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-number">1.</span> <span class="nav-text">c++lamda表达式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F3-0-%E5%8D%87%E7%BA%A7%E4%B8%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number"></span> <span class="nav-text">匹配系统3.0(升级为多线程服务器)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4-4"><span class="nav-number">1.</span> <span class="nav-text">步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%B9%E9%85%8D%E7%B3%BB%E7%BB%9F4-0-%E9%9A%8F%E6%97%B6%E9%97%B4%E6%89%A9%E5%A4%A7%E5%8C%B9%E9%85%8D%E9%98%88%E5%80%BC"><span class="nav-number"></span> <span class="nav-text">匹配系统4.0(随时间扩大匹配阈值)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%8F%82%E8%80%83"><span class="nav-number"></span> <span class="nav-text">案例代码：参考</span></a></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>