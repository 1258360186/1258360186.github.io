<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="blog"><meta name="author" content="白羽近墨"><title>GDB 常用命令详解（中） | 白羽小站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/mylogo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/author.svg",favicon:"/images/mylogo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"种一棵树，最好的时间是十年前,其次是现在。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="baiyu" type="application/atom+xml">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/mylogo.svg"> </a><a class="logo-title" href="/">白羽小站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">GDB 常用命令详解（中）</span></div><div class="article-header"><div class="avatar"><img src="/images/author.svg"></div><div class="info"><div class="author"><span class="name">白羽近墨</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-10-10 16:41:57</span> <span class="mobile">2021-10-10 16:41</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Linux-GDB-%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/">Linux GDB 调试指南</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/C-%E5%BC%80%E5%8F%91/">C++ 开发</a>&nbsp;</li><li>| <a href="/tags/GDB/">GDB</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>5.7k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>26 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4><div id="aplayer-pVNmeQBr" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="522647397" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="GDB-常用命令详解（中）"><a href="#GDB-常用命令详解（中）" class="headerlink" title="GDB 常用命令详解（中）"></a>GDB 常用命令详解（中）</h1><p>本课的核心内容：</p><ul><li>info 和 thread 命令</li><li>next、step、until、finish、return 和 jump 命令</li></ul><h2 id="info-和-thread-命令"><a href="#info-和-thread-命令" class="headerlink" title="info 和 thread 命令"></a>info 和 thread 命令</h2><p>在前面使用 <strong>info break</strong> 命令查看当前断点时介绍过，info 命令是一个复合指令，还可以用来查看当前进程的所有线程运行情况。下面以 redis-server 进程为例来演示一下，使用 delete 命令删掉所有断点，然后使用 run 命令重启一下 redis-server，等程序正常启动后，我们按快捷键 Ctrl+C 中断程序，然后使用 info thread 命令来查看当前进程有哪些线程，分别中断在何处：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete</span><br><span class="line">Delete all breakpoints? (y or n) y</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">...省略部分无关内容...</span><br><span class="line">53062:M 10 Sep 17:11:10.810 * Ready to accept connections</span><br><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) info thread</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  4    Thread 0x7fffef7fd700 (LWP 53065) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  3    Thread 0x7fffefffe700 (LWP 53064) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  2    Thread 0x7ffff07ff700 (LWP 53063) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">* 1    Thread 0x7ffff7fec780 (LWP 53062) "redis-server" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br></pre></td></tr></table></figure><p>通过 <strong>info thread</strong> 的输出可以知道 redis-server 正常启动后，一共产生了 4 个线程，包括一个主线程和三个工作线程，线程编号（Id 那一列）分别是 4、3、2、1。三个工作线程（2、3、4）分别阻塞在 Linux API pthread_cond_wait 处，而主线程（1）阻塞在 epoll_wait 处。</p><blockquote><p>注意：虽然第一栏的名称叫 Id，但第一栏的数值不是线程的 Id，第三栏括号里的内容（如 LWP 53065）中，53065 这样的数值才是当前线程真正的 Id。那 LWP 是什么意思呢？在早期的 Linux 系统的内核里面，其实不存在真正的线程实现，当时所有的线程都是用进程来实现的，这些模拟线程的进程被称为 Light Weight Process（轻量级进程），后来 Linux 系统有了真正的线程实现，这个名字仍然被保留了下来。</p></blockquote><p>读者可能会有疑问：怎么知道线程 1 就是主线程？线程 2、线程 3、线程 4 就是工作线程呢？是不是因为线程 1 前面有个星号（*）？错了，线程编号前面这个星号表示的是当前 GDB 作用于哪个线程，而不是主线程的意思。现在有 4 个线程，也就有 4 个调用堆栈，如果此时输入 <strong>backtrace</strong> 命令查看调用堆栈，由于当前 GDB 作用在线程 1，因此 <strong>backtrace</strong> 命令显示的一定是线程 1 的调用堆栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">#1  0x00000000004265df in aeApiPoll (tvp=0x7fffffffe300, eventLoop=0x7ffff08350a0) at ae_epoll.c:112</span><br><span class="line">#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411</span><br><span class="line">#3  0x0000000000426aeb in aeMain (eventLoop=0x7ffff08350a0) at ae.c:501</span><br><span class="line">#4  0x00000000004238ef in main (argc=1, argv=0x7fffffffe648) at server.c:3899</span><br></pre></td></tr></table></figure><p>由此可见，堆栈 #4 的 main() 函数也证实了上面的说法，即线程编号为 1 的线程是主线程。</p><p>如何切换到其他线程呢？可以通过“thread 线程编号”切换到具体的线程上去。例如，想切换到线程 2 上去，只要输入 <strong>thread 2</strong> 即可，然后输入 <strong>bt</strong> 就能查看这个线程的调用堆栈了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info thread</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  4    Thread 0x7fffef7fd700 (LWP 53065) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  3    Thread 0x7fffefffe700 (LWP 53064) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  2    Thread 0x7ffff07ff700 (LWP 53063) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">* 1    Thread 0x7ffff7fec780 (LWP 53062) "redis-server" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) thread 2</span><br><span class="line">[Switching to thread 2 (Thread 0x7ffff07ff700 (LWP 53063))]</span><br><span class="line">#0  0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">#1  0x000000000047a91c in bioProcessBackgroundJobs (arg=0x0) at bio.c:176</span><br><span class="line">#2  0x00007ffff76c0e25 in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#3  0x00007ffff73ee34d in clone () from /lib64/libc.so.6</span><br></pre></td></tr></table></figure><p>因此利用 <strong>info thread</strong> 命令就可以调试多线程程序，当然用 GDB 调试多线程程序还有一个很麻烦的问题，我们将在后面的 GDB 高级调试技巧中介绍。请注意，当把 GDB 当前作用的线程切换到线程 2 上之后，线程 2 前面就被加上了星号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info thread</span><br><span class="line">  Id   Target Id         Frame</span><br><span class="line">  4    Thread 0x7fffef7fd700 (LWP 53065) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  3    Thread 0x7fffefffe700 (LWP 53064) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">* 2    Thread 0x7ffff07ff700 (LWP 53063) "redis-server" 0x00007ffff76c4945 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span><br><span class="line">  1    Thread 0x7ffff7fec780 (LWP 53062) "redis-server" 0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br></pre></td></tr></table></figure><p><strong>info</strong> 命令还可以用来查看当前函数的参数值，组合命令是 <strong>info args</strong>，我们找个函数值多一点的堆栈函数来试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) thread 1</span><br><span class="line">[Switching to thread 1 (Thread 0x7ffff7fec780 (LWP 53062))]</span><br><span class="line">#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) bt</span><br><span class="line">#0  0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">#1  0x00000000004265df in aeApiPoll (tvp=0x7fffffffe300, eventLoop=0x7ffff08350a0) at ae_epoll.c:112</span><br><span class="line">#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411</span><br><span class="line">#3  0x0000000000426aeb in aeMain (eventLoop=0x7ffff08350a0) at ae.c:501</span><br><span class="line">#4  0x00000000004238ef in main (argc=1, argv=0x7fffffffe648) at server.c:3899</span><br><span class="line">(gdb) f 2</span><br><span class="line">#2  aeProcessEvents (eventLoop=eventLoop@entry=0x7ffff08350a0, flags=flags@entry=11) at ae.c:411</span><br><span class="line">411             numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">(gdb) info args</span><br><span class="line">eventLoop = 0x7ffff08350a0</span><br><span class="line">flags = 11</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>上述代码片段切回至主线程 1，然后切换到堆栈 #2，堆栈 #2 调用处的函数是 aeProcessEvents() ，一共有两个参数，使用 <strong>info args</strong> 命令可以输出当前两个函数参数的值，参数 eventLoop 是一个指针类型的参数，对于指针类型的参数，GDB 默认会输出该变量的指针地址值，如果想输出该指针指向对象的值，在变量名前面加上 * 解引用即可，这里使用 p *eventLoop 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *eventLoop</span><br><span class="line">$26 = {maxfd = 11, setsize = 10128, timeEventNextId = 1, lastTime = 1536570672, events = 0x7ffff0871480, fired = 0x7ffff08c2e40, timeEventHead = 0x7ffff0822080,</span><br><span class="line">  stop = 0, apidata = 0x7ffff08704a0, beforesleep = 0x429590 &lt;beforeSleep&gt;, aftersleep = 0x4296d0 &lt;afterSleep&gt;}</span><br></pre></td></tr></table></figure><p>如果还要查看其成员值，继续使用 <strong>变量名 -&gt;字段名</strong> 即可，在前面学习 print 命令时已经介绍过了，这里不再赘述。</p><p>上面介绍的是 <strong>info</strong> 命令最常用的三种方法，更多关于 info 的组合命令在 GDB 中输入 <strong>help info</strong> 就可以查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help info</span><br><span class="line">Generic command for showing things about the program being debugged.</span><br><span class="line"></span><br><span class="line">List of info subcommands:</span><br><span class="line"></span><br><span class="line">info address -- Describe where symbol SYM is stored</span><br><span class="line">info all-registers -- List of all registers and their contents</span><br><span class="line">info args -- Argument variables of current stack frame</span><br><span class="line">info auto-load -- Print current status of auto-loaded files</span><br><span class="line">info auto-load-scripts -- Print the list of automatically loaded Python scripts</span><br><span class="line">info auxv -- Display the inferior's auxiliary vector</span><br><span class="line">info bookmarks -- Status of user-settable bookmarks</span><br><span class="line">info breakpoints -- Status of specified breakpoints (all user-settable breakpoints if no argument)</span><br><span class="line">info checkpoints -- IDs of currently known checkpoints</span><br><span class="line">info classes -- All Objective-C classes</span><br><span class="line">info common -- Print out the values contained in a Fortran COMMON block</span><br><span class="line">info copying -- Conditions for redistributing copies of GDB</span><br><span class="line">info dcache -- Print information on the dcache performance</span><br><span class="line">info display -- Expressions to display when program stops</span><br><span class="line">info extensions -- All filename extensions associated with a source language</span><br><span class="line">info files -- Names of targets and files being debugged</span><br><span class="line">info float -- Print the status of the floating point unit</span><br><span class="line">info frame -- All about selected stack frame</span><br><span class="line">info frame-filter -- List all registered Python frame-filters</span><br><span class="line">info functions -- All function names</span><br><span class="line">info handle -- What debugger does when program gets various signals</span><br><span class="line">info inferiors -- IDs of specified inferiors (all inferiors if no argument)</span><br><span class="line">info line -- Core addresses of the code for a source line</span><br><span class="line">info locals -- Local variables of current stack frame</span><br><span class="line">info macro -- Show the definition of MACRO</span><br><span class="line">info macros -- Show the definitions of all macros at LINESPEC</span><br><span class="line">info mem -- Memory region attributes</span><br><span class="line">info os -- Show OS data ARG</span><br><span class="line">info pretty-printer -- GDB command to list all registered pretty-printers</span><br><span class="line">info probes -- Show available static probes</span><br><span class="line">info proc -- Show /proc process information about any running process</span><br><span class="line">info program -- Execution status of the program</span><br><span class="line">info record -- Info record options</span><br><span class="line">info registers -- List of integer registers and their contents</span><br><span class="line">info scope -- List the variables local to a scope</span><br><span class="line">---Type &lt;return&gt; to continue, or q &lt;return&gt; to quit---</span><br><span class="line">info selectors -- All Objective-C selectors</span><br><span class="line">info set -- Show all GDB settings</span><br><span class="line">info sharedlibrary -- Status of loaded shared object libraries</span><br><span class="line">info signals -- What debugger does when program gets various signals</span><br><span class="line">info skip -- Display the status of skips</span><br><span class="line">info source -- Information about the current source file</span><br><span class="line">info sources -- Source files in the program</span><br><span class="line">info stack -- Backtrace of the stack</span><br><span class="line">info static-tracepoint-markers -- List target static tracepoints markers</span><br><span class="line">info symbol -- Describe what symbol is at location ADDR</span><br><span class="line">info target -- Names of targets and files being debugged</span><br><span class="line">info tasks -- Provide information about all known Ada tasks</span><br><span class="line">info terminal -- Print inferior's saved terminal status</span><br><span class="line">info threads -- Display currently known threads</span><br><span class="line">info tracepoints -- Status of specified tracepoints (all tracepoints if no argument)</span><br><span class="line">info tvariables -- Status of trace state variables and their values</span><br><span class="line">info type-printers -- GDB command to list all registered type-printers</span><br><span class="line">info types -- All type names</span><br><span class="line">info variables -- All global and static variable names</span><br><span class="line">info vector -- Print the status of the vector unit</span><br><span class="line">info vtbl -- Show the virtual function table for a C++ object</span><br><span class="line">info warranty -- Various kinds of warranty you do not have</span><br><span class="line">info watchpoints -- Status of specified watchpoints (all watchpoints if no argument)</span><br><span class="line">info win -- List of all displayed windows</span><br><span class="line"></span><br><span class="line">Type "help info" followed by info subcommand name for full documentation.</span><br><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br></pre></td></tr></table></figure><h2 id="next、step、until、finish、return-和-jump-命令"><a href="#next、step、until、finish、return-和-jump-命令" class="headerlink" title="next、step、until、finish、return 和 jump 命令"></a>next、step、until、finish、return 和 jump 命令</h2><p>这几个命令是我们用 GDB 调试程序时最常用的几个控制流命令，因此放在一起介绍。<strong>next</strong> 命令（简写为 n）是让 GDB 调到下一条命令去执行，这里的下一条命令不一定是代码的下一行，而是根据程序逻辑跳转到相应的位置。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">if (a == 9)</span><br><span class="line">{</span><br><span class="line">    print("a is equal to 9.\n");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">int b = 10;</span><br><span class="line">print("b = %d.\n", b);</span><br></pre></td></tr></table></figure><p>如果当前 GDB 中断在上述代码第 2 行，此时输入 next 命令 GDB 将调到第 7 行，因为这里的 if 条件并不满足。</p><p>这里有一个小技巧，在 GDB 命令行界面如果直接按下回车键，默认是将最近一条命令重新执行一遍，因此，当使用 <strong>next</strong> 命令单步调试时，不必反复输入 <strong>n</strong> 命令，直接回车就可以了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">3704    int main(int argc, char **argv) {</span><br><span class="line">(gdb) n</span><br><span class="line">3736        spt_init(argc, argv);</span><br><span class="line">(gdb) n</span><br><span class="line">3738        setlocale(LC_COLLATE,"");</span><br><span class="line">(gdb) n</span><br><span class="line">3739        zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">(gdb) n</span><br><span class="line">3740        srand(time(NULL)^getpid());</span><br><span class="line">(gdb) n</span><br><span class="line">3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">(gdb) n</span><br><span class="line">3740        srand(time(NULL)^getpid());</span><br><span class="line">(gdb) n</span><br><span class="line">3741        gettimeofday(&amp;tv,NULL);</span><br><span class="line">(gdb) n</span><br><span class="line">3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>上面的执行过程等价于输入第一个 <strong>n</strong> 后直接回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">3736        spt_init(argc, argv);</span><br><span class="line">(gdb)</span><br><span class="line">3738        setlocale(LC_COLLATE,"");</span><br><span class="line">(gdb)</span><br><span class="line">3739        zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">(gdb)</span><br><span class="line">3740        srand(time(NULL)^getpid());</span><br><span class="line">(gdb)</span><br><span class="line">3752        server.exec_argv = zmalloc(sizeof(char*)*(argc+1));</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p><strong>next</strong> 命令用调试的术语叫“单步步过”（step over），即遇到函数调用直接跳过，不进入函数体内部。而下面的 <strong>step</strong> 命令（简写为 <strong>s</strong>）就是“单步步入”（step into），顾名思义，就是遇到函数调用，进入函数内部。举个例子，在 redis-server 的 main() 函数中有个叫 spt_init(argc, argv) 的函数调用，当我们停在这一行时，输入 s 将进入这个函数内部。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//为了说明问题本身，除去不相关的干扰，代码有删减</span><br><span class="line">int main(int argc, char **argv) {</span><br><span class="line">    struct timeval tv;</span><br><span class="line">    int j;</span><br><span class="line">    /* We need to initialize our libraries, and the server configuration. */</span><br><span class="line">    spt_init(argc, argv);</span><br><span class="line">    setlocale(LC_COLLATE,"");</span><br><span class="line">    zmalloc_set_oom_handler(redisOutOfMemoryHandler);</span><br><span class="line">    srand(time(NULL)^getpid());</span><br><span class="line">    gettimeofday(&amp;tv,NULL);</span><br><span class="line">    char hashseed[16];</span><br><span class="line">    getRandomHexChars(hashseed,sizeof(hashseed));</span><br><span class="line">    dictSetHashFunctionSeed((uint8_t*)hashseed);</span><br><span class="line">    server.sentinel_mode = checkForSentinelMode(argc,argv);</span><br><span class="line">    initServerConfig();</span><br><span class="line">    moduleInitModulesSystem();</span><br><span class="line">    //省略部分无关代码...</span><br><span class="line"> }</span><br></pre></td></tr></table></figure><p>演示一下，先使用 <strong>b main</strong> 命令在 main() 处加一个断点，然后使用 r 命令重新跑一下程序，会触发刚才加在 main() 函数处的断点，然后使用 <strong>n</strong> 命令让程序走到 spt_init(argc, argv) 函数调用处，再输入 <strong>s</strong> 命令就可以进入该函数了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 3 at 0x423450: file server.c, line 3704.</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/redis-4.0.9/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line"></span><br><span class="line">Breakpoint 3, main (argc=1, argv=0x7fffffffe588) at server.c:3704</span><br><span class="line">3704    int main(int argc, char **argv) {</span><br><span class="line">(gdb) n</span><br><span class="line">3736        spt_init(argc, argv);</span><br><span class="line">(gdb) s</span><br><span class="line">spt_init (argc=argc@entry=1, argv=argv@entry=0x7fffffffe588) at setproctitle.c:152</span><br><span class="line">152     void spt_init(int argc, char *argv[]) {</span><br><span class="line">(gdb) l</span><br><span class="line">147</span><br><span class="line">148             return 0;</span><br><span class="line">149     } /* spt_copyargs() */</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152     void spt_init(int argc, char *argv[]) {</span><br><span class="line">153             char **envp = environ;</span><br><span class="line">154             char *base, *end, *nul, *tmp;</span><br><span class="line">155             int i, error;</span><br><span class="line">156</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>说到 <strong>step</strong> 命令，还有一个需要注意的地方，就是当函数的参数也是函数调用时，我们使用 <strong>step</strong> 命令会依次进入各个函数，那么顺序是什么呢？举个例子，看下面这段代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">1  int func1(int a, int b)</span><br><span class="line">2  {</span><br><span class="line">3     int c = a + b;</span><br><span class="line">4     c += 2;</span><br><span class="line">5     return c;</span><br><span class="line">6  }</span><br><span class="line">7</span><br><span class="line">8  int func2(int p, int q)</span><br><span class="line">9  {</span><br><span class="line">10    int t = q * p;</span><br><span class="line">11       return t * t;</span><br><span class="line">12 }</span><br><span class="line">13</span><br><span class="line">14 int func3(int m, int n)</span><br><span class="line">15 {</span><br><span class="line">16    return m + n;</span><br><span class="line">17 }</span><br><span class="line">18</span><br><span class="line">19 int main()</span><br><span class="line">20 {</span><br><span class="line">21    int c;</span><br><span class="line">22    c = func3(func1(1, 2),  func2(8, 9));</span><br><span class="line">23    printf("c=%d.\n", c);</span><br><span class="line">24    return 0;</span><br><span class="line">25 }</span><br></pre></td></tr></table></figure><p>上述代码，程序入口是 main() 函数，在第 22 行 func3 使用 func1 和 func2 的返回值作为自己的参数，在第 22 行输入 <strong>step</strong> 命令，会先进入哪个函数呢？这里就需要补充一个知识点了—— 函数调用方式，我们常用的函数调用方式有 _cdecl 和 _stdcall，C++ 非静态成员函数的调用方式是 _thiscall 。在这些调用方式中，函数参数的传递本质上是函数参数的入栈过程，而这三种调用方式参数的入栈顺序都是从右往左的，因此，这段代码中并没有显式标明函数的调用方式，采用默认 _cdecl 方式。</p><p>当我们在第 22 行代码处输入 <strong>step</strong> 先进入的是 func2() ，当从 func2() 返回时再次输入 <strong>step</strong> 命令会接着进入 func1() ，当从 func1 返回时，此时两个参数已经计算出来了，这时候会最终进入 func3() 。理解这一点，在遇到这样的代码时，才能根据需要进入我们想要的函数中去调试。</p><p>实际调试时，我们在某个函数中调试一段时间后，不需要再一步步执行到函数返回处，希望直接执行完当前函数并回到上一层调用处，就可以使用 <strong>finish</strong> 命令。与 <strong>finish</strong> 命令类似的还有 <strong>return</strong> 命令，<strong>return</strong> 命令的作用是结束执行当前函数，还可以指定该函数的返回值。</p><p>这里需要注意一下二者的区别：<strong>finish</strong> 命令会执行函数到正常退出该函数；而 <strong>return</strong> 命令是立即结束执行当前函数并返回，也就是说，如果当前函数还有剩余的代码未执行完毕，也不会执行了。我们用一个例子来验证一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1  #include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3  int func()</span><br><span class="line">4  {</span><br><span class="line">5     int a = 9;</span><br><span class="line">6     printf("a=%d.\n", a);</span><br><span class="line">7</span><br><span class="line">8     int b = 8;</span><br><span class="line">9     printf("b=%d.\n", b);</span><br><span class="line">10    return a + b;</span><br><span class="line">11 }</span><br><span class="line">12</span><br><span class="line">13 int main()</span><br><span class="line">14 {</span><br><span class="line">15    int c = func();</span><br><span class="line">16    printf("c=%d.\n", c);</span><br><span class="line">17</span><br><span class="line">18    return 0;</span><br><span class="line">19 }</span><br></pre></td></tr></table></figure><p>在 main() 函数处加一个断点，然后运行程序，在第 15 行使用 <strong>step</strong> 命令进入 func() 函数，接着单步到代码第 8 行，直接输入 <strong>return</strong> 命令，这样 func() 函数剩余的代码就不会继续执行了，因此 printf(“b=%d.\n”, b); 这一行就没有输出。同时由于我们没有在 <strong>return</strong> 命令中指定这个函数的返回值，因而最终在 main() 函数中得到的变量 c 的值是一个脏数据。这也就验证了我们上面说的：<strong>return</strong> 命令在当前位置立即结束当前函数的执行，并返回到上一层调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x40057d: file test.c, line 15.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/testreturn/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64</span><br><span class="line">(gdb) s</span><br><span class="line">func () at test.c:5</span><br><span class="line">5           int a = 9;</span><br><span class="line">(gdb) n</span><br><span class="line">6           printf("a=%d.\n", a);</span><br><span class="line">(gdb) n</span><br><span class="line">a=9.</span><br><span class="line">8           int b = 8;</span><br><span class="line">(gdb) return</span><br><span class="line">Make func return now? (y or n) y</span><br><span class="line">#0  0x0000000000400587 in main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">(gdb) n</span><br><span class="line">16          printf("c=%d.\n", c);</span><br><span class="line">(gdb) n</span><br><span class="line">c=-134250496.</span><br><span class="line">18          return 0;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>再次用 <strong>return</strong> 命令指定一个值试一下，这样得到变量 c 的值应该就是我们指定的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/testreturn/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">(gdb) s</span><br><span class="line">func () at test.c:5</span><br><span class="line">5           int a = 9;</span><br><span class="line">(gdb) n</span><br><span class="line">6           printf("a=%d.\n", a);</span><br><span class="line">(gdb) n</span><br><span class="line">a=9.</span><br><span class="line">8           int b = 8;</span><br><span class="line">(gdb) return 9999</span><br><span class="line">Make func return now? (y or n) y</span><br><span class="line">#0  0x0000000000400587 in main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">(gdb) n</span><br><span class="line">16          printf("c=%d.\n", c);</span><br><span class="line">(gdb) n</span><br><span class="line">c=9999.</span><br><span class="line">18          return 0;</span><br><span class="line">(gdb) p c</span><br><span class="line">$1 = 9999</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>仔细观察上述代码应该会发现，用 <strong>return</strong> 命令修改了函数的返回值，当使用 <strong>print</strong> 命令打印 c 值的时候，c 值也确实被修改成了 9999。</p><p>我们再对比一下使用 <strong>finish</strong> 命令来结束函数执行的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/testreturn/test </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">(gdb) s</span><br><span class="line">func () at test.c:5</span><br><span class="line">5           int a = 9;</span><br><span class="line">(gdb) n</span><br><span class="line">6           printf("a=%d.\n", a);</span><br><span class="line">(gdb) n</span><br><span class="line">a=9.</span><br><span class="line">8           int b = 8;</span><br><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  func () at test.c:8</span><br><span class="line">b=8.</span><br><span class="line">0x0000000000400587 in main () at test.c:15</span><br><span class="line">15          int c = func();</span><br><span class="line">Value returned is $3 = 17</span><br><span class="line">(gdb) n</span><br><span class="line">16          printf("c=%d.\n", c);</span><br><span class="line">(gdb) n</span><br><span class="line">c=17.</span><br><span class="line">18          return 0;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>结果和我们预期的一样，<strong>finish</strong> 正常结束函数，剩余的代码也会被正常执行。因此 c 的值是 17。</p><p>实际调试时，还有一个 <strong>until</strong> 命令（简写为 <strong>u</strong>）可以指定程序运行到某一行停下来，还是以 redis-server 的代码为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">1812    void initServer(void) {</span><br><span class="line">1813        int j;</span><br><span class="line">1814</span><br><span class="line">1815        signal(SIGHUP, SIG_IGN);</span><br><span class="line">1816        signal(SIGPIPE, SIG_IGN);</span><br><span class="line">1817        setupSignalHandlers();</span><br><span class="line">1818</span><br><span class="line">1819        if (server.syslog_enabled) {</span><br><span class="line">1820            openlog(server.syslog_ident, LOG_PID | LOG_NDELAY | LOG_NOWAIT,</span><br><span class="line">1821                server.syslog_facility);</span><br><span class="line">1822        }</span><br><span class="line">1823</span><br><span class="line">1824        server.pid = getpid();</span><br><span class="line">1825        server.current_client = NULL;</span><br><span class="line">1826        server.clients = listCreate();</span><br><span class="line">1827        server.clients_to_close = listCreate();</span><br><span class="line">1828        server.slaves = listCreate();</span><br><span class="line">1829        server.monitors = listCreate();</span><br><span class="line">1830        server.clients_pending_write = listCreate();</span><br><span class="line">1831        server.slaveseldb = -1; /* Force to emit the first SELECT command. */</span><br><span class="line">1832        server.unblocked_clients = listCreate();</span><br><span class="line">1833        server.ready_keys = listCreate();</span><br><span class="line">1834        server.clients_waiting_acks = listCreate();</span><br><span class="line">1835        server.get_ack_from_slaves = 0;</span><br><span class="line">1836        server.clients_paused = 0;</span><br><span class="line">1837        server.system_memory_size = zmalloc_get_memory_size();</span><br><span class="line">1838</span><br><span class="line">1839        createSharedObjects();</span><br><span class="line">1840        adjustOpenFilesLimit();</span><br><span class="line">1841        server.el = aeCreateEventLoop(server.maxclients+CONFIG_FDSET_INCR);</span><br><span class="line">1842        if (server.el == NULL) {</span><br><span class="line">1843            serverLog(LL_WARNING,</span><br><span class="line">1844                "Failed creating the event loop. Error message: '%s'",</span><br><span class="line">1845                strerror(errno));</span><br><span class="line">1846            exit(1);</span><br><span class="line">1847        }</span><br></pre></td></tr></table></figure><p>这是 redis-server 代码中 initServer() 函数的一个代码片段，位于文件 server.c 中，当停在第 1813 行，想直接跳到第 1839 行，可以直接输入 <strong>u 1839</strong>，这样就能快速执行完中间的代码。当然，也可以先在第 1839 行加一个断点，然后使用 <strong>continue</strong> 命令运行到这一行，但是使用 <strong>until</strong> 命令会更简便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/redis-4.0.9/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line"></span><br><span class="line">Breakpoint 3, main (argc=1, argv=0x7fffffffe588) at server.c:3704</span><br><span class="line">3704    int main(int argc, char **argv) {</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">21574:C 14 Sep 06:42:36.978 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">21574:C 14 Sep 06:42:36.978 # Redis version=4.0.9, bits=64, commit=00000000, modified=0, pid=21574, just started</span><br><span class="line">21574:C 14 Sep 06:42:36.979 # Warning: no config file specified, using the default config. In order to specify a config file use /root/redis-4.0.9/src/redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line">Breakpoint 4, initServer () at server.c:1812</span><br><span class="line">1812    void initServer(void) {</span><br><span class="line">(gdb) n</span><br><span class="line">1815        signal(SIGHUP, SIG_IGN);</span><br><span class="line">(gdb) u 1839</span><br><span class="line">initServer () at server.c:1839</span><br><span class="line">1839        createSharedObjects();</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h2 id="jump-命令基本用法是："><a href="#jump-命令基本用法是：" class="headerlink" title="jump 命令基本用法是："></a>jump 命令基本用法是：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jump &lt;location&gt;</span><br></pre></td></tr></table></figure><p><strong>location</strong> 可以是程序的行号或者函数的地址，<strong>jump</strong> 会让程序执行流跳转到指定位置执行，当然其行为也是不可控制的，例如您跳过了某个对象的初始化代码，直接执行操作该对象的代码，那么可能会导致程序崩溃或其他意外行为。<strong>jump</strong> 命令可以简写成 <strong>j</strong>，但是不可以简写成 <strong>jmp</strong>，其使用有一个注意事项，即如果 <strong>jump</strong> 跳转到的位置后续没有断点，那么 GDB 会执行完跳转处的代码会继续执行。举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 int somefunc()</span><br><span class="line">2 {</span><br><span class="line">3   //代码A</span><br><span class="line">4   //代码B</span><br><span class="line">5   //代码C</span><br><span class="line">6   //代码D</span><br><span class="line">7   //代码E</span><br><span class="line">8   //代码F</span><br><span class="line">9 }</span><br></pre></td></tr></table></figure><p>假设我们的断点初始位置在行号 <strong>3</strong> 处（代码 A），这个时候我们使用 <strong>jump 6</strong>，那么程序会跳过代码 B 和 C 的执行，执行完代码 D（ <strong>跳转点</strong>），程序并不会停在代码 <strong>6</strong> 处，而是继续执行后续代码，因此如果我们想查看执行跳转处的代码后的结果，需要在行号 <strong>6</strong>、<strong>7</strong> 或 <strong>8</strong> 处设置断点。</p><p><strong>jump</strong> 命令除了跳过一些代码的执行外，还有一个妙用就是可以执行一些我们想要执行的代码，而这些代码在正常的逻辑下可能并不会执行（当然可能也因此会产生一些意外的结果，这需要读者自行斟酌使用）。举个例子，假设现在有如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1  #include &lt;stdio.h&gt;</span><br><span class="line">2  int main()</span><br><span class="line">3  {</span><br><span class="line">4    int a = 0;</span><br><span class="line">5    if (a != 0)</span><br><span class="line">6    {</span><br><span class="line">7      printf("if condition\n");</span><br><span class="line">8    }</span><br><span class="line">9    else</span><br><span class="line">10   {</span><br><span class="line">11     printf("else condition\n");</span><br><span class="line">12   }</span><br><span class="line">13</span><br><span class="line">14   return 0;</span><br><span class="line">15 }</span><br></pre></td></tr></table></figure><p>我们在行号 <strong>4 、14</strong> 处设置一个断点，当触发行号 <strong>4</strong> 处的断点后，正常情况下程序执行流会走 else 分支，我们可以使用 <strong>jump 7</strong> 强行让程序执行 if 分支，接着 GDB 会因触发行号 <strong>14</strong> 处的断点而停下来，此时我们接着执行 <strong>jump 11</strong>，程序会将 else 分支中的代码重新执行一遍。整个操作过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost testcore]# gdb test</span><br><span class="line">Reading symbols from /root/testcore/test...done.</span><br><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x400545: file main.cpp, line 4.</span><br><span class="line">(gdb) b 14</span><br><span class="line">Breakpoint 2 at 0x400568: file main.cpp, line 14.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/testcore/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.cpp:4</span><br><span class="line">4       int a = 0;</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64</span><br><span class="line">(gdb) jump 7</span><br><span class="line">Continuing at 0x400552.</span><br><span class="line">if condition</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.cpp:14</span><br><span class="line">14       return 0;</span><br><span class="line">(gdb) jump 11</span><br><span class="line">Continuing at 0x40055e.</span><br><span class="line">else condition</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.cpp:14</span><br><span class="line">14       return 0;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[Inferior 1 (process 13349) exited normally]</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p><strong>redis-server</strong> 在入口函数 <strong>main</strong> 处调用 <strong>initServer()</strong> ，我们使用 “<strong>b initServer</strong>” 、“<strong>b 2025</strong>”、“<strong>b 2027</strong>”在这个函数入口处、2025 行、2027 行增加三个断点，然后使用 <strong>run</strong> 命令重新运行一下程序，触发第一个断点后，继续输入 c 命令继续运行，然后触发 2025 行处的断点，接着输入 <strong>jump 2027</strong> ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 2025</span><br><span class="line">Breakpoint 5 at 0x42c8e7: file server.c, line 2025.</span><br><span class="line">(gdb) b 2027</span><br><span class="line">Breakpoint 6 at 0x42c8f8: file server.c, line 2027.</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) n</span><br><span class="line">Program not restarted.</span><br><span class="line">(gdb) b initServer</span><br><span class="line">Note: breakpoint 3 also set at pc 0x42c8b0.</span><br><span class="line">Breakpoint 7 at 0x42c8b0: file server.c, line 2013.</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/redis-5.0.3/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffe4e8) at server.c:4003</span><br><span class="line">4003    int main(int argc, char **argv) {</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">13374:C 14 Jan 2019 15:12:16.571 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">13374:C 14 Jan 2019 15:12:16.571 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=13374, just started</span><br><span class="line">13374:C 14 Jan 2019 15:12:16.571 # Warning: no config file specified, using the default config. In order to specify a config file use /root/redis-5.0.3/src/redis-server /path/to/redis.conf</span><br><span class="line"></span><br><span class="line">Breakpoint 3, initServer () at server.c:2013</span><br><span class="line">2013    void initServer(void) {</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 5, initServer () at server.c:2025</span><br><span class="line">2025        server.hz = server.config_hz;</span><br><span class="line">(gdb) jump 2027</span><br><span class="line">Continuing at 0x42c8f8.</span><br><span class="line"></span><br><span class="line">Breakpoint 6, initServer () at server.c:2027</span><br><span class="line">2027        server.current_client = NULL;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>程序将 <strong>2026</strong> 行的代码跳过了，2026 行处的代码是获取当前进程 id：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2026 server.pid = getpid();</span><br></pre></td></tr></table></figure><p>由于这一行被跳过了，所以 <strong>server.pid</strong> 的值应该是一个无效的值，我们可以使用 <strong>print</strong> 命令将这个值打印出来看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p server.pid</span><br><span class="line">$3 = 0</span><br></pre></td></tr></table></figure><p>结果确实是 <strong>0</strong> 这个我们初始化的无效值。</p><blockquote><p>本质上，<strong>jump</strong> 命令的作用类似于在 Visual Studio 中调试时，拖鼠标将程序从一个执行处拖到另外一个执行处。</p></blockquote><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb7.1oqia2a0pl8g.jpg" alt="gdb7"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="本节课介绍了-info-thread、next、step、until、finish、-return-和-jump-命令，这些也是-GDB-调试过程中非常常用的命令，请读者务必掌握。"><a href="#本节课介绍了-info-thread、next、step、until、finish、-return-和-jump-命令，这些也是-GDB-调试过程中非常常用的命令，请读者务必掌握。" class="headerlink" title="本节课介绍了 info thread、next、step、until、finish、 return 和 jump 命令，这些也是 GDB 调试过程中非常常用的命令，请读者务必掌握。"></a>本节课介绍了 info thread、next、step、until、finish、 return 和 jump 命令，这些也是 GDB 调试过程中非常常用的命令，请读者务必掌握。</h3><hr><p>来源:<a class="link" target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/column/5c0e149eedba1b683458fd5f">范蠡《Linux GDB 调试指南》<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：GDB 常用命令详解（中）</li><li>本文作者：白羽近墨</li><li>创建时间：2021-10-10 16:41:57</li><li>本文链接：https://keep.xpoet.cn/2021/10/10/GDB-2/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/C-%E5%BC%80%E5%8F%91/">#C++ 开发</a>&nbsp;</li><li class="tag-item"><a href="/tags/GDB/">#GDB</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/10/10/GDB-3/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">GDB 常用命令详解（下）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/10/10/GDB-1/"><span class="title flex-center"><span class="post-nav-title-item">GDB 常用命令详解（上）</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"irqOqaGORMEoxUV1bBigEGyr-gzGzoHsz",appKey:"Dkd9JB0KYotx5nS6IA6PKB6f",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="白羽近墨";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),r=n.innerHTML;r===t&&(n.innerHTML=`${r} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">白羽近墨</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E4%B9%90%E5%B0%8F%E6%B8%AF"><span class="nav-number">1.</span> <span class="nav-text">音乐小港</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#GDB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%AD%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">GDB 常用命令详解（中）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#info-%E5%92%8C-thread-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">info 和 thread 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#next%E3%80%81step%E3%80%81until%E3%80%81finish%E3%80%81return-%E5%92%8C-jump-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">next、step、until、finish、return 和 jump 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jump-%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E6%98%AF%EF%BC%9A"><span class="nav-number"></span> <span class="nav-text">jump 命令基本用法是：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E8%AF%BE%E4%BB%8B%E7%BB%8D%E4%BA%86-info-thread%E3%80%81next%E3%80%81step%E3%80%81until%E3%80%81finish%E3%80%81-return-%E5%92%8C-jump-%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%BF%99%E4%BA%9B%E4%B9%9F%E6%98%AF-GDB-%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%9D%9E%E5%B8%B8%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%AF%B7%E8%AF%BB%E8%80%85%E5%8A%A1%E5%BF%85%E6%8E%8C%E6%8F%A1%E3%80%82"><span class="nav-number"></span> <span class="nav-text">本节课介绍了 info thread、next、step、until、finish、 return 和 jump 命令，这些也是 GDB 调试过程中非常常用的命令，请读者务必掌握。</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>