<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="blog"><meta name="author" content="白羽近墨"><title>启动 GDB 调试 | 白羽小站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/mylogo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/author.svg",favicon:"/images/mylogo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"种一棵树，最好的时间是十年前,其次是现在。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="baiyu" type="application/atom+xml">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/mylogo.svg"> </a><a class="logo-title" href="/">白羽小站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">启动 GDB 调试</span></div><div class="article-header"><div class="avatar"><img src="/images/author.svg"></div><div class="info"><div class="author"><span class="name">白羽近墨</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-10-10 15:44:40</span> <span class="mobile">2021-10-10 15:44</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Linux-GDB-%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/">Linux GDB 调试指南</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/C-%E5%BC%80%E5%8F%91/">C++ 开发</a>&nbsp;</li><li>| <a href="/tags/GDB/">GDB</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>3.1k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>13 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4><div id="aplayer-suongkuG" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="1378282335" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="启动-GDB-调试"><a href="#启动-GDB-调试" class="headerlink" title="启动 GDB 调试"></a>启动 GDB 调试</h1><p>使用 GDB 调试程序一般有三种方式：</p><ul><li>gdb filename</li><li>gdb attach pid</li><li>gdb filename corename</li></ul><p>这也对应着本节课的核心内容：</p><ul><li>直接调试目标程序</li><li>附加进程</li><li>调试 core 文件<br>接下来我们逐一讲解。</li></ul><h2 id="直接调试目标程序"><a href="#直接调试目标程序" class="headerlink" title="直接调试目标程序"></a>直接调试目标程序</h2><p>在开发阶段或者研究别人的项目时，当编译成功生成目标二进制文件后，可以使用 <strong>gdb filename</strong> 直接启动这个程序的调试，其中 <strong>filename</strong> 是需要启动的调试程序文件名，这种方式是直接使用 GDB 启动一个程序进行调试。注意这里说的<strong>启动一个程序进行调试</strong>其实不严谨，因为实际上只是附加（attach）了一个可执行文件，并没有把程序启动起来；接着需要输入run 命令，程序才会真正的运行起来。关于 <strong>run</strong> 命令后面的课程中会详细介绍。上一课的 GDB 调试 hello_server 系列就是使用的这种方式。</p><p>假设现在有一个程序叫 <strong>fileserver</strong>，使用 <strong>gdb fileserver</strong> 附加该程序，然后使用 <strong>run</strong> 命令启动该程序。如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb6.10736za5ayvk.jpg" alt="gdb6"></p><h2 id="附加进程"><a href="#附加进程" class="headerlink" title="附加进程"></a>附加进程</h2><p>在某些情况下，一个程序已经启动了，我们想调试这个程序，但是又不想重启这个程序。假设有这样一个场景，我们的聊天测试服务器程序正在运行，运行一段时间之后，发现这个聊天服务器不能接受新的客户端连接了，这时肯定是不能重启程序的，如果重启，当前程序的各种状态信息就丢失了。怎么办呢？可以使用 <strong>gdb attach 进程 ID</strong> 来将 GDB 调试器附加到聊天测试服务器程序上。例如，假设聊天程序叫 chatserver，可以使用 ps 命令获取该进程的 PID，然后使用 gdb attach 就可以调试了，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[zhangyl@iZ238vnojlyZ flamingoserver]$ ps -ef | grep chatserver</span><br><span class="line">zhangyl  21462 21414  0 18:00 pts/2    00:00:00 grep --color=auto chatserver</span><br><span class="line">zhangyl  26621     1  5 Oct10 ?        2-17:54:42 ./chatserver -d</span><br></pre></td></tr></table></figure><p>实际执行如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb5.3gwo4mbem6s0.JPG" alt="gdb5"></p><p>通过以上代码得到 chatserver 的 PID 为 26621，然后使用 <strong>gdb attach 26621</strong> 把 GDB 附加到 chatserver 进程，操作并输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zhangyl@localhost flamingoserver]$ gdb attach 26621</span><br><span class="line">Attaching to process 26661</span><br><span class="line">Reading symbols from /home/zhangyl/flamingoserver/chatserver...done.</span><br><span class="line">Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...Reading symbols from /usr/lib64/mysql/libmysqlclient.so.18...(no debugging symbols found)...done.</span><br><span class="line">Reading symbols from /lib64/libpthread.so.0...(no debugging symbols found)...done.</span><br><span class="line">[New LWP 42931]</span><br><span class="line">[New LWP 42930]</span><br><span class="line">[New LWP 42929]</span><br><span class="line">[New LWP 42928]</span><br><span class="line">[New LWP 42927]</span><br><span class="line">[New LWP 42926]</span><br><span class="line">[New LWP 42925]</span><br><span class="line">[New LWP 42924]</span><br><span class="line">[New LWP 42922]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">Loaded symbols for /lib64/libpthread.so.0</span><br><span class="line">Reading symbols from /lib64/libc.so.6...(no debugging symbols found)...done.</span><br></pre></td></tr></table></figure><p>为了节约篇幅，上述代码中我删掉了一些无关的信息。当提示 “<strong>Attaching to process 26621</strong>” 时就说明我们已经成功地将 GDB 附加到目标进程了。需要注意的是，程序使用了一些系统库（如 libc.so），由于这是发行版本的 Linux 系统，这些库是没有调试符号的，因而 GDB 会提示找不到这些库的调试符号。因为目的是调试 chatserver，对系统 API 调用的内部实现并不关注，所以这些提示可以不用关注，只要 chatserver 这个文件有调试信息即可。</p><p>当用 gdb attach 上目标进程后，调试器会暂停下来，此时可以使用 continue 命令让程序继续运行，或者加上相应的断点再继续运行程序（这里提到的 continue 命令不熟悉也没有关系，后续会详细介绍这些命令的使用方法）。</p><p>当调试完程序想结束此次调试时，而且不对当前进程 chatserver 有任何影响，也就是说想让这个程序继续运行，可以在 GDB 的命令行界面输入 detach 命令让程序与 GDB 调试器分离，这样 chatserver 就可以继续运行了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) detach</span><br><span class="line">Detaching from program: /home/zhangyl/flamingoserver/chatserver, process 42921</span><br></pre></td></tr></table></figure><p>然后再退出 GDB 就可以了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) quit</span><br><span class="line">[zhangyl@localhost flamingoserver]$</span><br></pre></td></tr></table></figure><h2 id="调试-core-文件"><a href="#调试-core-文件" class="headerlink" title="调试 core 文件"></a>调试 core 文件</h2><p>有时候，服务器程序运行一段时间后会突然崩溃，这并不是我们希望看到的，需要解决这个问题。只要程序在崩溃的时候有 core 文件产生，就可以使用这个 core 文件来定位崩溃的原因。当然，Linux 系统默认是不开启程序崩溃产生 core 文件这一机制的，我们可以使用 ulimit -c 命令来查看系统是否开启了这一机制。</p><blockquote><p>顺便提一句，ulimit 这个命令不仅仅可以查看 core 文件生成是否开启，还可以查看其他的一些功能，比如系统允许的最大文件描述符的数量等，具体可以使用 ulimit -a 命令来查看，由于这个内容与本课主题无关，这里不再赘述。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[zhangyl@localhost flamingoserver]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) 0</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15045</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 4096</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><p>发现 core file size 那一行默认是 0，表示关闭生成 core 文件，可以使用“ulimit 选项名 设置值”来修改。例如，可以将 core 文件生成改成具体某个值（最大允许的字节数），这里我们使用 <strong>ulimit -c unlimited</strong>（<strong>unlimited</strong> 是 -c 选项值）直接修改成不限制大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[zhangyl@localhost flamingoserver]$ ulimit -c unlimited</span><br><span class="line">[zhangyl@localhost flamingoserver]$ ulimit -a</span><br><span class="line">core file size          (blocks, -c) unlimited</span><br><span class="line">data seg size           (kbytes, -d) unlimited</span><br><span class="line">scheduling priority             (-e) 0</span><br><span class="line">file size               (blocks, -f) unlimited</span><br><span class="line">pending signals                 (-i) 15045</span><br><span class="line">max locked memory       (kbytes, -l) 64</span><br><span class="line">max memory size         (kbytes, -m) unlimited</span><br><span class="line">open files                      (-n) 1024</span><br><span class="line">pipe size            (512 bytes, -p) 8</span><br><span class="line">POSIX message queues     (bytes, -q) 819200</span><br><span class="line">real-time priority              (-r) 0</span><br><span class="line">stack size              (kbytes, -s) 8192</span><br><span class="line">cpu time               (seconds, -t) unlimited</span><br><span class="line">max user processes              (-u) 4096</span><br><span class="line">virtual memory          (kbytes, -v) unlimited</span><br><span class="line">file locks                      (-x) unlimited</span><br></pre></td></tr></table></figure><blockquote><p>注意，这个命令容易记错，第一个 ulimit 是 <strong>Linux</strong> 命令， -c 选项后面的 unlimited 是<strong>选项的值</strong>，表示不限制大小，当然也可以改成具体的数值大小。很多初学者在学习这个命令时，总是把 <strong>ulimit 命令</strong>和 <strong>unlimited 取值</strong>搞混淆，如果读者能理解其含义，一般就不会混淆了。</p></blockquote><p>还有一个问题就是，这样修改以后，当我们关闭这个 Linux 会话，设置项的值就会被还原成 0，而服务器程序一般是以后台程序（守护进程）长周期运行，也就是说当前会话虽然被关闭，服务器程序仍然继续在后台运行，这样这个程序在某个时刻崩溃后，是无法产生 core 文件的，这种情形不利于排查问题。因此，我们希望这个选项永久生效，永久生效的方式是把“ulimit -c unlimited”这一行加到 /etc/profile 文件中去，放到这个文件最后一行即可。</p><h3 id="具体的例子"><a href="#具体的例子" class="headerlink" title="具体的例子"></a>具体的例子</h3><p>生成的 core 文件的默认命名方式是 core.pid，举个例子，比如某个程序当时运行时其进程 ID 是 16663，那么它崩溃产生的 core 文件的名称就是 core.16663。我们来看一个具体的例子，某次我发现服务器上的 msg_server 崩溃了，产生了一个如下的 core 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw------- 1 root root 10092544 Sep  9 15:14 core.21985</span><br></pre></td></tr></table></figure><p>就可以通过这个 core.21985 文件来排查崩溃的原因，调试 core 文件的命令是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb filename corename</span><br></pre></td></tr></table></figure><p>其中，filename 就是程序名，这里就是 msg_server；corename 是 core.21985，我们输入 gdb msg_server core.21985 来启动调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@myaliyun msg_server]# gdb msg_server core.21985</span><br><span class="line">Reading symbols from /root/teamtalkserver/src/msg_server/msg_server...done.</span><br><span class="line">[New LWP 21985]</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">Core was generated by `./msg_server -d'.</span><br><span class="line">Program terminated with signal 11, Segmentation fault.</span><br><span class="line">#0  0x00000000004ceb1f in std::less&lt;CMsgConn*&gt;::operator() (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430, __y=@0x51: &lt;error reading variable&gt;)</span><br><span class="line">    at /usr/include/c++/4.8.2/bits/stl_function.h:235</span><br><span class="line">235           { return __x &lt; __y; }</span><br></pre></td></tr></table></figure><p>可以看到程序崩溃的地方是在 stl_function.h 的第 235 行，然后通过 <strong>bt</strong> 命令（后续将详细介绍该命令）查看崩溃时的调用堆栈，进一步分析就能找到崩溃的原因。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  0x00000000004ceb1f in std::less&lt;CMsgConn*&gt;::operator() (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430, __y=@0x51: &lt;error reading variable&gt;)</span><br><span class="line">    at /usr/include/c++/4.8.2/bits/stl_function.h:235</span><br><span class="line">#1  0x00000000004cdd70 in std::_Rb_tree&lt;CMsgConn*, CMsgConn*, std::_Identity&lt;CMsgConn*&gt;, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::_M_get_insert_unique_pos</span><br><span class="line">    (this=0x2283878, __k=@0x7ffca83563a0: 0x2284430) at /usr/include/c++/4.8.2/bits/stl_tree.h:1324</span><br><span class="line">#2  0x00000000004cd18a in std::_Rb_tree&lt;CMsgConn*, CMsgConn*, std::_Identity&lt;CMsgConn*&gt;, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::_M_insert_unique&lt;CMsgConn* const&amp;&gt; (this=0x2283878, __v=@0x7ffca83563a0: 0x2284430) at /usr/include/c++/4.8.2/bits/stl_tree.h:1377</span><br><span class="line">#3  0x00000000004cc8bd in std::set&lt;CMsgConn*, std::less&lt;CMsgConn*&gt;, std::allocator&lt;CMsgConn*&gt; &gt;::insert (this=0x2283878, __x=@0x7ffca83563a0: 0x2284430)</span><br><span class="line">    at /usr/include/c++/4.8.2/bits/stl_set.h:463</span><br><span class="line">#4  0x00000000004cb011 in CImUser::AddUnValidateMsgConn (this=0x2283820, pMsgConn=0x2284430) at /root/teamtalkserver/src/msg_server/ImUser.h:42</span><br><span class="line">#5  0x00000000004c64ae in CDBServConn::_HandleValidateResponse (this=0x227f6a0, pPdu=0x22860d0) at /root/teamtalkserver/src/msg_server/DBServConn.cpp:319</span><br><span class="line">#6  0x00000000004c5e3d in CDBServConn::HandlePdu (this=0x227f6a0, pPdu=0x22860d0) at /root/teamtalkserver/src/msg_server/DBServConn.cpp:203</span><br><span class="line">#7  0x00000000005022b3 in CImConn::OnRead (this=0x227f6a0) at /root/teamtalkserver/src/base/imconn.cpp:148</span><br><span class="line">#8  0x0000000000501db3 in imconn_callback (callback_data=0x7f4b20 &lt;g_db_server_conn_map&gt;, msg=3 '\003', handle=8, pParam=0x0)</span><br><span class="line">    at /root/teamtalkserver/src/base/imconn.cpp:47</span><br><span class="line">#9  0x0000000000504025 in CBaseSocket::OnRead (this=0x227f820) at /root/teamtalkserver/src/base/BaseSocket.cpp:178</span><br><span class="line">#10 0x0000000000502f8a in CEventDispatch::StartDispatch (this=0x2279990, wait_timeout=100) at /root/teamtalkserver/src/base/EventDispatch.cpp:386</span><br><span class="line">#11 0x00000000004fddbe in netlib_eventloop (wait_timeout=100) at /root/teamtalkserver/src/base/netlib.cpp:160</span><br><span class="line">#12 0x00000000004d18c2 in main (argc=2, argv=0x7ffca8359978) at /root/teamtalkserver/src/msg_server/msg_server.cpp:213</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>堆栈 #4 就不是库代码了，我们可以排查这里的代码，然后找到问题原因。</p><h3 id="自定义-core-文件名称"><a href="#自定义-core-文件名称" class="headerlink" title="自定义 core 文件名称"></a>自定义 core 文件名称</h3><p>但是细心的读者会发现一个问题：一个正在程序运行时，其 PID 是可以获取到的，但是当程序崩溃后，产生了 core 文件，尤其是多个程序同时崩溃，我们根本没法通过 core 文件名称中的 PID 来区分到底是哪个服务解决这个问题有两个方法：</p><ul><li>程序启动时，记录一下自己的 PID<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void writePid()</span><br><span class="line">{</span><br><span class="line">      uint32_t curPid = (uint32_t) getpid();</span><br><span class="line">      FILE* f = fopen("xxserver.pid", "w");</span><br><span class="line">      assert(f);</span><br><span class="line">      char szPid[32];</span><br><span class="line">      snprintf(szPid, sizeof(szPid), "%d", curPid);</span><br><span class="line">      fwrite(szPid, strlen(szPid), 1, f);</span><br><span class="line">      fclose(f);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>我们在程序启动时调用上述 <strong>writePID</strong> 函数，将程序当时的 PID 记录到 <strong>xxserver.pid</strong> 文件中去，这样当程序崩溃时，可以从这个文件中得到进程当时运行的 PID，这样就可以与默认的 core 文件名后面的 PID 做匹配了。</li><li>自定义 core 文件的名称和目录<br><code>/proc/sys/kernel/core_uses_pid</code> 可以控制产生的 core 文件的文件名中是否添加 PID 作为扩展，如果添加则文件内容为 1，否则为 0；**/proc/sys/kernel/core_pattern** 可以设置格式化的 core 文件保存位置或文件名。修改方式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "/corefile/core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>各个参数的说明如下：</li></ul><table><thead><tr><th><strong>参数名称</strong></th><th><strong>参数含义（英文）</strong></th><th><strong>参数含义（中文）</strong></th></tr></thead><tbody><tr><td>%p</td><td>insert pid into filename</td><td>添加 pid 到 core 文件名中</td></tr><tr><td>%u</td><td>insert current uid into filename</td><td>添加当前 uid 到 core 文件名中</td></tr><tr><td>%g</td><td>insert current gid into filename</td><td>添加当前 gid 到 core 文件名中</td></tr><tr><td>%s</td><td>insert signal that caused the coredump into the filename</td><td>添加导致产生 core 的信号到 core 文件名中</td></tr><tr><td>%t</td><td>insert UNIX time that the coredump occurred into filename</td><td>添加 core 文件生成时间（UNIX）到 core 文件名中</td></tr><tr><td>%h</td><td>insert hostname where the coredump happened into filename</td><td>添加主机名到 core 文件名中</td></tr><tr><td>%e</td><td>insert coredumping executable name into filename</td><td>添加程序名到 core 文件名中</td></tr></tbody></table><p>假设现在的程序叫 <strong>test</strong>，我们设置该程序崩溃时的 core 文件名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "/root/testcore/core-%e-%p-%t" &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>那么最终会在 /root/testcore/ 目录下生成的 test 的 core 文件名格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-------. 1 root root 409600 Jan 14 13:54 core-test-13154-1547445291</span><br></pre></td></tr></table></figure><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb4.20p39qxvzn4w.jpg" alt="gdb4"></p><blockquote><p>需要注意的是，您使用的用户必须对指定 core 文件目录具有写权限，否则生成时 会因为权限不足而导致无法生成 core 文件。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="本节课介绍了使用-GDB-调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。"><a href="#本节课介绍了使用-GDB-调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。" class="headerlink" title="本节课介绍了使用 GDB 调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。"></a>本节课介绍了使用 GDB 调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。</h3><hr><p>来源:<a class="link" target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/column/5c0e149eedba1b683458fd5f">范蠡《Linux GDB 调试指南》<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：启动 GDB 调试</li><li>本文作者：白羽近墨</li><li>创建时间：2021-10-10 15:44:40</li><li>本文链接：https://keep.xpoet.cn/2021/10/10/GDB-0/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/C-%E5%BC%80%E5%8F%91/">#C++ 开发</a>&nbsp;</li><li class="tag-item"><a href="/tags/GDB/">#GDB</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/10/10/GDB-1/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">GDB 常用命令详解（上）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/10/09/Linux-CPP-1/"><span class="title flex-center"><span class="post-nav-title-item">Linux C++ 开发 第一讲</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"irqOqaGORMEoxUV1bBigEGyr-gzGzoHsz",appKey:"Dkd9JB0KYotx5nS6IA6PKB6f",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="白羽近墨";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),r=n.innerHTML;r===t&&(n.innerHTML=`${r} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">白羽近墨</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E4%B9%90%E5%B0%8F%E6%B8%AF"><span class="nav-number">1.</span> <span class="nav-text">音乐小港</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8-GDB-%E8%B0%83%E8%AF%95"><span class="nav-number"></span> <span class="nav-text">启动 GDB 调试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E8%B0%83%E8%AF%95%E7%9B%AE%E6%A0%87%E7%A8%8B%E5%BA%8F"><span class="nav-number"></span> <span class="nav-text">直接调试目标程序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%99%84%E5%8A%A0%E8%BF%9B%E7%A8%8B"><span class="nav-number"></span> <span class="nav-text">附加进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E8%AF%95-core-%E6%96%87%E4%BB%B6"><span class="nav-number"></span> <span class="nav-text">调试 core 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-number"></span> <span class="nav-text">具体的例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-core-%E6%96%87%E4%BB%B6%E5%90%8D%E7%A7%B0"><span class="nav-number"></span> <span class="nav-text">自定义 core 文件名称</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E8%AF%BE%E4%BB%8B%E7%BB%8D%E4%BA%86%E4%BD%BF%E7%94%A8-GDB-%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E7%90%86%E8%A7%A3%E5%B9%B6%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8%E8%BF%99%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%8F%AF%E4%BB%A5%E5%B8%AE%E5%8A%A9%E8%AF%BB%E8%80%85%E5%9C%A8%E9%81%87%E5%88%B0%E9%97%AE%E9%A2%98%E6%97%B6%E5%87%86%E7%A1%AE%E5%9C%B0%E9%80%89%E6%8B%A9%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E3%80%82"><span class="nav-number"></span> <span class="nav-text">本节课介绍了使用 GDB 调试程序的三种方式，理解并熟练使用这三种方式可以帮助读者在遇到问题时准确地选择调试方法。</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>