<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="keywords" content="Hexo Theme Keep"><meta name="description" content="blog"><meta name="author" content="白羽近墨"><title>GDB 常用命令详解（上） | 白羽小站</title><link rel="stylesheet" href="/css/style.css"><link rel="shortcut icon" href="/images/mylogo.svg"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/css/font-awesome.min.css"><script id="hexo-configurations">let KEEP=window.KEEP||{};KEEP.hexo_config={hostname:"example.com",root:"/",language:"zh-CN",path:"search.json"},KEEP.theme_config={toc:{enable:!0,number:!0,expand_all:!1,init_open:!0},style:{primary_color:"#0066CC",avatar:"/images/author.svg",favicon:"/images/mylogo.svg",article_img_align:"center",left_side_width:"260px",content_max_width:"920px",hover:{shadow:!0,scale:!0},first_screen:{enable:!0,background_img:"/images/bg.svg",description:"种一棵树，最好的时间是十年前,其次是现在。"},scroll:{progress_bar:{enable:!0},percent:{enable:!0}}},local_search:{enable:!0,preload:!0},code_copy:{enable:!0,style:"default"},pjax:{enable:!0},lazyload:{enable:!0},version:"3.4.5"},KEEP.language_ago={second:"%s 秒前",minute:"%s 分钟前",hour:"%s 小时前",day:"%s 天前",week:"%s 周前",month:"%s 个月前",year:"%s 年前"}</script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax=SVG]{direction:ltr}mjx-container[jax=SVG]>svg{overflow:visible}mjx-container[jax=SVG][display=true]{display:block;text-align:center;margin:1em 0}mjx-container[jax=SVG][justify=left]{text-align:left}mjx-container[jax=SVG][justify=right]{text-align:right}g[data-mml-node=merror]>g{fill:red;stroke:red}g[data-mml-node=merror]>rect[data-background]{fill:#ff0;stroke:none}g[data-mml-node=mtable]>line[data-line]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>rect[data-frame]{stroke-width:70px;fill:none}g[data-mml-node=mtable]>.mjx-dashed{stroke-dasharray:140}g[data-mml-node=mtable]>.mjx-dotted{stroke-linecap:round;stroke-dasharray:0,140}g[data-mml-node=mtable]>svg{overflow:visible}[jax=SVG] mjx-tool{display:inline-block;position:relative;width:0;height:0}[jax=SVG] mjx-tool>mjx-tip{position:absolute;top:0;left:0}mjx-tool>mjx-tip{display:inline-block;padding:.2em;border:1px solid #888;font-size:70%;background-color:#f8f8f8;color:#000;box-shadow:2px 2px 5px #aaa}g[data-mml-node=maction][data-toggle]{cursor:pointer}mjx-status{display:block;position:fixed;left:1em;bottom:1em;min-width:25%;padding:.2em .4em;border:1px solid #888;font-size:90%;background-color:#f8f8f8;color:#000}foreignObject[data-mjx-xml]{font-family:initial;line-height:normal;overflow:visible}.MathJax path{stroke-width:3}mjx-container[display=true]{overflow:auto hidden}mjx-container[display=true]+br{display:none}</style><link rel="alternate" href="/atom.xml" title="baiyu" type="application/atom+xml">
<link rel="stylesheet" href="\assets\css\APlayer.min.css" class="aplayer-style-marker">
<script src="\assets\js\APlayer.min.js" class="aplayer-script-marker"></script>
<script src="\assets\js\Meting.min.js" class="meting-script-marker"></script>
</head><body><div class="progress-bar-container"><span class="scroll-progress-bar"></span> <span class="pjax-progress-bar"></span> <span class="pjax-progress-icon"><i class="fas fa-circle-notch fa-spin"></i></span></div><main class="page-container"><div class="page-main-content"><div class="page-main-content-top"><header class="header-wrapper"><div class="header-content"><div class="left"><a class="logo-image" href="/"><img src="/images/mylogo.svg"> </a><a class="logo-title" href="/">白羽小站</a></div><div class="right"><div class="pc"><ul class="menu-list"><li class="menu-item"><a href="/">首页</a></li><li class="menu-item"><a href="/archives">归档</a></li><li class="menu-item"><a href="/categories">分类</a></li><li class="menu-item"><a href="/tags">标签</a></li><li class="menu-item"><a href="/links">友链</a></li><li class="menu-item"><a href="/about">关于</a></li><li class="menu-item search search-popup-trigger"><i class="fas fa-search"></i></li></ul></div><div class="mobile"><div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div><div class="icon-item menu-bar"><div class="menu-bar-middle"></div></div></div></div></div><div class="header-drawer"><ul class="drawer-menu-list"><li class="drawer-menu-item flex-center"><a href="/">首页</a></li><li class="drawer-menu-item flex-center"><a href="/archives">归档</a></li><li class="drawer-menu-item flex-center"><a href="/categories">分类</a></li><li class="drawer-menu-item flex-center"><a href="/tags">标签</a></li><li class="drawer-menu-item flex-center"><a href="/links">友链</a></li><li class="drawer-menu-item flex-center"><a href="/about">关于</a></li></ul></div><div class="window-mask"></div></header></div><div class="page-main-content-middle"><div class="main-content"><div class="fade-in-down-animation"><div class="article-content-container"><div class="article-title"><span class="title-hover-animation">GDB 常用命令详解（上）</span></div><div class="article-header"><div class="avatar"><img src="/images/author.svg"></div><div class="info"><div class="author"><span class="name">白羽近墨</span> <span class="author-label">Lv5</span></div><div class="meta-info"><div class="article-meta-info"><span class="article-date article-meta-item"><i class="fas fa-edit"></i>&nbsp; <span class="pc">2021-10-10 16:16:02</span> <span class="mobile">2021-10-10 16:16</span> </span><span class="article-categories article-meta-item"><i class="fas fa-folder"></i>&nbsp;<ul><li><a href="/categories/Linux-GDB-%E8%B0%83%E8%AF%95%E6%8C%87%E5%8D%97/">Linux GDB 调试指南</a>&nbsp;</li></ul></span><span class="article-tags article-meta-item"><i class="fas fa-tags"></i>&nbsp;<ul><li><a href="/tags/Linux/">Linux</a>&nbsp;</li><li>| <a href="/tags/C-%E5%BC%80%E5%8F%91/">C++ 开发</a>&nbsp;</li><li>| <a href="/tags/GDB/">GDB</a>&nbsp;</li></ul></span><span class="article-wordcount article-meta-item"><i class="fas fa-file-word"></i>&nbsp;<span>5.6k 字</span> </span><span class="article-min2read article-meta-item"><i class="fas fa-clock"></i>&nbsp;<span>26 分钟</span> </span><span class="article-pv article-meta-item"><i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span></span></div></div></div></div><div class="article-content markdown-body"><h4 id="音乐小港"><a href="#音乐小港" class="headerlink" title="音乐小港"></a>音乐小港</h4><div id="aplayer-dtpqUCCl" class="aplayer aplayer-tag-marker meting-tag-marker" data-id="532776335" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"></div><hr><h1 id="GDB-常用命令详解（上）"><a href="#GDB-常用命令详解（上）" class="headerlink" title="GDB 常用命令详解（上）"></a>GDB 常用命令详解（上）</h1><p>本课的核心内容如下：</p><ul><li>run 命令</li><li>continue 命令</li><li>break 命令</li><li>backtrace 与 frame 命令</li><li>info break、enable、disable 和 delete 命令</li><li>list 命令</li><li>print 和 ptype 命令</li></ul><p>为了结合实践，这里以调试 Redis 源码为例来介绍每一个命令，先介绍一些常用命令的基础用法，某些命令的高级用法会在后面讲解。</p><h2 id="Redis-源码下载与-debug-版本编译"><a href="#Redis-源码下载与-debug-版本编译" class="headerlink" title="Redis 源码下载与 debug 版本编译"></a>Redis 源码下载与 debug 版本编译</h2><p>Redis 的最新源码下载地址可以在 Redis 官网获得，使用 wget 命令将 Redis 源码文件下载下来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost gdbtest]# wget http://download.redis.io/releases/redis-4.0.11.tar.gz</span><br><span class="line">--2018-09-08 13:08:41--  http://download.redis.io/releases/redis-4.0.11.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 109.74.203.151</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1739656 (1.7M) [application/x-gzip]</span><br><span class="line">Saving to: ‘redis-4.0.11.tar.gz’</span><br><span class="line"></span><br><span class="line">54% [==================================================================&gt;                                                         ] 940,876     65.6KB/s  eta 9s</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost gdbtest]# tar zxvf redis-4.0.11.tar.gz</span><br></pre></td></tr></table></figure><p>进入生成的 redis-4.0.11 目录使用 <strong>makefile</strong> 命令进行编译。<strong>makefile</strong> 命令是 Linux 程序编译基本的命令，由于本课程的重点是 Linux 调试，如果读者不熟悉 Linux 编译可以通过互联网或相关书籍补充一下相关知识。</p><p>为了方便调试，我们需要生成调试符号并且关闭编译器优化选项，操作如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost gdbtest]# cd redis-4.0.11</span><br><span class="line">[root@localhost redis-4.0.11]# make CFLAGS="-g -O0" -j 4</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于 redis 是纯 C 项目，使用的编译器是 gcc，因而这里设置编译器的选项时使用的是 CFLAGS 选项；如果项目使用的语言是 C++，那么使用的编译器一般是 g++，相对应的编译器选项是 CXXFLAGS。这点请读者注意区别。</p><p>另外，这里 makefile 使用了 -j 选项，其值是 4，表示开启 4 个进程同时编译，加快编译速度。</p></blockquote><p>编译成功后，会在 src 目录下生成多个可执行程序，其中 redis-server 和 redis-cli 是需要调试的程序。</p><p>进入 src 目录，使用 GDB 启动 redis-server 这个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# gdb redis-server</span><br><span class="line">Reading symbols from /root/gdbtest/redis-4.0.11/src/redis-server...done.</span><br></pre></td></tr></table></figure><h2 id="run-命令"><a href="#run-命令" class="headerlink" title="run 命令"></a>run 命令</h2><p>默认情况下，前面的课程中我们说 <strong>gdb filename</strong> 命令只是附加的一个调试文件，并没有启动这个程序，需要输入 <strong>run</strong> 命令（简写为 r）启动这个程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">46455:C 08 Sep 13:43:43.957 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">46455:C 08 Sep 13:43:43.957 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46455, just started</span><br><span class="line">46455:C 08 Sep 13:43:43.957 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf</span><br><span class="line">46455:M 08 Sep 13:43:43.957 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line">[New Thread 0x7ffff07ff700 (LWP 46459)]</span><br><span class="line">[New Thread 0x7fffefffe700 (LWP 46460)]</span><br><span class="line">[New Thread 0x7fffef7fd700 (LWP 46461)]</span><br><span class="line">                _._</span><br><span class="line">           _.-``__ ''-._</span><br><span class="line">      _.-``    `.  `_.  ''-._           Redis 4.0.11 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ ''-._</span><br><span class="line"> (    '      ,       .-`  | `,    )     Running in standalone mode</span><br><span class="line"> |`-._`-...-` __...-.``-._|'` _.-'|     Port: 6379</span><br><span class="line"> |    `-._   `._    /     _.-'    |     PID: 46455</span><br><span class="line">  `-._    `-._  `-./  _.-'    _.-'</span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|</span><br><span class="line"> |    `-._`-._        _.-'_.-'    |     http://redis.io</span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'</span><br><span class="line"> |`-._`-._    `-.__.-'    _.-'_.-'|</span><br><span class="line"> |    `-._`-._        _.-'_.-'    |</span><br><span class="line">  `-._    `-._`-.__.-'_.-'    _.-'</span><br><span class="line">      `-._    `-.__.-'    _.-'</span><br><span class="line">          `-._        _.-'</span><br><span class="line">              `-.__.-'</span><br><span class="line"></span><br><span class="line">46455:M 08 Sep 13:43:43.965 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span><br><span class="line">46455:M 08 Sep 13:43:43.965 # Server initialized</span><br><span class="line">46455:M 08 Sep 13:43:43.965 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span><br><span class="line">46455:M 08 Sep 13:43:43.965 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command 'echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled' as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</span><br><span class="line">46455:M 08 Sep 13:43:43.965 * Ready to accept connections</span><br></pre></td></tr></table></figure><p>这就是 redis-server 启动界面，假设程序已经启动，再次输入 run 命令则是重启程序。我们在 GDB 界面按 Ctrl + C 快捷键让 GDB 中断下来，再次输入 r 命令，GDB 会询问我们是否重启程序，输入 yes 确认重启。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">Missing separate debuginfos, use: debuginfo-install glibc-2.17-196.el7_4.2.x86_64</span><br><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) yes</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br></pre></td></tr></table></figure><h2 id="continue-命令"><a href="#continue-命令" class="headerlink" title="continue 命令"></a>continue 命令</h2><p>当 GDB 触发断点或者使用 Ctrl + C 命令中断下来后，想让程序继续运行，只要输入 <strong>continue</strong> 命令即可（简写为 c）。当然，如果 <strong>continue</strong> 命令继续触发断点，GDB 就会再次中断下来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">^C</span><br><span class="line">Program received signal SIGINT, Interrupt.</span><br><span class="line">0x00007ffff73ee923 in epoll_wait () from /lib64/libc.so.6</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure><h2 id="break-命令"><a href="#break-命令" class="headerlink" title="break 命令"></a>break 命令</h2><p><strong>break</strong> 命令（简写为 b）即我们添加断点的命令，可以使用以下方式添加断点：</p><ul><li>break functionname，在函数名为 functionname 的入口处添加一个断点；</li><li>break LineNo，在当前文件行号为 LineNo 处添加一个断点；</li><li>break filename:LineNo，在 filename 文件行号为 LineNo 处添加一个断点。<br>这三种方式都是我们常用的添加断点的方式。举个例子，对于一般的 Linux 程序来说，main() 函数是程序入口函数，redis-server 也不例外，我们知道了函数的名字，就可以直接在 main() 函数处添加一个断点：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x423450: file server.c, line 3709.</span><br></pre></td></tr></table></figure>添加好了以后，使用 run 命令重启程序，就可以触发这个断点了，GDB 会停在断点处。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffe648) at server.c:3709</span><br><span class="line">3709    int main(int argc, char **argv) {</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>redis-server 默认端口号是 6379 ，我们知道这个端口号肯定是通过操作系统的 socket API bind() 函数创建的，通过文件搜索，找到调用这个函数的文件，其位于 anet.c 441 行。</li></ul><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb1.5js4ek6xxes0.jpg" alt="gdb1"></p><p>我们使用 <strong>break</strong> 命令在这个地方加一个断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b anet.c:441</span><br><span class="line">Breakpoint 3 at 0x426cf0: file anet.c, line 441</span><br></pre></td></tr></table></figure><p>由于程序绑定端口号是 redis-server 启动时初始化的，为了能触发这个断点，再次使用 run 命令重启下这个程序，GDB 第一次会触发 main() 函数处的断点，输入 continue 命令继续运行，接着触发 anet.c:441 处的断点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=1, argv=0x7fffffffe648) at server.c:3709</span><br><span class="line">3709    int main(int argc, char **argv) {</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">46699:C 08 Sep 15:30:31.403 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">46699:C 08 Sep 15:30:31.403 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46699, just started</span><br><span class="line">46699:C 08 Sep 15:30:31.403 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf</span><br><span class="line">46699:M 08 Sep 15:30:31.404 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line"></span><br><span class="line">Breakpoint 3, anetListen (err=0x746bb0 &lt;server+560&gt; "", s=10, sa=0x75edb0, len=28, backlog=511) at anet.c:441</span><br><span class="line">441         if (bind(s,sa,len) == -1) {</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>anet.c:441 处的代码如下：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb2.1rsl9bdfej34.jpg" alt="gdb2"></p><p>现在断点停在第 441 行，所以当前文件就是 anet.c，可以直接使用“break 行号”添加断点。例如，可以在第 444 行、450 行、452 行分别加一个断点，看看这个函数执行完毕后走哪个 return 语句退出，则可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">440     static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int                               backlog) {</span><br><span class="line">441         if (bind(s,sa,len) == -1) {</span><br><span class="line">442             anetSetError(err, "bind: %s", strerror(errno));</span><br><span class="line">443             close(s);</span><br><span class="line">444             return ANET_ERR;</span><br><span class="line">(gdb) l</span><br><span class="line">445         }</span><br><span class="line">446</span><br><span class="line">447         if (listen(s, backlog) == -1) {</span><br><span class="line">448             anetSetError(err, "listen: %s", strerror(errno));</span><br><span class="line">449             close(s);</span><br><span class="line">450             return ANET_ERR;</span><br><span class="line">451         }</span><br><span class="line">452         return ANET_OK;</span><br><span class="line">453     }</span><br><span class="line">454</span><br><span class="line">(gdb) b 444</span><br><span class="line">Breakpoint 3 at 0x426cf5: file anet.c, line 444.</span><br><span class="line">(gdb) b 450</span><br><span class="line">Breakpoint 4 at 0x426d06: file anet.c, line 450.</span><br><span class="line">(gdb) b 452</span><br><span class="line">Note: breakpoint 4 also set at pc 0x426d06.</span><br><span class="line">Breakpoint 5 at 0x426d06: file anet.c, line 452.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>添加好这三个断点以后，我们使用 <strong>continue</strong> 命令继续运行程序，发现程序运行到第 452 行中断下来（即触发 Breakpoint 5）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 5, anetListen (err=0x746bb0 &lt;server+560&gt; "", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:452</span><br><span class="line">452         return ANET_OK;</span><br></pre></td></tr></table></figure><p>说明 redis-server 绑定端口号并设置侦听（listen）成功，我们可以再打开一个 SSH 窗口，验证一下，发现 6379 端口确实已经处于侦听状态了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost src]# lsof -i -Pn | grep redis</span><br><span class="line">redis-ser 46699    root   10u  IPv6 245844      0t0  TCP *:6379 (LISTEN)</span><br></pre></td></tr></table></figure><h2 id="backtrace-与-frame-命令"><a href="#backtrace-与-frame-命令" class="headerlink" title="backtrace 与 frame 命令"></a>backtrace 与 frame 命令</h2><p><strong>backtrace</strong> 命令（简写为 bt）用来查看当前调用堆栈。接上，redis-server 现在中断在 anet.c:452 行，可以通过 backtrace 命令来查看当前的调用堆栈：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  anetListen (err=0x746bb0 &lt;server+560&gt; "", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:452</span><br><span class="line">#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)</span><br><span class="line">    at anet.c:487</span><br><span class="line">#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)</span><br><span class="line">    at anet.c:510</span><br><span class="line">#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728</span><br><span class="line">#4  0x000000000042fa77 in initServer () at server.c:1852</span><br><span class="line">#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>这里一共有 6 层堆栈，最顶层是 main() 函数，最底层是断点所在的 anetListen() 函数，堆栈编号分别是 #0 ~ #5 ，如果想切换到其他堆栈处，可以使用 frame 命令（简写为 f），该命令的使用方法是“<strong>frame 堆栈编号</strong>（编号不加 #）”。在这里依次切换至堆栈顶部，然后再切换回 #0 练习一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 1</span><br><span class="line">#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)</span><br><span class="line">    at anet.c:487</span><br><span class="line">487             if (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">(gdb) f 2</span><br><span class="line">#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)</span><br><span class="line">    at anet.c:510</span><br><span class="line">510         return _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);</span><br><span class="line">(gdb) f 3</span><br><span class="line">#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728</span><br><span class="line">1728                fds[*count] = anetTcp6Server(server.neterr,port,NULL,</span><br><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000042fa77 in initServer () at server.c:1852</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">(gdb) f 5</span><br><span class="line">#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862</span><br><span class="line">3862        initServer();</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>通过查看上面的各个堆栈，可以得出这里的调用层级关系，即：</p><ul><li>main() 函数在第 3862 行调用了 initServer() 函数</li><li>initServer() 在第 1852 行调用了 listenToPort() 函数</li><li>listenToPort() 在第 1728 行调用了 anetTcp6Server() 函数</li><li>anetTcp6Server() 在第 510 行调用了 _anetTcpServer() 函数</li><li>_anetTcpServer() 函数在第 487 行调用了 anetListen() 函数</li><li>当前断点正好位于 anetListen() 函数中<h2 id="info-break、enable、disable-和-delete-命令"><a href="#info-break、enable、disable-和-delete-命令" class="headerlink" title="info break、enable、disable 和 delete 命令"></a>info break、enable、disable 和 delete 命令</h2>在程序中加了很多断点，而我们想查看加了哪些断点时，可以使用 <strong>info break</strong> 命令（简写为 info b）：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000423450 in main at server.c:3709</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:267</span><br><span class="line">3       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452</span><br><span class="line">        breakpoint already hit 1 time</span><br></pre></td></tr></table></figure>通过上面的内容片段可以知道，目前一共增加了 6 个断点，除了断点 2 以外，其他的断点均被触发一次，其他信息比如每个断点的位置（所在的文件和行号）、内存地址、断点启用和禁用状态信息也一目了然。如果我们想禁用某个断点，使用“<strong>disable 断点编号</strong>”就可以禁用这个断点了，被禁用的断点不会再被触发；同理，被禁用的断点也可以使用“<strong>enable 断点编号</strong>”重新启用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable 1</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000423450 in main at server.c:3709</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:267</span><br><span class="line">3       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452</span><br><span class="line">        breakpoint already hit 1 time</span><br></pre></td></tr></table></figure>使用 <strong>disable 1</strong> 以后，第一个断点的 Enb 一栏的值由 y 变成 n，重启程序也不会再次触发：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /root/gdbtest/redis-4.0.11/src/redis-server</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library "/lib64/libthread_db.so.1".</span><br><span class="line">46795:C 08 Sep 16:15:55.681 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">46795:C 08 Sep 16:15:55.681 # Redis version=4.0.11, bits=64, commit=00000000, modified=0, pid=46795, just started</span><br><span class="line">46795:C 08 Sep 16:15:55.681 # Warning: no config file specified, using the default config. In order to specify a config file use /root/gdbtest/redis-4.0.11/src/redis-server /path/to/redis.conf</span><br><span class="line">46795:M 08 Sep 16:15:55.682 * Increased maximum number of open files to 10032 (it was originally set to 1024).</span><br><span class="line"></span><br><span class="line">Breakpoint 3, anetListen (err=0x746bb0 &lt;server+560&gt; "", s=10, sa=0x75edb0, len=28, backlog=511) at anet.c:441</span><br><span class="line">441         if (bind(s,sa,len) == -1) {</span><br></pre></td></tr></table></figure>如果 <strong>disable</strong> 命令和 <strong>enable</strong> 命令不加断点编号，则分别表示禁用和启用所有断点：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep n   0x0000000000423450 in main at server.c:3709</span><br><span class="line">2       breakpoint     keep n   0x000000000049c1f0 in _redisContextConnectTcp at net.c:267</span><br><span class="line">3       breakpoint     keep n   0x0000000000426cf0 in anetListen at anet.c:441</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">4       breakpoint     keep n   0x0000000000426d05 in anetListen at anet.c:444</span><br><span class="line">5       breakpoint     keep n   0x0000000000426d16 in anetListen at anet.c:450</span><br><span class="line">6       breakpoint     keep n   0x0000000000426d16 in anetListen at anet.c:452</span><br><span class="line">(gdb) enable</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000423450 in main at server.c:3709</span><br><span class="line">2       breakpoint     keep y   0x000000000049c1f0 in _redisContextConnectTcp at net.c:267</span><br><span class="line">3       breakpoint     keep y   0x0000000000426cf0 in anetListen at anet.c:441</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444</span><br><span class="line">5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450</span><br><span class="line">6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>使用“<strong>delete 编号</strong>”可以删除某个断点，如 <strong>delete 2 3</strong> 则表示要删除的断点 2 和断点 3：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) delete 2 3</span><br><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000423450 in main at server.c:3709</span><br><span class="line">4       breakpoint     keep y   0x0000000000426d05 in anetListen at anet.c:444</span><br><span class="line">5       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:450</span><br><span class="line">6       breakpoint     keep y   0x0000000000426d16 in anetListen at anet.c:452</span><br></pre></td></tr></table></figure>同样的道理，如果输入 delete 不加命令号，则表示删除所有断点。</li></ul><h2 id="list-命令"><a href="#list-命令" class="headerlink" title="list 命令"></a>list 命令</h2><p><strong>list</strong> 命令和后面介绍的 <strong>print</strong> 命令都是 GDB 调试中用到的频率最高的命令，<strong>list</strong> 命令（简写为 l）可以查看当前断点处的代码。使用 <strong>frame</strong> 命令切换到刚才的堆栈 #3 处，然后输入 <strong>list</strong> 命令看下效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000042fa77 in initServer () at server.c:1852</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">(gdb) l</span><br><span class="line">1847        }</span><br><span class="line">1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);</span><br><span class="line">1849</span><br><span class="line">1850        /* Open the TCP listening socket for the user commands. */</span><br><span class="line">1851        if (server.port != 0 &amp;&amp;</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">1853            exit(1);</span><br><span class="line">1854</span><br><span class="line">1855        /* Open the listening Unix domain socket. */</span><br><span class="line">1856        if (server.unixsocket != NULL) {</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>断点停在第 1852 行，输入 list 命令以后，会显示第 1852 行前后的 10 行代码，再次输入 list 命令试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">1857            unlink(server.unixsocket); /* don't care if this fails */</span><br><span class="line">1858            server.sofd = anetUnixServer(server.neterr,server.unixsocket,</span><br><span class="line">1859                server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">1860            if (server.sofd == ANET_ERR) {</span><br><span class="line">1861                serverLog(LL_WARNING, "Opening Unix socket: %s", server.neterr);</span><br><span class="line">1862                exit(1);</span><br><span class="line">1863            }</span><br><span class="line">1864            anetNonBlock(NULL,server.sofd);</span><br><span class="line">1865        }</span><br><span class="line">1866</span><br><span class="line">(gdb) l</span><br><span class="line">1867        /* Abort if there are no listening sockets at all. */</span><br><span class="line">1868        if (server.ipfd_count == 0 &amp;&amp; server.sofd &lt; 0) {</span><br><span class="line">1869            serverLog(LL_WARNING, "Configured to not listen anywhere, exiting.");</span><br><span class="line">1870            exit(1);</span><br><span class="line">1871        }</span><br><span class="line">1872</span><br><span class="line">1873        /* Create the Redis databases, and initialize other internal state. */</span><br><span class="line">1874        for (j = 0; j &lt; server.dbnum; j++) {</span><br><span class="line">1875            server.db[j].dict = dictCreate(&amp;dbDictType,NULL);</span><br><span class="line">1876            server.db[j].expires = dictCreate(&amp;keyptrDictType,NULL);</span><br></pre></td></tr></table></figure><p>代码继续往后显示 10 行，也就是说，第一次输入 <strong>list</strong> 命令会显示断点处前后的代码，继续输入 <strong>list</strong> 指令会以递增行号的形式继续显示剩下的代码行，一直到文件结束为止。当然 list 指令还可以往前和往后显示代码，命令分别是“**list + <strong>（加号）”和“</strong>list - **（减号）”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list -</span><br><span class="line">1857            unlink(server.unixsocket); /* don't care if this fails */</span><br><span class="line">1858            server.sofd = anetUnixServer(server.neterr,server.unixsocket,</span><br><span class="line">1859                server.unixsocketperm, server.tcp_backlog);</span><br><span class="line">1860            if (server.sofd == ANET_ERR) {</span><br><span class="line">1861                serverLog(LL_WARNING, "Opening Unix socket: %s", server.neterr);</span><br><span class="line">1862                exit(1);</span><br><span class="line">1863            }</span><br><span class="line">1864            anetNonBlock(NULL,server.sofd);</span><br><span class="line">1865        }</span><br><span class="line">1866</span><br><span class="line">(gdb) l -</span><br><span class="line">1847        }</span><br><span class="line">1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);</span><br><span class="line">1849</span><br><span class="line">1850        /* Open the TCP listening socket for the user commands. */</span><br><span class="line">1851        if (server.port != 0 &amp;&amp;</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">1853            exit(1);</span><br><span class="line">1854</span><br><span class="line">1855        /* Open the listening Unix domain socket. */</span><br><span class="line">1856        if (server.unixsocket != NULL) {</span><br></pre></td></tr></table></figure><p><strong>list</strong> 默认显示多少行可以通过修改相关的 GDB 配置，由于我们一般不会修改这个默认显示行数，这里就不再浪费篇幅介绍了。<strong>list</strong> 不仅可以显示当前断点处的代码，也可以显示其他文件某一行的代码，更多的用法可以在 GDB 中输入 <strong>help list</strong> 查看（也可以通过）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help list</span><br><span class="line">List specified function or line.</span><br><span class="line">With no argument, lists ten more lines after or around previous listing.</span><br><span class="line">"list -" lists the ten lines before a previous ten-line listing.</span><br><span class="line">One argument specifies a line, and ten lines are listed around that line.</span><br><span class="line">Two arguments with comma between specify starting and ending lines to list.</span><br><span class="line">Lines can be specified in these ways:</span><br><span class="line">  LINENUM, to list around that line in current file,</span><br><span class="line">  FILE:LINENUM, to list around that line in that file,</span><br><span class="line">  FUNCTION, to list around beginning of that function,</span><br><span class="line">  FILE:FUNCTION, to distinguish among like-named static functions.</span><br><span class="line">  *ADDRESS, to list around the line containing that address.</span><br><span class="line">With two args if one is empty it stands for ten lines away from the other arg.</span><br></pre></td></tr></table></figure><p>上面的帮助信息中，介绍了可以使用 <strong>list FILE:LINENUM</strong> 来显示某个文件的某一行处的代码，这里不再演示是因为我觉得实用性不大。使用 GDB 的目的是调试，因此更关心的是断点附近的代码，而不是通过 GDB 阅读代码，GDB 并不是一个好的阅读工具。以我自己为例，调试 Redis 时用 GDB 调试，而阅读代码使用的却是 Visual Studio，如下图所示：</p><p><img lazyload="" src="/images/loading.svg" data-src="https://cdn.jsdelivr.net/gh/1258360186/image_hosting@master/20211010/gdb3.7hywlopi9fo0.jpg" alt="gdb3"></p><h2 id="print-和-ptype-命令"><a href="#print-和-ptype-命令" class="headerlink" title="print 和 ptype 命令"></a>print 和 ptype 命令</h2><p>通过 <strong>print</strong> 命令（简写为 p）我们可以在调试过程中方便地查看变量的值，也可以修改当前内存中的变量值。切换当前断点到堆栈 #4 ，然后打印以下三个变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  anetListen (err=0x746bb0 &lt;server+560&gt; "", s=10, sa=0x7e34e0, len=16, backlog=511) at anet.c:447</span><br><span class="line">#1  0x0000000000426e35 in _anetTcpServer (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, af=af@entry=10, backlog=511)</span><br><span class="line">    at anet.c:487</span><br><span class="line">#2  0x000000000042793d in anetTcp6Server (err=err@entry=0x746bb0 &lt;server+560&gt; "", port=port@entry=6379, bindaddr=bindaddr@entry=0x0, backlog=511)</span><br><span class="line">    at anet.c:510</span><br><span class="line">#3  0x000000000042b0bf in listenToPort (port=6379, fds=fds@entry=0x746ae4 &lt;server+356&gt;, count=count@entry=0x746b24 &lt;server+420&gt;) at server.c:1728</span><br><span class="line">#4  0x000000000042fa77 in initServer () at server.c:1852</span><br><span class="line">#5  0x0000000000423803 in main (argc=1, argv=0x7fffffffe648) at server.c:3862</span><br><span class="line">(gdb) f 4</span><br><span class="line">#4  0x000000000042fa77 in initServer () at server.c:1852</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">(gdb) l</span><br><span class="line">1847        }</span><br><span class="line">1848        server.db = zmalloc(sizeof(redisDb)*server.dbnum);</span><br><span class="line">1849</span><br><span class="line">1850        /* Open the TCP listening socket for the user commands. */</span><br><span class="line">1851        if (server.port != 0 &amp;&amp;</span><br><span class="line">1852            listenToPort(server.port,server.ipfd,&amp;server.ipfd_count) == C_ERR)</span><br><span class="line">1853            exit(1);</span><br><span class="line">1854</span><br><span class="line">1855        /* Open the listening Unix domain socket. */</span><br><span class="line">1856        if (server.unixsocket != NULL) {</span><br><span class="line">(gdb) p server.port</span><br><span class="line">$15 = 6379</span><br><span class="line">(gdb) p server.ipfd</span><br><span class="line">$16 = {0 &lt;repeats 16 times&gt;}</span><br><span class="line">(gdb) p server.ipfd_count</span><br><span class="line">$17 = 0</span><br></pre></td></tr></table></figure><p>这里使用 <strong>print</strong> 命令分别打印出 server.port 、server.ipfd 、server.ipfd_count 的值，其中 server.ipfd 显示 “{0 }”，这是 GDB 显示字符串或字符数据特有的方式，当一个字符串变量或者字符数组或者连续的内存值重复若干次，GDB 就会以这种模式来显示以节约空间。</p><p><strong>print</strong> 命令不仅可以显示变量值，也可以显示进行一定运算的表达式计算结果值，甚至可以显示一些函数的执行结果值。</p><p>举个例子，我们可以输入 <strong>p &amp;server.port</strong> 来输出 server.port 的地址值，如果在 C++ 对象中，可以通过 p this 来显示当前对象的地址，也可以通过 p *this 来列出当前对象的各个成员变量值，如果有三个变量可以相加（ 假设变量名分别叫 a、b、c ），可以使用 <strong>p a + b + c</strong> 来打印这三个变量的结果值。</p><p>假设 func() 是一个可以执行的函数，p func() 命令可以输出该变量的执行结果。举一个最常用的例子，某个时刻，某个系统函数执行失败了，通过系统变量 errno 得到一个错误码，则可以使用 p strerror(errno) 将这个错误码对应的文字信息打印出来，这样就不用费劲地去 man 手册上查找这个错误码对应的错误含义了。</p><p>print 命令不仅可以输出表达式结果，同时也可以修改变量的值，我们尝试将上文中的端口号从 6379 改成 6400 试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p server.port=6400</span><br><span class="line">$24 = 6400</span><br><span class="line">(gdb) p server.port</span><br><span class="line">$25 = 6400</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>当然，一个变量值修改后能否起作用要看这个变量的具体位置和作用，举个例子，对于表达式 int a = b / c ; 如果将 c 修改成 0 ，那么程序就会产生除零异常。再例如，对于如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int j = 100;</span><br><span class="line">for (int i = 0; i &lt; j; ++i) {</span><br><span class="line">    printf("i = %d\n", i);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>如果在循环的过程中，利用 <strong>print</strong> 命令将 j 的大小由 100 改成 1000 ，那么这个循环将输出 i 的值 1000 次。</p><p>总结起来，利用 <strong>print</strong> 命令，我们不仅可以查看程序运行过程中的各个变量的状态值，也可以通过临时修改变量的值来控制程序的行为。</p><p>GDB 还有另外一个命令叫 <strong>ptype</strong> ，顾名思义，其含义是“print type”，就是输出一个变量的类型。例如，我们试着输出 Redis 堆栈 #4 的变量 server 和变量 server.port 的类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype server</span><br><span class="line">type = struct redisServer {</span><br><span class="line">    pid_t pid;</span><br><span class="line">    char *configfile;</span><br><span class="line">    char *executable;</span><br><span class="line">    char **exec_argv;</span><br><span class="line">    int hz;</span><br><span class="line">    redisDb *db;</span><br><span class="line">    ...省略部分字段...</span><br><span class="line">(gdb) ptype server.port</span><br><span class="line">type = int</span><br></pre></td></tr></table></figure><p>可以看到，对于一个复合数据类型的变量，ptype 不仅列出了这个变量的类型（ 这里是一个名叫 redisServer 的结构体），而且详细地列出了每个成员变量的字段名，有了这个功能，我们在调试时就不用刻意去代码文件中查看某个变量的类型定义了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="本节课介绍了-run、continue、break、backtrace、frame、info-break、list、print-和-ptype-等命令，这些都是-GDB-调试过程中非常常用的命令，尤其是一些复合命令（如-info、break）是调试多线程程序的核心命令，请读者务必掌握。"><a href="#本节课介绍了-run、continue、break、backtrace、frame、info-break、list、print-和-ptype-等命令，这些都是-GDB-调试过程中非常常用的命令，尤其是一些复合命令（如-info、break）是调试多线程程序的核心命令，请读者务必掌握。" class="headerlink" title="本节课介绍了 run、continue、break、backtrace、frame、info break、list、print 和 ptype 等命令，这些都是 GDB 调试过程中非常常用的命令，尤其是一些复合命令（如 info、break）是调试多线程程序的核心命令，请读者务必掌握。"></a>本节课介绍了 <strong>run、continue、break、backtrace、frame、info break、list、print</strong> 和 <strong>ptype</strong> 等命令，这些都是 GDB 调试过程中非常常用的命令，尤其是一些复合命令（如 info、break）是调试多线程程序的核心命令，请读者务必掌握。</h3><hr><p>来源:<a class="link" target="_blank" rel="noopener" href="https://gitbook.cn/gitchat/column/5c0e149eedba1b683458fd5f">范蠡《Linux GDB 调试指南》<i class="fas fa-external-link-alt"></i></a></p></div><div class="post-copyright-info"><div class="article-copyright-info-container"><ul><li>本文标题：GDB 常用命令详解（上）</li><li>本文作者：白羽近墨</li><li>创建时间：2021-10-10 16:16:02</li><li>本文链接：https://keep.xpoet.cn/2021/10/10/GDB-1/</li><li>版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div></div><ul class="post-tags-box"><li class="tag-item"><a href="/tags/Linux/">#Linux</a>&nbsp;</li><li class="tag-item"><a href="/tags/C-%E5%BC%80%E5%8F%91/">#C++ 开发</a>&nbsp;</li><li class="tag-item"><a href="/tags/GDB/">#GDB</a>&nbsp;</li></ul><div class="article-nav"><div class="article-prev"><a class="prev" rel="prev" href="/2021/10/10/GDB-2/"><span class="left arrow-icon flex-center"><i class="fas fa-chevron-left"></i> </span><span class="title flex-center"><span class="post-nav-title-item">GDB 常用命令详解（中）</span> <span class="post-nav-item">上一篇</span></span></a></div><div class="article-next"><a class="next" rel="next" href="/2021/10/10/GDB-0/"><span class="title flex-center"><span class="post-nav-title-item">启动 GDB 调试</span> <span class="post-nav-item">下一篇</span> </span><span class="right arrow-icon flex-center"><i class="fas fa-chevron-right"></i></span></a></div></div><div class="comment-container"><div class="comments-container"><div id="comment-anchor"></div><div class="comment-area-title"><i class="fas fa-comments">&nbsp;评论</i></div><div class="valine-container"><script data-pjax src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script><div id="vcomments"></div><script data-pjax>function loadValine(){function e(e){switch(e){case"en":return"Author";case"zh-CN":return"博主";default:return"Master"}}new Valine({el:"#vcomments",appId:"irqOqaGORMEoxUV1bBigEGyr-gzGzoHsz",appKey:"Dkd9JB0KYotx5nS6IA6PKB6f",meta:["nick","mail","link"],avatar:"wavatar",enableQQ:!0,placeholder:"😜 尽情吐槽吧~",lang:"zh-CN".toLowerCase()});const a=setInterval(()=>{const n=document.querySelectorAll("#vcomments .vcards .vcard");if(n.length>0){let t="白羽近墨";if(t)for(let a of n){const n=a.querySelector(".vhead .vnick"),r=n.innerHTML;r===t&&(n.innerHTML=`${r} <span class="author">${e(KEEP.hexo_config.language)}</span>`)}clearInterval(a)}else clearInterval(a)},2e3)}{const e=setTimeout(()=>{loadValine(),clearTimeout(e)},1e3)}</script></div></div></div></div></div></div></div><div class="page-main-content-bottom"><footer class="footer"><div class="info-container"><div class="copyright-info info-item">&copy; <span>2020</span> - 2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">白羽近墨</a></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="website-count info-item"><span id="busuanzi_container_site_uv">访问人数&nbsp;<span id="busuanzi_value_site_uv"></span>&ensp; </span><span id="busuanzi_container_site_pv">总访问量&nbsp;<span id="busuanzi_value_site_pv"></span></span></div><div class="theme-info info-item">由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a></div></div></footer></div></div><div class="post-tools"><div class="post-tools-container"><ul class="tools-list"><li class="tools-item page-aside-toggle"><i class="fas fa-outdent"></i></li><li class="go-comment"><i class="fas fa-comment"></i></li></ul></div></div><div class="right-bottom-side-tools"><div class="side-tools-container"><ul class="side-tools-list"><li class="tools-item tool-font-adjust-plus flex-center"><i class="fas fa-search-plus"></i></li><li class="tools-item tool-font-adjust-minus flex-center"><i class="fas fa-search-minus"></i></li><li class="tools-item tool-expand-width flex-center"><i class="fas fa-arrows-alt-h"></i></li><li class="tools-item tool-dark-light-toggle flex-center"><i class="fas fa-moon"></i></li><li class="tools-item rss flex-center"><a class="flex-center" href="/atom.xml" target="_blank"><i class="fas fa-rss"></i></a></li><li class="tools-item tool-scroll-to-bottom flex-center"><i class="fas fa-arrow-down"></i></li></ul><ul class="exposed-tools-list"><li class="tools-item tool-toggle-show flex-center"><i class="fas fa-cog fa-spin"></i></li><li class="tools-item tool-scroll-to-top flex-center"><i class="arrow-up fas fa-arrow-up"></i> <span class="percent"></span></li></ul></div></div><aside class="page-aside"><div class="post-toc-wrap"><div class="post-toc"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9F%B3%E4%B9%90%E5%B0%8F%E6%B8%AF"><span class="nav-number">1.</span> <span class="nav-text">音乐小港</span></a></li></ol><li class="nav-item nav-level-1"><a class="nav-link" href="#GDB-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89"><span class="nav-number"></span> <span class="nav-text">GDB 常用命令详解（上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis-%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%B8%8E-debug-%E7%89%88%E6%9C%AC%E7%BC%96%E8%AF%91"><span class="nav-number"></span> <span class="nav-text">Redis 源码下载与 debug 版本编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#run-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">run 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#continue-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">continue 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">break 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#backtrace-%E4%B8%8E-frame-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">backtrace 与 frame 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#info-break%E3%80%81enable%E3%80%81disable-%E5%92%8C-delete-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">info break、enable、disable 和 delete 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#list-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">list 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#print-%E5%92%8C-ptype-%E5%91%BD%E4%BB%A4"><span class="nav-number"></span> <span class="nav-text">print 和 ptype 命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E8%AF%BE%E4%BB%8B%E7%BB%8D%E4%BA%86-run%E3%80%81continue%E3%80%81break%E3%80%81backtrace%E3%80%81frame%E3%80%81info-break%E3%80%81list%E3%80%81print-%E5%92%8C-ptype-%E7%AD%89%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AF-GDB-%E8%B0%83%E8%AF%95%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%9D%9E%E5%B8%B8%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%8C%E5%B0%A4%E5%85%B6%E6%98%AF%E4%B8%80%E4%BA%9B%E5%A4%8D%E5%90%88%E5%91%BD%E4%BB%A4%EF%BC%88%E5%A6%82-info%E3%80%81break%EF%BC%89%E6%98%AF%E8%B0%83%E8%AF%95%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4%EF%BC%8C%E8%AF%B7%E8%AF%BB%E8%80%85%E5%8A%A1%E5%BF%85%E6%8E%8C%E6%8F%A1%E3%80%82"><span class="nav-number"></span> <span class="nav-text">本节课介绍了 run、continue、break、backtrace、frame、info break、list、print 和 ptype 等命令，这些都是 GDB 调试过程中非常常用的命令，尤其是一些复合命令（如 info、break）是调试多线程程序的核心命令，请读者务必掌握。</span></a></li></ol></li></ol></li></div></div></aside><div class="image-viewer-container"><img src=""></div><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-input-field-pre"><i class="fas fa-keyboard"></i></span><div class="search-input-container"><input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fas fa-times"></i></span></div><div id="search-result"><div id="no-result"><i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></main><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/dark-light-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/local-search.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/code-copy.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/lazyload.js"></script><div class="post-scripts pjax"><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/toc.js"></script></div><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.5/source/js/libs/pjax.min.js"></script><script>window.addEventListener("DOMContentLoaded",()=>{window.pjax=new Pjax({selectors:["head title",".page-container",".pjax"],history:!0,debug:!1,cacheBust:!1,timeout:0,analytics:!1,currentUrlFullReload:!1,scrollRestoration:!1}),document.addEventListener("pjax:send",()=>{KEEP.utils.pjaxProgressBarStart()}),document.addEventListener("pjax:complete",()=>{KEEP.utils.pjaxProgressBarEnd(),window.pjax.executeScripts(document.querySelectorAll("script[data-pjax], .pjax script")),KEEP.refresh()})})</script></body></html>